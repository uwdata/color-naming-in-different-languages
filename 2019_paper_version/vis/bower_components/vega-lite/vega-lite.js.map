{
  "version": 3,
  "sources": [
    "node_modules/browser-pack/_prelude.js",
    "node_modules/browser-resolve/empty.js",
    "node_modules/datalib/src/util.js",
    "node_modules/json-stable-stringify/index.js",
    "node_modules/jsonify/index.js",
    "node_modules/jsonify/lib/parse.js",
    "node_modules/jsonify/lib/stringify.js",
    "src/aggregate.ts",
    "src/axis.ts",
    "src/bin.ts",
    "src/channel.ts",
    "src/compile/axis.ts",
    "src/compile/common.ts",
    "src/compile/compile.ts",
    "src/compile/config.ts",
    "src/compile/data/bin.ts",
    "src/compile/data/colorrank.ts",
    "src/compile/data/data.ts",
    "src/compile/data/filter.ts",
    "src/compile/data/formatparse.ts",
    "src/compile/data/formula.ts",
    "src/compile/data/nonpositivenullfilter.ts",
    "src/compile/data/nullfilter.ts",
    "src/compile/data/source.ts",
    "src/compile/data/stackscale.ts",
    "src/compile/data/summary.ts",
    "src/compile/data/timeunit.ts",
    "src/compile/data/timeunitdomain.ts",
    "src/compile/facet.ts",
    "src/compile/layer.ts",
    "src/compile/layout.ts",
    "src/compile/legend.ts",
    "src/compile/mark/area.ts",
    "src/compile/mark/bar.ts",
    "src/compile/mark/line.ts",
    "src/compile/mark/mark.ts",
    "src/compile/mark/point.ts",
    "src/compile/mark/rule.ts",
    "src/compile/mark/text.ts",
    "src/compile/mark/tick.ts",
    "src/compile/model.ts",
    "src/compile/scale.ts",
    "src/compile/unit.ts",
    "src/config.ts",
    "src/data.ts",
    "src/datetime.ts",
    "src/encoding.ts",
    "src/fielddef.ts",
    "src/filter.ts",
    "src/legend.ts",
    "src/mark.ts",
    "src/scale.ts",
    "src/shorthand.ts",
    "src/sort.ts",
    "src/spec.ts",
    "src/stack.ts",
    "src/timeunit.ts",
    "src/type.ts",
    "src/util.ts",
    "src/validate.ts",
    "src/vega.schema.ts",
    "src/vl.ts"
  ],
  "names": [],
  "mappings": "AAAA;ACAA;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AC1SA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpFA;AACA;AACA;;ACFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACzJA,WAAY,WAAW;IACnB,oCAAS,QAAe,YAAA,CAAA;IACxB,mCAAQ,OAAc,WAAA,CAAA;IACtB,mCAAQ,OAAc,WAAA,CAAA;IACtB,qCAAU,SAAgB,aAAA,CAAA;IAC1B,sCAAW,UAAiB,cAAA,CAAA;IAC5B,iCAAM,KAAY,SAAA,CAAA;IAClB,kCAAO,MAAa,UAAA,CAAA;IACpB,qCAAU,SAAgB,aAAA,CAAA;IAC1B,sCAAW,UAAiB,cAAA,CAAA;IAC5B,uCAAY,WAAkB,eAAA,CAAA;IAC9B,mCAAQ,OAAc,WAAA,CAAA;IACtB,oCAAS,QAAe,YAAA,CAAA;IACxB,oCAAS,QAAe,YAAA,CAAA;IACxB,gCAAK,IAAW,QAAA,CAAA;IAChB,gCAAK,IAAW,QAAA,CAAA;IAChB,sCAAW,UAAiB,cAAA,CAAA;IAC5B,iCAAM,KAAY,SAAA,CAAA;IAClB,iCAAM,KAAY,SAAA,CAAA;IAClB,oCAAS,QAAe,YAAA,CAAA;IACxB,oCAAS,QAAe,YAAA,CAAA;AAC5B,CAAC,EArBW,mBAAW,KAAX,mBAAW,QAqBtB;AArBD,IAAY,WAAW,GAAX,mBAqBX,CAAA;AAEY,qBAAa,GAAG;IACzB,WAAW,CAAC,MAAM;IAClB,WAAW,CAAC,KAAK;IAC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",
  "file": "generated.js",
  "sourceRoot": "",
  "sourcesContent": [
    "(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})",
    "",
    "var u = module.exports;\n\n// utility functions\n\nvar FNAME = '__name__';\n\nu.namedfunc = function(name, f) { return (f[FNAME] = name, f); };\n\nu.name = function(f) { return f==null ? null : f[FNAME]; };\n\nu.identity = function(x) { return x; };\n\nu.true = u.namedfunc('true', function() { return true; });\n\nu.false = u.namedfunc('false', function() { return false; });\n\nu.duplicate = function(obj) {\n  return JSON.parse(JSON.stringify(obj));\n};\n\nu.equal = function(a, b) {\n  return JSON.stringify(a) === JSON.stringify(b);\n};\n\nu.extend = function(obj) {\n  for (var x, name, i=1, len=arguments.length; i<len; ++i) {\n    x = arguments[i];\n    for (name in x) { obj[name] = x[name]; }\n  }\n  return obj;\n};\n\nu.length = function(x) {\n  return x != null && x.length != null ? x.length : null;\n};\n\nu.keys = function(x) {\n  var keys = [], k;\n  for (k in x) keys.push(k);\n  return keys;\n};\n\nu.vals = function(x) {\n  var vals = [], k;\n  for (k in x) vals.push(x[k]);\n  return vals;\n};\n\nu.toMap = function(list, f) {\n  return (f = u.$(f)) ?\n    list.reduce(function(obj, x) { return (obj[f(x)] = 1, obj); }, {}) :\n    list.reduce(function(obj, x) { return (obj[x] = 1, obj); }, {});\n};\n\nu.keystr = function(values) {\n  // use to ensure consistent key generation across modules\n  var n = values.length;\n  if (!n) return '';\n  for (var s=String(values[0]), i=1; i<n; ++i) {\n    s += '|' + String(values[i]);\n  }\n  return s;\n};\n\n// type checking functions\n\nvar toString = Object.prototype.toString;\n\nu.isObject = function(obj) {\n  return obj === Object(obj);\n};\n\nu.isFunction = function(obj) {\n  return toString.call(obj) === '[object Function]';\n};\n\nu.isString = function(obj) {\n  return typeof value === 'string' || toString.call(obj) === '[object String]';\n};\n\nu.isArray = Array.isArray || function(obj) {\n  return toString.call(obj) === '[object Array]';\n};\n\nu.isNumber = function(obj) {\n  return typeof obj === 'number' || toString.call(obj) === '[object Number]';\n};\n\nu.isBoolean = function(obj) {\n  return obj === true || obj === false || toString.call(obj) == '[object Boolean]';\n};\n\nu.isDate = function(obj) {\n  return toString.call(obj) === '[object Date]';\n};\n\nu.isValid = function(obj) {\n  return obj != null && obj === obj;\n};\n\nu.isBuffer = (typeof Buffer === 'function' && Buffer.isBuffer) || u.false;\n\n// type coercion functions\n\nu.number = function(s) {\n  return s == null || s === '' ? null : +s;\n};\n\nu.boolean = function(s) {\n  return s == null || s === '' ? null : s==='false' ? false : !!s;\n};\n\n// parse a date with optional d3.time-format format\nu.date = function(s, format) {\n  var d = format ? format : Date;\n  return s == null || s === '' ? null : d.parse(s);\n};\n\nu.array = function(x) {\n  return x != null ? (u.isArray(x) ? x : [x]) : [];\n};\n\nu.str = function(x) {\n  return u.isArray(x) ? '[' + x.map(u.str) + ']'\n    : u.isObject(x) || u.isString(x) ?\n      // Output valid JSON and JS source strings.\n      // See http://timelessrepo.com/json-isnt-a-javascript-subset\n      JSON.stringify(x).replace('\\u2028','\\\\u2028').replace('\\u2029', '\\\\u2029')\n    : x;\n};\n\n// data access functions\n\nvar field_re = /\\[(.*?)\\]|[^.\\[]+/g;\n\nu.field = function(f) {\n  return String(f).match(field_re).map(function(d) {\n    return d[0] !== '[' ? d :\n      d[1] !== \"'\" && d[1] !== '\"' ? d.slice(1, -1) :\n      d.slice(2, -2).replace(/\\\\([\"'])/g, '$1');\n  });\n};\n\nu.accessor = function(f) {\n  /* jshint evil: true */\n  return f==null || u.isFunction(f) ? f :\n    u.namedfunc(f, Function('x', 'return x[' + u.field(f).map(u.str).join('][') + '];'));\n};\n\n// short-cut for accessor\nu.$ = u.accessor;\n\nu.mutator = function(f) {\n  var s;\n  return u.isString(f) && (s=u.field(f)).length > 1 ?\n    function(x, v) {\n      for (var i=0; i<s.length-1; ++i) x = x[s[i]];\n      x[s[i]] = v;\n    } :\n    function(x, v) { x[f] = v; };\n};\n\n\nu.$func = function(name, op) {\n  return function(f) {\n    f = u.$(f) || u.identity;\n    var n = name + (u.name(f) ? '_'+u.name(f) : '');\n    return u.namedfunc(n, function(d) { return op(f(d)); });\n  };\n};\n\nu.$valid  = u.$func('valid', u.isValid);\nu.$length = u.$func('length', u.length);\n\nu.$in = function(f, values) {\n  f = u.$(f);\n  var map = u.isArray(values) ? u.toMap(values) : values;\n  return function(d) { return !!map[f(d)]; };\n};\n\n// comparison / sorting functions\n\nu.comparator = function(sort) {\n  var sign = [];\n  if (sort === undefined) sort = [];\n  sort = u.array(sort).map(function(f) {\n    var s = 1;\n    if      (f[0] === '-') { s = -1; f = f.slice(1); }\n    else if (f[0] === '+') { s = +1; f = f.slice(1); }\n    sign.push(s);\n    return u.accessor(f);\n  });\n  return function(a, b) {\n    var i, n, f, c;\n    for (i=0, n=sort.length; i<n; ++i) {\n      f = sort[i];\n      c = u.cmp(f(a), f(b));\n      if (c) return c * sign[i];\n    }\n    return 0;\n  };\n};\n\nu.cmp = function(a, b) {\n  return (a < b || a == null) && b != null ? -1 :\n    (a > b || b == null) && a != null ? 1 :\n    ((b = b instanceof Date ? +b : b),\n     (a = a instanceof Date ? +a : a)) !== a && b === b ? -1 :\n    b !== b && a === a ? 1 : 0;\n};\n\nu.numcmp = function(a, b) { return a - b; };\n\nu.stablesort = function(array, sortBy, keyFn) {\n  var indices = array.reduce(function(idx, v, i) {\n    return (idx[keyFn(v)] = i, idx);\n  }, {});\n\n  array.sort(function(a, b) {\n    var sa = sortBy(a),\n        sb = sortBy(b);\n    return sa < sb ? -1 : sa > sb ? 1\n         : (indices[keyFn(a)] - indices[keyFn(b)]);\n  });\n\n  return array;\n};\n\n// permutes an array using a Knuth shuffle\nu.permute = function(a) {\n  var m = a.length,\n      swap,\n      i;\n\n  while (m) {\n    i = Math.floor(Math.random() * m--);\n    swap = a[m];\n    a[m] = a[i];\n    a[i] = swap;\n  }\n};\n\n// string functions\n\nu.pad = function(s, length, pos, padchar) {\n  padchar = padchar || \" \";\n  var d = length - s.length;\n  if (d <= 0) return s;\n  switch (pos) {\n    case 'left':\n      return strrep(d, padchar) + s;\n    case 'middle':\n    case 'center':\n      return strrep(Math.floor(d/2), padchar) +\n         s + strrep(Math.ceil(d/2), padchar);\n    default:\n      return s + strrep(d, padchar);\n  }\n};\n\nfunction strrep(n, str) {\n  var s = \"\", i;\n  for (i=0; i<n; ++i) s += str;\n  return s;\n}\n\nu.truncate = function(s, length, pos, word, ellipsis) {\n  var len = s.length;\n  if (len <= length) return s;\n  ellipsis = ellipsis !== undefined ? String(ellipsis) : '\\u2026';\n  var l = Math.max(0, length - ellipsis.length);\n\n  switch (pos) {\n    case 'left':\n      return ellipsis + (word ? truncateOnWord(s,l,1) : s.slice(len-l));\n    case 'middle':\n    case 'center':\n      var l1 = Math.ceil(l/2), l2 = Math.floor(l/2);\n      return (word ? truncateOnWord(s,l1) : s.slice(0,l1)) +\n        ellipsis + (word ? truncateOnWord(s,l2,1) : s.slice(len-l2));\n    default:\n      return (word ? truncateOnWord(s,l) : s.slice(0,l)) + ellipsis;\n  }\n};\n\nfunction truncateOnWord(s, len, rev) {\n  var cnt = 0, tok = s.split(truncate_word_re);\n  if (rev) {\n    s = (tok = tok.reverse())\n      .filter(function(w) { cnt += w.length; return cnt <= len; })\n      .reverse();\n  } else {\n    s = tok.filter(function(w) { cnt += w.length; return cnt <= len; });\n  }\n  return s.length ? s.join('').trim() : tok[0].slice(0, len);\n}\n\nvar truncate_word_re = /([\\u0009\\u000A\\u000B\\u000C\\u000D\\u0020\\u00A0\\u1680\\u180E\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200A\\u202F\\u205F\\u2028\\u2029\\u3000\\uFEFF])/;\n",
    "var json = typeof JSON !== 'undefined' ? JSON : require('jsonify');\n\nmodule.exports = function (obj, opts) {\n    if (!opts) opts = {};\n    if (typeof opts === 'function') opts = { cmp: opts };\n    var space = opts.space || '';\n    if (typeof space === 'number') space = Array(space+1).join(' ');\n    var cycles = (typeof opts.cycles === 'boolean') ? opts.cycles : false;\n    var replacer = opts.replacer || function(key, value) { return value; };\n\n    var cmp = opts.cmp && (function (f) {\n        return function (node) {\n            return function (a, b) {\n                var aobj = { key: a, value: node[a] };\n                var bobj = { key: b, value: node[b] };\n                return f(aobj, bobj);\n            };\n        };\n    })(opts.cmp);\n\n    var seen = [];\n    return (function stringify (parent, key, node, level) {\n        var indent = space ? ('\\n' + new Array(level + 1).join(space)) : '';\n        var colonSeparator = space ? ': ' : ':';\n\n        if (node && node.toJSON && typeof node.toJSON === 'function') {\n            node = node.toJSON();\n        }\n\n        node = replacer.call(parent, key, node);\n\n        if (node === undefined) {\n            return;\n        }\n        if (typeof node !== 'object' || node === null) {\n            return json.stringify(node);\n        }\n        if (isArray(node)) {\n            var out = [];\n            for (var i = 0; i < node.length; i++) {\n                var item = stringify(node, i, node[i], level+1) || json.stringify(null);\n                out.push(indent + space + item);\n            }\n            return '[' + out.join(',') + indent + ']';\n        }\n        else {\n            if (seen.indexOf(node) !== -1) {\n                if (cycles) return json.stringify('__cycle__');\n                throw new TypeError('Converting circular structure to JSON');\n            }\n            else seen.push(node);\n\n            var keys = objectKeys(node).sort(cmp && cmp(node));\n            var out = [];\n            for (var i = 0; i < keys.length; i++) {\n                var key = keys[i];\n                var value = stringify(node, key, node[key], level+1);\n\n                if(!value) continue;\n\n                var keyValue = json.stringify(key)\n                    + colonSeparator\n                    + value;\n                ;\n                out.push(indent + space + keyValue);\n            }\n            seen.splice(seen.indexOf(node), 1);\n            return '{' + out.join(',') + indent + '}';\n        }\n    })({ '': obj }, '', obj, 0);\n};\n\nvar isArray = Array.isArray || function (x) {\n    return {}.toString.call(x) === '[object Array]';\n};\n\nvar objectKeys = Object.keys || function (obj) {\n    var has = Object.prototype.hasOwnProperty || function () { return true };\n    var keys = [];\n    for (var key in obj) {\n        if (has.call(obj, key)) keys.push(key);\n    }\n    return keys;\n};\n",
    "exports.parse = require('./lib/parse');\nexports.stringify = require('./lib/stringify');\n",
    "var at, // The index of the current character\n    ch, // The current character\n    escapee = {\n        '\"':  '\"',\n        '\\\\': '\\\\',\n        '/':  '/',\n        b:    '\\b',\n        f:    '\\f',\n        n:    '\\n',\n        r:    '\\r',\n        t:    '\\t'\n    },\n    text,\n\n    error = function (m) {\n        // Call error when something is wrong.\n        throw {\n            name:    'SyntaxError',\n            message: m,\n            at:      at,\n            text:    text\n        };\n    },\n    \n    next = function (c) {\n        // If a c parameter is provided, verify that it matches the current character.\n        if (c && c !== ch) {\n            error(\"Expected '\" + c + \"' instead of '\" + ch + \"'\");\n        }\n        \n        // Get the next character. When there are no more characters,\n        // return the empty string.\n        \n        ch = text.charAt(at);\n        at += 1;\n        return ch;\n    },\n    \n    number = function () {\n        // Parse a number value.\n        var number,\n            string = '';\n        \n        if (ch === '-') {\n            string = '-';\n            next('-');\n        }\n        while (ch >= '0' && ch <= '9') {\n            string += ch;\n            next();\n        }\n        if (ch === '.') {\n            string += '.';\n            while (next() && ch >= '0' && ch <= '9') {\n                string += ch;\n            }\n        }\n        if (ch === 'e' || ch === 'E') {\n            string += ch;\n            next();\n            if (ch === '-' || ch === '+') {\n                string += ch;\n                next();\n            }\n            while (ch >= '0' && ch <= '9') {\n                string += ch;\n                next();\n            }\n        }\n        number = +string;\n        if (!isFinite(number)) {\n            error(\"Bad number\");\n        } else {\n            return number;\n        }\n    },\n    \n    string = function () {\n        // Parse a string value.\n        var hex,\n            i,\n            string = '',\n            uffff;\n        \n        // When parsing for string values, we must look for \" and \\ characters.\n        if (ch === '\"') {\n            while (next()) {\n                if (ch === '\"') {\n                    next();\n                    return string;\n                } else if (ch === '\\\\') {\n                    next();\n                    if (ch === 'u') {\n                        uffff = 0;\n                        for (i = 0; i < 4; i += 1) {\n                            hex = parseInt(next(), 16);\n                            if (!isFinite(hex)) {\n                                break;\n                            }\n                            uffff = uffff * 16 + hex;\n                        }\n                        string += String.fromCharCode(uffff);\n                    } else if (typeof escapee[ch] === 'string') {\n                        string += escapee[ch];\n                    } else {\n                        break;\n                    }\n                } else {\n                    string += ch;\n                }\n            }\n        }\n        error(\"Bad string\");\n    },\n\n    white = function () {\n\n// Skip whitespace.\n\n        while (ch && ch <= ' ') {\n            next();\n        }\n    },\n\n    word = function () {\n\n// true, false, or null.\n\n        switch (ch) {\n        case 't':\n            next('t');\n            next('r');\n            next('u');\n            next('e');\n            return true;\n        case 'f':\n            next('f');\n            next('a');\n            next('l');\n            next('s');\n            next('e');\n            return false;\n        case 'n':\n            next('n');\n            next('u');\n            next('l');\n            next('l');\n            return null;\n        }\n        error(\"Unexpected '\" + ch + \"'\");\n    },\n\n    value,  // Place holder for the value function.\n\n    array = function () {\n\n// Parse an array value.\n\n        var array = [];\n\n        if (ch === '[') {\n            next('[');\n            white();\n            if (ch === ']') {\n                next(']');\n                return array;   // empty array\n            }\n            while (ch) {\n                array.push(value());\n                white();\n                if (ch === ']') {\n                    next(']');\n                    return array;\n                }\n                next(',');\n                white();\n            }\n        }\n        error(\"Bad array\");\n    },\n\n    object = function () {\n\n// Parse an object value.\n\n        var key,\n            object = {};\n\n        if (ch === '{') {\n            next('{');\n            white();\n            if (ch === '}') {\n                next('}');\n                return object;   // empty object\n            }\n            while (ch) {\n                key = string();\n                white();\n                next(':');\n                if (Object.hasOwnProperty.call(object, key)) {\n                    error('Duplicate key \"' + key + '\"');\n                }\n                object[key] = value();\n                white();\n                if (ch === '}') {\n                    next('}');\n                    return object;\n                }\n                next(',');\n                white();\n            }\n        }\n        error(\"Bad object\");\n    };\n\nvalue = function () {\n\n// Parse a JSON value. It could be an object, an array, a string, a number,\n// or a word.\n\n    white();\n    switch (ch) {\n    case '{':\n        return object();\n    case '[':\n        return array();\n    case '\"':\n        return string();\n    case '-':\n        return number();\n    default:\n        return ch >= '0' && ch <= '9' ? number() : word();\n    }\n};\n\n// Return the json_parse function. It will have access to all of the above\n// functions and variables.\n\nmodule.exports = function (source, reviver) {\n    var result;\n    \n    text = source;\n    at = 0;\n    ch = ' ';\n    result = value();\n    white();\n    if (ch) {\n        error(\"Syntax error\");\n    }\n\n    // If there is a reviver function, we recursively walk the new structure,\n    // passing each name/value pair to the reviver function for possible\n    // transformation, starting with a temporary root object that holds the result\n    // in an empty key. If there is not a reviver function, we simply return the\n    // result.\n\n    return typeof reviver === 'function' ? (function walk(holder, key) {\n        var k, v, value = holder[key];\n        if (value && typeof value === 'object') {\n            for (k in value) {\n                if (Object.prototype.hasOwnProperty.call(value, k)) {\n                    v = walk(value, k);\n                    if (v !== undefined) {\n                        value[k] = v;\n                    } else {\n                        delete value[k];\n                    }\n                }\n            }\n        }\n        return reviver.call(holder, key, value);\n    }({'': result}, '')) : result;\n};\n",
    "var cx = /[\\u0000\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/g,\n    escapable = /[\\\\\\\"\\x00-\\x1f\\x7f-\\x9f\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/g,\n    gap,\n    indent,\n    meta = {    // table of character substitutions\n        '\\b': '\\\\b',\n        '\\t': '\\\\t',\n        '\\n': '\\\\n',\n        '\\f': '\\\\f',\n        '\\r': '\\\\r',\n        '\"' : '\\\\\"',\n        '\\\\': '\\\\\\\\'\n    },\n    rep;\n\nfunction quote(string) {\n    // If the string contains no control characters, no quote characters, and no\n    // backslash characters, then we can safely slap some quotes around it.\n    // Otherwise we must also replace the offending characters with safe escape\n    // sequences.\n    \n    escapable.lastIndex = 0;\n    return escapable.test(string) ? '\"' + string.replace(escapable, function (a) {\n        var c = meta[a];\n        return typeof c === 'string' ? c :\n            '\\\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);\n    }) + '\"' : '\"' + string + '\"';\n}\n\nfunction str(key, holder) {\n    // Produce a string from holder[key].\n    var i,          // The loop counter.\n        k,          // The member key.\n        v,          // The member value.\n        length,\n        mind = gap,\n        partial,\n        value = holder[key];\n    \n    // If the value has a toJSON method, call it to obtain a replacement value.\n    if (value && typeof value === 'object' &&\n            typeof value.toJSON === 'function') {\n        value = value.toJSON(key);\n    }\n    \n    // If we were called with a replacer function, then call the replacer to\n    // obtain a replacement value.\n    if (typeof rep === 'function') {\n        value = rep.call(holder, key, value);\n    }\n    \n    // What happens next depends on the value's type.\n    switch (typeof value) {\n        case 'string':\n            return quote(value);\n        \n        case 'number':\n            // JSON numbers must be finite. Encode non-finite numbers as null.\n            return isFinite(value) ? String(value) : 'null';\n        \n        case 'boolean':\n        case 'null':\n            // If the value is a boolean or null, convert it to a string. Note:\n            // typeof null does not produce 'null'. The case is included here in\n            // the remote chance that this gets fixed someday.\n            return String(value);\n            \n        case 'object':\n            if (!value) return 'null';\n            gap += indent;\n            partial = [];\n            \n            // Array.isArray\n            if (Object.prototype.toString.apply(value) === '[object Array]') {\n                length = value.length;\n                for (i = 0; i < length; i += 1) {\n                    partial[i] = str(i, value) || 'null';\n                }\n                \n                // Join all of the elements together, separated with commas, and\n                // wrap them in brackets.\n                v = partial.length === 0 ? '[]' : gap ?\n                    '[\\n' + gap + partial.join(',\\n' + gap) + '\\n' + mind + ']' :\n                    '[' + partial.join(',') + ']';\n                gap = mind;\n                return v;\n            }\n            \n            // If the replacer is an array, use it to select the members to be\n            // stringified.\n            if (rep && typeof rep === 'object') {\n                length = rep.length;\n                for (i = 0; i < length; i += 1) {\n                    k = rep[i];\n                    if (typeof k === 'string') {\n                        v = str(k, value);\n                        if (v) {\n                            partial.push(quote(k) + (gap ? ': ' : ':') + v);\n                        }\n                    }\n                }\n            }\n            else {\n                // Otherwise, iterate through all of the keys in the object.\n                for (k in value) {\n                    if (Object.prototype.hasOwnProperty.call(value, k)) {\n                        v = str(k, value);\n                        if (v) {\n                            partial.push(quote(k) + (gap ? ': ' : ':') + v);\n                        }\n                    }\n                }\n            }\n            \n        // Join all of the member texts together, separated with commas,\n        // and wrap them in braces.\n\n        v = partial.length === 0 ? '{}' : gap ?\n            '{\\n' + gap + partial.join(',\\n' + gap) + '\\n' + mind + '}' :\n            '{' + partial.join(',') + '}';\n        gap = mind;\n        return v;\n    }\n}\n\nmodule.exports = function (value, replacer, space) {\n    var i;\n    gap = '';\n    indent = '';\n    \n    // If the space parameter is a number, make an indent string containing that\n    // many spaces.\n    if (typeof space === 'number') {\n        for (i = 0; i < space; i += 1) {\n            indent += ' ';\n        }\n    }\n    // If the space parameter is a string, it will be used as the indent string.\n    else if (typeof space === 'string') {\n        indent = space;\n    }\n\n    // If there is a replacer, it must be a function or an array.\n    // Otherwise, throw an error.\n    rep = replacer;\n    if (replacer && typeof replacer !== 'function'\n    && (typeof replacer !== 'object' || typeof replacer.length !== 'number')) {\n        throw new Error('JSON.stringify');\n    }\n    \n    // Make a fake root object containing our value under the key of ''.\n    // Return the result of stringifying the value.\n    return str('', {'': value});\n};\n",
    "\nexport enum AggregateOp {\n    VALUES = 'values' as any,\n    COUNT = 'count' as any,\n    VALID = 'valid' as any,\n    MISSING = 'missing' as any,\n    DISTINCT = 'distinct' as any,\n    SUM = 'sum' as any,\n    MEAN = 'mean' as any,\n    AVERAGE = 'average' as any,\n    VARIANCE = 'variance' as any,\n    VARIANCEP = 'variancep' as any,\n    STDEV = 'stdev' as any,\n    STDEVP = 'stdevp' as any,\n    MEDIAN = 'median' as any,\n    Q1 = 'q1' as any,\n    Q3 = 'q3' as any,\n    MODESKEW = 'modeskew' as any,\n    MIN = 'min' as any,\n    MAX = 'max' as any,\n    ARGMIN = 'argmin' as any,\n    ARGMAX = 'argmax' as any,\n}\n\nexport const AGGREGATE_OPS = [\n    AggregateOp.VALUES,\n    AggregateOp.COUNT,\n    AggregateOp.VALID,\n    AggregateOp.MISSING,\n    AggregateOp.DISTINCT,\n    AggregateOp.SUM,\n    AggregateOp.MEAN,\n    AggregateOp.AVERAGE,\n    AggregateOp.VARIANCE,\n    AggregateOp.VARIANCEP,\n    AggregateOp.STDEV,\n    AggregateOp.STDEVP,\n    AggregateOp.MEDIAN,\n    AggregateOp.Q1,\n    AggregateOp.Q3,\n    AggregateOp.MODESKEW,\n    AggregateOp.MIN,\n    AggregateOp.MAX,\n    AggregateOp.ARGMIN,\n    AggregateOp.ARGMAX,\n];\n\n/** Additive-based aggregation operations.  These can be applied to stack. */\nexport const SUM_OPS = [\n    AggregateOp.COUNT,\n    AggregateOp.SUM,\n    AggregateOp.DISTINCT\n];\n\nexport const SHARED_DOMAIN_OPS = [\n    AggregateOp.MEAN,\n    AggregateOp.AVERAGE,\n    AggregateOp.STDEV,\n    AggregateOp.STDEVP,\n    AggregateOp.MEDIAN,\n    AggregateOp.Q1,\n    AggregateOp.Q3,\n    AggregateOp.MIN,\n    AggregateOp.MAX,\n];\n",
    "\nexport enum AxisOrient {\n    TOP = 'top' as any,\n    RIGHT = 'right' as any,\n    LEFT = 'left' as any,\n    BOTTOM = 'bottom' as any\n}\n\nexport interface AxisConfig {\n  // ---------- General ----------\n  /**\n   * Width of the axis line\n   */\n  axisWidth?: number;\n  /**\n   * A string indicating if the axis (and any gridlines) should be placed above or below the data marks.\n   */\n  layer?: string;\n  /**\n   * The offset, in pixels, by which to displace the axis from the edge of the enclosing group or data rectangle.\n   */\n  offset?: number;\n\n  // ---------- Axis ----------\n  /**\n   * Color of axis line.\n   */\n  axisColor?: string;\n\n  // ---------- Grid ----------\n  /**\n   * A flag indicate if gridlines should be created in addition to ticks. If `grid` is unspecified, the default value is `true` for ROW and COL. For X and Y, the default value is `true` for quantitative and time fields and `false` otherwise.\n   */\n  grid?: boolean;\n\n  /**\n   * Color of gridlines.\n   */\n  gridColor?: string;\n\n  /**\n   * The offset (in pixels) into which to begin drawing with the grid dash array.\n   */\n  gridDash?: number[];\n\n  /**\n   * The stroke opacity of grid (value between [0,1])\n   */\n  gridOpacity?: number;\n\n  /**\n   * The grid width, in pixels.\n   */\n  gridWidth?: number;\n\n  // ---------- Labels ----------\n  /**\n   * Enable or disable labels.\n   */\n  labels?: boolean;\n  /**\n   * The rotation angle of the axis labels.\n   */\n  labelAngle?: number;\n  /**\n   * Text alignment for the Label.\n   */\n  labelAlign?: string;\n  /**\n   * Text baseline for the label.\n   */\n  labelBaseline?: string;\n  /**\n   * Truncate labels that are too long.\n   * @minimum 1\n   */\n  labelMaxLength?: number;\n  /**\n   * Whether month and day names should be abbreviated.\n   */\n  shortTimeLabels?: boolean;\n\n  // ---------- Ticks ----------\n  /**\n   * If provided, sets the number of minor ticks between major ticks (the value 9 results in decimal subdivision). Only applicable for axes visualizing quantitative scales.\n   */\n  subdivide?: number;\n  /**\n   * A desired number of ticks, for axes visualizing quantitative scales. The resulting number may be different so that values are \"nice\" (multiples of 2, 5, 10) and lie within the underlying scale's range.\n   * @minimum 0\n   */\n  ticks?: number;\n\n  /**\n   * The color of the axis's tick.\n   */\n  tickColor?: string;\n\n  /**\n   * The color of the tick label, can be in hex color code or regular color name.\n   */\n  tickLabelColor?: string;\n\n  /**\n   * The font of the tick label.\n   */\n  tickLabelFont?: string;\n\n  /**\n   * The font size of label, in pixels.\n   */\n  tickLabelFontSize?: number;\n\n  /**\n   * The padding, in pixels, between ticks and text labels.\n   */\n  tickPadding?: number;\n  /**\n   * The size, in pixels, of major, minor and end ticks.\n   * @minimum 0\n   */\n  tickSize?: number;\n  /**\n   * The size, in pixels, of major ticks.\n   * @minimum 0\n   */\n  tickSizeMajor?: number;\n  /**\n   * The size, in pixels, of minor ticks.\n   * @minimum 0\n   */\n  tickSizeMinor?: number;\n  /**\n   * The size, in pixels, of end ticks.\n   * @minimum 0\n   */\n  tickSizeEnd?: number;\n\n  /**\n   * The width, in pixels, of ticks.\n   */\n  tickWidth?: number;\n\n  // ---------- Title ----------\n  /**\n   * Color of the title, can be in hex color code or regular color name.\n   */\n  titleColor?: string;\n\n  /**\n   * Font of the title.\n   */\n  titleFont?: string;\n\n  /**\n   * Size of the title.\n   */\n  titleFontSize?: number;\n\n  /**\n   * Weight of the title.\n   */\n  titleFontWeight?: string;\n\n  /**\n   * A title offset value for the axis.\n   */\n  titleOffset?: number;\n  /**\n   * Max length for axis title if the title is automatically generated from the field's description. By default, this is automatically based on cell size and characterWidth property.\n   * @minimum 0\n   */\n  titleMaxLength?: number;\n  /**\n   * Character width for automatically determining title max length.\n   */\n  characterWidth?: number;\n\n  // ---------- Other ----------\n  /**\n   * Optional mark property definitions for custom axis styling.\n   */\n  properties?: any; // TODO: replace\n}\n\n// TODO: add comment for properties that we rely on Vega's default to produce\n// more concise Vega output.\n\nexport const defaultAxisConfig: AxisConfig = {\n  offset: undefined, // implicitly 0\n  grid: undefined, // automatically determined\n  labels: true,\n  labelMaxLength: 25,\n  tickSize: undefined, // implicitly 6\n  characterWidth: 6\n};\n\nexport const defaultFacetAxisConfig: AxisConfig = {\n  axisWidth: 0,\n  labels: true,\n  grid: false,\n  tickSize: 0\n};\n\nexport interface Axis extends AxisConfig {\n  /**\n   * The rotation angle of the axis labels.\n   */\n  labelAngle?: number;\n  /**\n   * The formatting pattern for axis labels.\n   */\n  format?: string; // default value determined by config.format anyway\n  /**\n   * The orientation of the axis. One of top, bottom, left or right. The orientation can be used to further specialize the axis type (e.g., a y axis oriented for the right edge of the chart).\n   */\n  orient?: AxisOrient;\n  /**\n   * A title for the axis. Shows field name and its function by default.\n   */\n  title?: string;\n  values?: number[];\n}\n",
    "import {Channel, ROW, COLUMN, SHAPE, SIZE} from './channel';\n\n/**\n * Binning properties or boolean flag for determining whether to bin data or not.\n */\nexport interface Bin {\n  /**\n   * The minimum bin value to consider. If unspecified, the minimum value of the specified field is used.\n   */\n  min?: number;\n  /**\n   * The maximum bin value to consider. If unspecified, the maximum value of the specified field is used.\n   */\n  max?: number;\n  /**\n   * The number base to use for automatic bin determination (default is base 10).\n   */\n  base?: number;\n  /**\n   * An exact step size to use between bins. If provided, options such as maxbins will be ignored.\n   */\n  step?: number;\n  /**\n   * An array of allowable step sizes to choose from.\n   */\n  steps?: number[];\n  /**\n   * A minimum allowable step size (particularly useful for integer values).\n   */\n  minstep?: number;\n  /**\n   * Scale factors indicating allowable subdivisions. The default value is [5, 2], which indicates that for base 10 numbers (the default base), the method may consider dividing bin sizes by 5 and/or 2. For example, for an initial step size of 10, the method can check if bin sizes of 2 (= 10/5), 5 (= 10/2), or 1 (= 10/(5*2)) might also satisfy the given constraints.\n   */\n  div?: number[];\n  /**\n   * Maximum number of bins.\n   * @minimum 2\n   */\n  maxbins?: number;\n}\n\nexport function autoMaxBins(channel: Channel): number {\n  switch (channel) {\n    case ROW:\n    case COLUMN:\n    case SIZE:\n      // Facets and Size shouldn't have too many bins\n      // We choose 6 like shape to simplify the rule\n    case SHAPE:\n      return 6; // Vega's \"shape\" has 6 distinct values\n    default:\n      return 10;\n  }\n}\n",
    "/*\n * Constants and utilities for encoding channels (Visual variables)\n * such as 'x', 'y', 'color'.\n */\n\nimport {Mark} from './mark';\nimport {contains, without} from './util';\n\nexport enum Channel {\n  X = 'x' as any,\n  Y = 'y' as any,\n  X2 = 'x2' as any,\n  Y2 = 'y2' as any,\n  ROW = 'row' as any,\n  COLUMN = 'column' as any,\n  SHAPE = 'shape' as any,\n  SIZE = 'size' as any,\n  COLOR = 'color' as any,\n  TEXT = 'text' as any,\n  DETAIL = 'detail' as any,\n  LABEL = 'label' as any,\n  PATH = 'path' as any,\n  ORDER = 'order' as any,\n  OPACITY = 'opacity' as any\n}\n\nexport const X = Channel.X;\nexport const Y = Channel.Y;\nexport const X2 = Channel.X2;\nexport const Y2 = Channel.Y2;\nexport const ROW = Channel.ROW;\nexport const COLUMN = Channel.COLUMN;\nexport const SHAPE = Channel.SHAPE;\nexport const SIZE = Channel.SIZE;\nexport const COLOR = Channel.COLOR;\nexport const TEXT = Channel.TEXT;\nexport const DETAIL = Channel.DETAIL;\nexport const LABEL = Channel.LABEL;\nexport const PATH = Channel.PATH;\nexport const ORDER = Channel.ORDER;\nexport const OPACITY = Channel.OPACITY;\n\nexport const CHANNELS = [X, Y, X2, Y2, ROW, COLUMN, SIZE, SHAPE, COLOR, PATH, ORDER, OPACITY, TEXT, DETAIL, LABEL];\n\nexport const UNIT_CHANNELS = without(CHANNELS, [ROW, COLUMN]);\nexport const UNIT_SCALE_CHANNELS = without(UNIT_CHANNELS, [PATH, ORDER, DETAIL, TEXT, LABEL, X2, Y2]);\nexport const NONSPATIAL_CHANNELS = without(UNIT_CHANNELS, [X, Y, X2, Y2]);\nexport const NONSPATIAL_SCALE_CHANNELS = without(UNIT_SCALE_CHANNELS, [X, Y, X2, Y2]);\n\n/** Channels that can serve as groupings for stacked charts. */\nexport const STACK_GROUP_CHANNELS = [COLOR, DETAIL, ORDER, OPACITY, SIZE];\n\nexport interface SupportedMark {\n  point?: boolean;\n  tick?: boolean;\n  rule?: boolean;\n  circle?: boolean;\n  square?: boolean;\n  bar?: boolean;\n  line?: boolean;\n  area?: boolean;\n  text?: boolean;\n};\n\n/**\n * Return whether a channel supports a particular mark type.\n * @param channel  channel name\n * @param mark the mark type\n * @return whether the mark supports the channel\n */\nexport function supportMark(channel: Channel, mark: Mark) {\n  return !!getSupportedMark(channel)[mark];\n}\n\n/**\n * Return a dictionary showing whether a channel supports mark type.\n * @param channel\n * @return A dictionary mapping mark types to boolean values.\n */\nexport function getSupportedMark(channel: Channel): SupportedMark {\n  switch (channel) {\n    case X:\n    case Y:\n    case COLOR:\n    case DETAIL:\n    case ORDER:\n    case OPACITY:\n    case ROW:\n    case COLUMN:\n      return { // all marks\n        point: true, tick: true, rule: true, circle: true, square: true,\n        bar: true, line: true, area: true, text: true\n      };\n    case X2:\n    case Y2:\n      return {\n        rule: true, bar: true, area: true\n      };\n    case SIZE:\n      return {\n        point: true, tick: true, rule: true, circle: true, square: true,\n        bar: true, text: true\n      };\n    case SHAPE:\n      return {point: true};\n    case TEXT:\n      return {text: true};\n    case PATH:\n      return {line: true};\n  }\n  return {};\n}\n\nexport interface SupportedRole {\n  measure: boolean;\n  dimension: boolean;\n};\n\n/**\n * Return whether a channel supports dimension / measure role\n * @param  channel\n * @return A dictionary mapping role to boolean values.\n */\nexport function getSupportedRole(channel: Channel): SupportedRole {\n  switch (channel) {\n    case X:\n    case Y:\n    case COLOR:\n    case OPACITY:\n    case LABEL:\n    case DETAIL:\n      return {\n        measure: true,\n        dimension: true\n      };\n    case ROW:\n    case COLUMN:\n    case SHAPE:\n      return {\n        measure: false,\n        dimension: true\n      };\n    case X2:\n    case Y2:\n    case SIZE:\n    case TEXT:\n      return {\n        measure: true,\n        dimension: false\n      };\n    case PATH:\n      return {\n        measure: false,\n        dimension: true\n      };\n  }\n  throw new Error('Invalid encoding channel' + channel);\n}\n\nexport function hasScale(channel: Channel) {\n  return !contains([DETAIL, PATH, TEXT, LABEL, ORDER], channel);\n}\n",
    "import {AxisOrient} from '../axis';\nimport {COLUMN, ROW, X, Y, Channel} from '../channel';\nimport {title as fieldDefTitle} from '../fielddef';\nimport {NOMINAL, ORDINAL, TEMPORAL} from '../type';\nimport {contains, keys, extend, truncate, Dict} from '../util';\nimport {VgAxis} from '../vega.schema';\n\nimport {numberFormat, timeTemplate} from './common';\nimport {Model} from './model';\nimport {UnitModel} from './unit';\n\n// https://github.com/Microsoft/TypeScript/blob/master/doc/spec.md#11-ambient-declarations\ndeclare let exports;\n\nexport function parseAxisComponent(model: Model, axisChannels: Channel[]): Dict<VgAxis> {\n  return axisChannels.reduce(function(axis, channel) {\n    if (model.axis(channel)) {\n      axis[channel] = parseAxis(channel, model);\n    }\n    return axis;\n  }, {} as Dict<VgAxis>);\n}\n\n/**\n * Make an inner axis for showing grid for shared axis.\n */\nexport function parseInnerAxis(channel: Channel, model: Model): VgAxis {\n  const isCol = channel === COLUMN,\n    isRow = channel === ROW,\n    type = isCol ? 'x' : isRow ? 'y': channel;\n\n  // TODO: support adding ticks as well\n\n  // TODO: replace any with Vega Axis Interface\n  let def: any = {\n    type: type,\n    scale: model.scaleName(channel),\n    grid: true,\n    tickSize: 0,\n    properties: {\n      labels: {\n        text: {value: ''}\n      },\n      axis: {\n        stroke: {value: 'transparent'}\n      }\n    }\n  };\n\n  const axis = model.axis(channel);\n\n  ['layer', 'ticks', 'values', 'subdivide'].forEach(function(property) {\n    let method: (model: Model, channel: Channel, def:any)=>any;\n\n    const value = (method = exports[property]) ?\n                  // calling axis.format, axis.grid, ...\n                  method(model, channel, def) :\n                  axis[property];\n    if (value !== undefined) {\n      def[property] = value;\n    }\n  });\n\n  const props = model.axis(channel).properties || {};\n\n  // For now, only need to add grid properties here because innerAxis is only for rendering grid.\n  // TODO: support add other properties for innerAxis\n  ['grid'].forEach(function(group) {\n    const value = properties[group] ?\n      properties[group](model, channel, props[group] || {}, def) :\n      props[group];\n    if (value !== undefined && keys(value).length > 0) {\n      def.properties = def.properties || {};\n      def.properties[group] = value;\n    }\n  });\n\n  return def;\n}\n\nexport function parseAxis(channel: Channel, model: Model): VgAxis {\n  const isCol = channel === COLUMN,\n    isRow = channel === ROW,\n    type = isCol ? 'x' : isRow ? 'y': channel;\n\n  const axis = model.axis(channel);\n\n  // TODO: replace any with Vega Axis Interface\n  let def: any = {\n    type: type,\n    scale: model.scaleName(channel)\n  };\n\n  // 1.2. Add properties\n  [\n    // a) properties with special rules (so it has axis[property] methods) -- call rule functions\n    'format', 'grid', 'layer', 'offset', 'orient', 'tickSize', 'ticks', 'tickSizeEnd', 'title', 'titleOffset',\n    // b) properties without rules, only produce default values in the schema, or explicit value if specified\n    'tickPadding', 'tickSize', 'tickSizeMajor', 'tickSizeMinor', 'values', 'subdivide'\n  ].forEach(function(property) {\n    let method: (model: Model, channel: Channel, def:any)=>any;\n\n    const value = (method = exports[property]) ?\n                  // calling axis.format, axis.grid, ...\n                  method(model, channel, def) :\n                  axis[property];\n    if (value !== undefined) {\n      def[property] = value;\n    }\n  });\n\n  // 2) Add mark property definition groups\n  const props = model.axis(channel).properties || {};\n\n  [\n    'axis', 'labels', // have special rules\n    'grid', 'title', 'ticks', 'majorTicks', 'minorTicks' // only default values\n  ].forEach(function(group) {\n    const value = properties[group] ?\n      properties[group](model, channel, props[group] || {}, def) :\n      props[group];\n    if (value !== undefined && keys(value).length > 0) {\n      def.properties = def.properties || {};\n      def.properties[group] = value;\n    }\n  });\n\n  return def;\n}\n\nexport function format(model: Model, channel: Channel) {\n  return numberFormat(model.fieldDef(channel), model.axis(channel).format, model.config());\n}\n\nexport function offset(model: Model, channel: Channel) {\n  return model.axis(channel).offset;\n}\n\n// TODO: we need to refactor this method after we take care of config refactoring\n/**\n * Default rules for whether to show a grid should be shown for a channel.\n * If `grid` is unspecified, the default value is `true` for ordinal scales that are not binned\n */\nexport function gridShow(model: Model, channel: Channel) {\n  const grid = model.axis(channel).grid;\n  if (grid !== undefined) {\n    return grid;\n  }\n\n  return !model.isOrdinalScale(channel) && !model.fieldDef(channel).bin;\n}\n\nexport function grid(model: Model, channel: Channel) {\n  if (channel === ROW || channel === COLUMN) {\n    // never apply grid for ROW and COLUMN since we manually create rule-group for them\n    return undefined;\n  }\n\n  return gridShow(model, channel) && (\n    // TODO refactor this cleanly -- essentially the condition below is whether\n    // the axis is a shared / union axis.\n    (channel === Y || channel === X) && !(model.parent() && model.parent().isFacet())\n  );\n}\n\nexport function layer(model: Model, channel: Channel, def) {\n  const layer = model.axis(channel).layer;\n  if (layer !== undefined) {\n    return layer;\n  }\n  if (def.grid) {\n    // if grid is true, need to put layer on the back so that grid is behind marks\n    return 'back';\n  }\n  return undefined; // otherwise return undefined and use Vega's default.\n};\n\nexport function orient(model: Model, channel: Channel) {\n  const orient = model.axis(channel).orient;\n  if (orient) {\n    return orient;\n  } else if (channel === COLUMN) {\n    // FIXME test and decide\n    return AxisOrient.TOP;\n  }\n  return undefined;\n}\n\nexport function ticks(model: Model, channel: Channel) {\n  const ticks = model.axis(channel).ticks;\n  if (ticks !== undefined) {\n    return ticks;\n  }\n\n  // FIXME depends on scale type too\n  if (channel === X && !model.fieldDef(channel).bin) {\n    // Vega's default ticks often lead to a lot of label occlusion on X without 90 degree rotation\n    return 5;\n  }\n\n  return undefined;\n}\n\nexport function tickSize(model: Model, channel: Channel) {\n  const tickSize = model.axis(channel).tickSize;\n  if (tickSize !== undefined) {\n    return tickSize;\n  }\n  return undefined;\n}\n\nexport function tickSizeEnd(model: Model, channel: Channel) {\n  const tickSizeEnd = model.axis(channel).tickSizeEnd;\n  if (tickSizeEnd !== undefined) {\n      return tickSizeEnd;\n  }\n  return undefined;\n}\n\n\nexport function title(model: Model, channel: Channel) {\n  const axis = model.axis(channel);\n  if (axis.title !== undefined) {\n    return axis.title;\n  }\n\n  // if not defined, automatically determine axis title from field def\n  const fieldTitle = fieldDefTitle(model.fieldDef(channel), model.config());\n\n  let maxLength;\n  if (axis.titleMaxLength) {\n    maxLength = axis.titleMaxLength;\n  } else if (channel === X && !model.isOrdinalScale(X)) {\n    const unitModel: UnitModel = model as any; // only unit model has channel x\n    // For non-ordinal scale, we know cell size at compile time, we can guess max length\n    maxLength = unitModel.width / model.axis(X).characterWidth;\n  } else if (channel === Y && !model.isOrdinalScale(Y)) {\n    const unitModel: UnitModel = model as any; // only unit model has channel y\n    // For non-ordinal scale, we know cell size at compile time, we can guess max length\n    maxLength = unitModel.height / model.axis(Y).characterWidth;\n  }\n\n  // FIXME: we should use template to truncate instead\n  return maxLength ? truncate(fieldTitle, maxLength) : fieldTitle;\n}\n\nexport function titleOffset(model: Model, channel: Channel) {\n  const titleOffset = model.axis(channel).titleOffset;\n  if (titleOffset !== undefined) {\n      return titleOffset;\n  }\n  return undefined;\n}\n\nexport namespace properties {\n  export function axis(model: Model, channel: Channel, axisPropsSpec) {\n    const axis = model.axis(channel);\n\n    return extend(\n      axis.axisColor !== undefined ?\n        { stroke: {value: axis.axisColor} } :\n        {},\n      axis.axisWidth !== undefined ?\n        { strokeWidth: {value: axis.axisWidth} } :\n        {},\n      axisPropsSpec || {}\n    );\n  }\n\n  export function grid(model: Model, channel: Channel, gridPropsSpec) {\n    const axis = model.axis(channel);\n\n    return extend(\n      axis.gridColor !== undefined ? { stroke: {value: axis.gridColor}} : {},\n      axis.gridOpacity !== undefined ? {strokeOpacity: {value: axis.gridOpacity} } : {},\n      axis.gridWidth !== undefined ? {strokeWidth : {value: axis.gridWidth} } : {},\n      axis.gridDash !== undefined ? {strokeDashOffset : {value: axis.gridDash} } : {},\n      gridPropsSpec || {}\n    );\n  }\n\n  export function labels(model: Model, channel: Channel, labelsSpec, def) {\n    const fieldDef = model.fieldDef(channel);\n    const axis = model.axis(channel);\n    const config = model.config();\n\n    if (!axis.labels) {\n      return extend({\n        text: ''\n      }, labelsSpec);\n    }\n\n    // Text\n    if (contains([NOMINAL, ORDINAL], fieldDef.type) && axis.labelMaxLength) {\n      // TODO replace this with Vega's labelMaxLength once it is introduced\n      labelsSpec = extend({\n        text: {\n          template: '{{ datum[\"data\"] | truncate:' + axis.labelMaxLength + ' }}'\n        }\n      }, labelsSpec || {});\n    } else if (fieldDef.type === TEMPORAL) {\n      labelsSpec = extend({\n        text: {\n          template: timeTemplate('datum[\"data\"]', fieldDef.timeUnit, axis.format, axis.shortTimeLabels, config)\n        }\n      }, labelsSpec);\n    }\n\n    // Label Angle\n    if (axis.labelAngle !== undefined) {\n      labelsSpec.angle = {value: axis.labelAngle};\n    } else {\n      // auto rotate for X and Row\n      if (channel === X && (contains([NOMINAL, ORDINAL], fieldDef.type) || !!fieldDef.bin || fieldDef.type === TEMPORAL)) {\n        labelsSpec.angle = {value: 270};\n      }\n    }\n\n    if (axis.labelAlign !== undefined) {\n      labelsSpec.align = {value: axis.labelAlign};\n    } else {\n      // Auto set align if rotated\n      // TODO: consider other value besides 270, 90\n      if (labelsSpec.angle) {\n        if (labelsSpec.angle.value === 270) {\n          labelsSpec.align = {\n            value: def.orient === 'top' ? 'left':\n                   def.type === 'x' ? 'right' :\n                   'center'\n          };\n        } else if (labelsSpec.angle.value === 90) {\n          labelsSpec.align = {value: 'center'};\n        }\n      }\n    }\n\n    if (axis.labelBaseline !== undefined) {\n      labelsSpec.baseline = {value: axis.labelBaseline};\n    } else {\n      if (labelsSpec.angle) {\n        // Auto set baseline if rotated\n        // TODO: consider other value besides 270, 90\n        if (labelsSpec.angle.value === 270) {\n          labelsSpec.baseline = {value: def.type === 'x' ? 'middle' : 'bottom'};\n        } else if (labelsSpec.angle.value === 90) {\n          labelsSpec.baseline = {value: 'bottom'};\n        }\n      }\n    }\n\n    if (axis.tickLabelColor !== undefined) {\n        labelsSpec.stroke = {value: axis.tickLabelColor};\n    }\n\n    if (axis.tickLabelFont !== undefined) {\n        labelsSpec.font = {value: axis.tickLabelFont};\n    }\n\n    if (axis.tickLabelFontSize !== undefined) {\n        labelsSpec.fontSize = {value: axis.tickLabelFontSize};\n    }\n\n    return keys(labelsSpec).length === 0 ? undefined : labelsSpec;\n  }\n\n  export function ticks(model: Model, channel: Channel, ticksPropsSpec) {\n    const axis = model.axis(channel);\n\n    return extend(\n      axis.tickColor !== undefined ? {stroke : {value: axis.tickColor} } : {},\n      axis.tickWidth !== undefined ? {strokeWidth: {value: axis.tickWidth} } : {},\n      ticksPropsSpec || {}\n    );\n  }\n\n  export function title(model: Model, channel: Channel, titlePropsSpec) {\n    const axis = model.axis(channel);\n\n    return extend(\n      axis.titleColor !== undefined ? {stroke : {value: axis.titleColor} } : {},\n      axis.titleFont !== undefined ? {font: {value: axis.titleFont}} : {},\n      axis.titleFontSize !== undefined ? {fontSize: {value: axis.titleFontSize}} : {},\n      axis.titleFontWeight !== undefined ? {fontWeight: {value: axis.titleFontWeight}} : {},\n\n      titlePropsSpec || {}\n    );\n  }\n}\n",
    "import {BAR, POINT, CIRCLE, SQUARE} from '../mark';\nimport {AggregateOp} from '../aggregate';\nimport {COLOR, OPACITY} from '../channel';\nimport {Config} from '../config';\nimport {FieldDef, field, OrderChannelDef} from '../fielddef';\nimport {SortOrder} from '../sort';\nimport {TimeUnit} from '../timeunit';\nimport {QUANTITATIVE, ORDINAL} from '../type';\nimport {contains, union} from '../util';\n\nimport {FacetModel} from './facet';\nimport {LayerModel} from './layer';\nimport {Model} from './model';\nimport {template as timeUnitTemplate} from '../timeunit';\nimport {UnitModel} from './unit';\nimport {Spec, isUnitSpec, isFacetSpec, isLayerSpec} from '../spec';\n\n\nexport function buildModel(spec: Spec, parent: Model, parentGivenName: string): Model {\n  if (isFacetSpec(spec)) {\n    return new FacetModel(spec, parent, parentGivenName);\n  }\n\n  if (isLayerSpec(spec)) {\n    return new LayerModel(spec, parent, parentGivenName);\n  }\n\n  if (isUnitSpec(spec)) {\n    return new UnitModel(spec, parent, parentGivenName);\n  }\n\n  console.error('Invalid spec.');\n  return null;\n}\n\n// TODO: figure if we really need opacity in both\nexport const STROKE_CONFIG = ['stroke', 'strokeWidth',\n  'strokeDash', 'strokeDashOffset', 'strokeOpacity', 'opacity'];\n\nexport const FILL_CONFIG = ['fill', 'fillOpacity',\n  'opacity'];\n\nexport const FILL_STROKE_CONFIG = union(STROKE_CONFIG, FILL_CONFIG);\n\nexport function applyColorAndOpacity(p, model: UnitModel) {\n  const filled = model.config().mark.filled;\n  const colorFieldDef = model.encoding().color;\n  const opacityFieldDef = model.encoding().opacity;\n\n  // Apply fill stroke config first so that color field / value can override\n  // fill / stroke\n  if (filled) {\n    applyMarkConfig(p, model, FILL_CONFIG);\n  } else {\n    applyMarkConfig(p, model, STROKE_CONFIG);\n  }\n\n  let colorValue;\n  let opacityValue;\n  if (model.has(COLOR)) {\n    colorValue = {\n      scale: model.scaleName(COLOR),\n      field: model.field(COLOR, colorFieldDef.type === ORDINAL ? {prefix: 'rank'} : {})\n    };\n  } else if (colorFieldDef && colorFieldDef.value) {\n    colorValue = { value: colorFieldDef.value };\n  }\n\n  if (model.has(OPACITY)) {\n    opacityValue = {\n      scale: model.scaleName(OPACITY),\n      field: model.field(OPACITY, opacityFieldDef.type === ORDINAL ? {prefix: 'rank'} : {})\n    };\n  } else if (opacityFieldDef && opacityFieldDef.value) {\n    opacityValue = { value: opacityFieldDef.value };\n  }\n\n  if (colorValue !== undefined) {\n    if (filled) {\n      p.fill = colorValue;\n    } else {\n      p.stroke = colorValue;\n    }\n  } else {\n    // apply color config if there is no fill / stroke config\n    p[filled ? 'fill' : 'stroke'] = p[filled ? 'fill' : 'stroke'] ||\n      {value: model.config().mark.color};\n  }\n\n  // If there is no fill, always fill symbols\n  // with transparent fills https://github.com/vega/vega-lite/issues/1316\n  if (!p.fill && contains([BAR, POINT, CIRCLE, SQUARE], model.mark())) {\n    p.fill = {value: 'transparent'};\n  }\n\n  if (opacityValue !== undefined) {\n    p.opacity = opacityValue;\n  }\n}\n\nexport function applyConfig(properties, config, propsList: string[]) {\n  propsList.forEach(function(property) {\n    const value = config[property];\n    if (value !== undefined) {\n      properties[property] = { value: value };\n    }\n  });\n  return properties;\n}\n\nexport function applyMarkConfig(marksProperties, model: UnitModel, propsList: string[]) {\n  return applyConfig(marksProperties, model.config().mark, propsList);\n}\n\n/**\n * Returns number format for a fieldDef\n *\n * @param format explicitly specified format\n */\nexport function numberFormat(fieldDef: FieldDef, format: string, config: Config) {\n  if (fieldDef.type === QUANTITATIVE && !fieldDef.bin) {\n    // add number format for quantitative type only\n\n    if (format) {\n      return format;\n    } else if (fieldDef.aggregate === AggregateOp.COUNT) {\n      // FIXME: need a more holistic way to deal with this.\n      return 'd';\n    }\n    // TODO: need to make this work correctly for numeric ordinal / nominal type\n    return config.numberFormat;\n  }\n  return undefined;\n}\n\n/** Return field reference with potential \"-\" prefix for descending sort */\nexport function sortField(orderChannelDef: OrderChannelDef) {\n  return (orderChannelDef.sort === SortOrder.DESCENDING ? '-' : '') +\n    field(orderChannelDef, {binSuffix: 'mid'});\n}\n\n/**\n * Returns the time template used for axis/legend labels or text mark for a temporal field\n */\nexport function timeTemplate(templateField: string, timeUnit: TimeUnit, format: string, shortTimeLabels: boolean, config: Config): string {\n  if (!timeUnit || format) {\n    // If there is not time unit, or if user explicitly specify format for axis/legend/text.\n    const _format = format || config.timeFormat; // only use config.timeFormat if there is no timeUnit.\n    return '{{' + templateField + ' | time:\\'' + _format + '\\'}}';\n  } else {\n    return timeUnitTemplate(timeUnit, templateField, shortTimeLabels);\n  }\n}\n",
    "/**\n * Module for compiling Vega-lite spec into Vega spec.\n */\n\nimport {LAYOUT} from '../data';\nimport {Model} from './model';\nimport {normalize, ExtendedSpec} from '../spec';\nimport {extend} from '../util';\n\nimport {buildModel} from './common';\n\nexport function compile(inputSpec: ExtendedSpec) {\n  // 1. Convert input spec into a normal form\n  // (Decompose all extended unit specs into composition of unit spec.)\n  const spec = normalize(inputSpec);\n\n  // 2. Instantiate the model with default properties\n  const model = buildModel(spec, null, '');\n\n  // 3. Parse each part of the model to produce components that will be assembled later\n  // We traverse the whole tree to parse once for each type of components\n  // (e.g., data, layout, mark, scale).\n  // Please see inside model.parse() for order for compilation.\n  model.parse();\n\n  // 4. Assemble a Vega Spec from the parsed components in 3.\n  return assemble(model);\n}\n\nfunction assemble(model: Model) {\n  const config = model.config();\n\n  // TODO: change type to become VgSpec\n  const output = extend(\n    {\n      // Set size to 1 because we rely on padding anyway\n      width: 1,\n      height: 1,\n      padding: 'auto'\n    },\n    config.viewport ? { viewport: config.viewport } : {},\n    config.background ? { background: config.background } : {},\n    {\n      // TODO: signal: model.assembleSelectionSignal\n      data: [].concat(\n        model.assembleData([]),\n        model.assembleLayout([])\n        // TODO: model.assembleSelectionData\n      ),\n      marks: [assembleRootGroup(model)]\n    });\n\n  return {\n    spec: output\n    // TODO: add warning / errors here\n  };\n}\n\nexport function assembleRootGroup(model: Model) {\n  let rootGroup:any = extend({\n      name: model.name('root'),\n      type: 'group',\n    },\n    model.description() ? {description: model.description()} : {},\n    {\n      from: {data: LAYOUT},\n      properties: {\n        update: extend(\n          {\n            width: {field: 'width'},\n            height: {field: 'height'}\n          },\n          model.assembleParentGroupProperties(model.config().cell)\n        )\n      }\n    });\n\n  return extend(rootGroup, model.assembleGroup());\n}\n",
    "import {X, Y, DETAIL} from '../channel';\nimport {Config, Orient, MarkConfig} from '../config';\nimport {Encoding, isAggregate, has} from '../encoding';\nimport {isMeasure} from '../fielddef';\nimport {BAR, AREA, POINT, LINE, TICK, CIRCLE, SQUARE, RULE, TEXT, Mark} from '../mark';\nimport {ScaleType} from '../scale';\nimport {contains, extend} from '../util';\nimport {scaleType} from '../compile/scale';\n\n/**\n * Augment config.mark with rule-based default values.\n */\nexport function initMarkConfig(mark: Mark, encoding: Encoding, config: Config) {\n   return extend(\n     ['filled', 'opacity', 'orient', 'align'].reduce(function(cfg, property: string) {\n       const value = config.mark[property];\n       switch (property) {\n         case 'filled':\n           if (value === undefined) {\n             // Point, line, and rule are not filled by default\n             cfg[property] = mark !== POINT && mark !== LINE && mark !== RULE;\n           }\n           break;\n         case 'opacity':\n           if (value === undefined) {\n            if (contains([POINT, TICK, CIRCLE, SQUARE], mark)) {\n              // point-based marks and bar\n              if (!isAggregate(encoding) || has(encoding, DETAIL)) {\n                cfg[property] = 0.7;\n              }\n            }\n            if (mark === AREA) {\n              cfg[property] = 0.7; // inspired by Tableau\n            }\n           }\n           break;\n         case 'orient':\n           cfg[property] = orient(mark, encoding, config.mark);\n           break;\n         // text-only\n         case 'align':\n          if (value === undefined) {\n            cfg[property] = has(encoding, X) ? 'center' : 'right';\n          }\n       }\n       return cfg;\n     }, {}),\n     config.mark\n   );\n}\n\nexport function orient(mark: Mark, encoding: Encoding, markConfig: MarkConfig = {}): Orient {\n  switch (mark) {\n    case POINT:\n    case CIRCLE:\n    case SQUARE:\n    case TEXT:\n      // orient is meaningless for these marks.\n      return undefined;\n  }\n\n  const yIsRange = encoding.y && encoding.y2;\n  const xIsRange = encoding.x && encoding.x2;\n\n  switch (mark) {\n    case TICK:\n      const xScaleType = encoding.x ? scaleType(encoding.x.scale || {}, encoding.x, X, mark) : null;\n      const yScaleType = encoding.y ? scaleType(encoding.y.scale || {}, encoding.y, Y, mark) : null;\n\n      // Tick is opposite to bar, line, area and never have ranged mark.\n      if (xScaleType !== ScaleType.ORDINAL && (!encoding.y || yScaleType === ScaleType.ORDINAL)) {\n        return Orient.VERTICAL;\n      }\n      // y:Q or Ambiguous case, return horizontal\n      return Orient.HORIZONTAL;\n    case RULE:\n      if (xIsRange) {\n        return Orient.HORIZONTAL;\n      }\n      if (yIsRange) {\n        return Orient.VERTICAL;\n      }\n      if (encoding.y) {\n        return Orient.HORIZONTAL;\n      }\n      if (encoding.x) {\n        return Orient.VERTICAL;\n      }\n      // no x/y -- so it's undefined\n      return undefined;\n    case BAR:\n    case AREA:\n      // If there are range for both x and y, y (vertical) has higher precedence.\n\n      if (yIsRange) {\n        return Orient.VERTICAL;\n      }\n\n      if (xIsRange) {\n        return Orient.HORIZONTAL;\n      }\n      /* tslint:disable */\n    case LINE: // intentional fall through\n      /* tslint:enable */\n      const xIsMeasure = isMeasure(encoding.x) || isMeasure(encoding.x2);\n      const yIsMeasure = isMeasure(encoding.y) || isMeasure(encoding.y2);\n      if (xIsMeasure && !yIsMeasure) {\n        return Orient.HORIZONTAL;\n      }\n      // y:Q or Ambiguous case, return vertical\n      return Orient.VERTICAL;\n  }\n  /* istanbul ignore:next */\n  console.warn('orient unimplemented for mark', mark);\n  return Orient.VERTICAL;\n}\n",
    "import {autoMaxBins} from '../../bin';\nimport {Channel, COLOR} from '../../channel';\nimport {field, FieldDef} from '../../fielddef';\nimport {extend, vals, flatten, hash, Dict} from '../../util';\nimport {VgTransform} from '../../vega.schema';\n\nimport {FacetModel} from './../facet';\nimport {LayerModel} from './../layer';\nimport {Model} from './../model';\n\nimport {DataComponent} from './data';\n\nexport namespace bin {\n  function parse(model: Model): Dict<VgTransform[]> {\n    return model.reduce(function(binComponent, fieldDef: FieldDef, channel: Channel) {\n      const bin = model.fieldDef(channel).bin;\n      if (bin) {\n        let binTrans = extend({\n          type: 'bin',\n          field: fieldDef.field,\n          output: {\n            start: field(fieldDef, { binSuffix: 'start' }),\n            mid: field(fieldDef, { binSuffix: 'mid' }),\n            end: field(fieldDef, { binSuffix: 'end' })\n          }\n        },\n          // if bin is an object, load parameter here!\n          typeof bin === 'boolean' ? {} : bin\n        );\n\n        if (!binTrans.maxbins && !binTrans.step) {\n          // if both maxbins and step are not specified, need to automatically determine bin\n          binTrans.maxbins = autoMaxBins(channel);\n        }\n\n        const transform = [binTrans];\n        const isOrdinalColor = model.isOrdinalScale(channel) || channel === COLOR;\n        // color ramp has type linear or time\n        if (isOrdinalColor) {\n          transform.push({\n            type: 'formula',\n            field: field(fieldDef, { binSuffix: 'range' }),\n            expr: field(fieldDef, { datum: true, binSuffix: 'start' }) +\n            ' + \\'-\\' + ' +\n            field(fieldDef, { datum: true, binSuffix: 'end' })\n          });\n        }\n        // FIXME: current merging logic can produce redundant transforms when a field is binned for color and for non-color\n        const key = hash(bin) + '_' + fieldDef.field + 'oc:' + isOrdinalColor;\n        binComponent[key] = transform;\n      }\n      return binComponent;\n    }, {});\n  }\n\n  export const parseUnit = parse;\n\n  export function parseFacet(model: FacetModel) {\n    let binComponent = parse(model);\n\n    const childDataComponent = model.child().component.data;\n\n    // If child doesn't have its own data source, then merge\n    if (!childDataComponent.source) {\n      // FIXME: current merging logic can produce redundant transforms when a field is binned for color and for non-color\n      extend(binComponent, childDataComponent.bin);\n      delete childDataComponent.bin;\n    }\n    return binComponent;\n  }\n\n  export function parseLayer(model: LayerModel) {\n    let binComponent = parse(model);\n\n    model.children().forEach((child) => {\n      const childDataComponent = child.component.data;\n\n      // If child doesn't have its own data source, then merge\n      if (!childDataComponent.source) {\n        extend(binComponent, childDataComponent.bin);\n        delete childDataComponent.bin;\n      }\n    });\n\n    return binComponent;\n  }\n\n  export function assemble(component: DataComponent) {\n    return flatten(vals(component.bin));\n  }\n}\n",
    "import {COLOR} from '../../channel';\nimport {ORDINAL} from '../../type';\nimport {extend, vals, flatten, Dict} from '../../util';\nimport {VgTransform} from '../../vega.schema';\n\nimport {FacetModel} from '../facet';\nimport {LayerModel} from '../layer';\nimport {UnitModel} from '../unit';\n\nimport {DataComponent} from './data';\n\n\n/**\n * We need to add a rank transform so that we can use the rank value as\n * input for color ramp's linear scale.\n */\nexport namespace colorRank {\n  /**\n   * Return hash dict from a color field's name to the sort and rank transforms\n   */\n  export function parseUnit(model: UnitModel) {\n    let colorRankComponent: Dict<VgTransform[]> = {};\n    if (model.has(COLOR) && model.encoding().color.type === ORDINAL) {\n      colorRankComponent[model.field(COLOR)] = [{\n        type: 'sort',\n        by: model.field(COLOR)\n      }, {\n        type: 'rank',\n        field: model.field(COLOR),\n        output: {\n          rank: model.field(COLOR, { prefix: 'rank' })\n        }\n      }];\n    }\n    return colorRankComponent;\n  }\n\n  export function parseFacet(model: FacetModel) {\n    const childDataComponent = model.child().component.data;\n\n    // If child doesn't have its own data source, then consider merging\n    if (!childDataComponent.source) {\n      // TODO: we have to see if color has union scale here\n\n      // For now, let's assume it always has union scale\n      const colorRankComponent = childDataComponent.colorRank;\n      delete childDataComponent.colorRank;\n      return colorRankComponent;\n    }\n    return {} as Dict<VgTransform[]>;\n  }\n\n  export function parseLayer(model: LayerModel) {\n    let colorRankComponent = {} as Dict<VgTransform[]>;\n\n    model.children().forEach((child) => {\n      const childDataComponent = child.component.data;\n\n      // If child doesn't have its own data source, then merge\n      if (!childDataComponent.source) {\n        extend(colorRankComponent, childDataComponent.colorRank);\n        delete childDataComponent.colorRank;\n      }\n    });\n\n    return colorRankComponent;\n  }\n\n  export function assemble(component: DataComponent) {\n    return flatten(vals(component.colorRank));\n  }\n}\n",
    "import {FieldDef} from '../../fielddef';\nimport {Formula} from '../../transform';\nimport {keys, Dict, StringSet} from '../../util';\nimport {VgData, VgTransform} from '../../vega.schema';\n\nimport {FacetModel} from './../facet';\nimport {LayerModel} from './../layer';\nimport {Model} from './../model';\nimport {UnitModel} from './../unit';\n\nimport {source} from './source';\nimport {formatParse} from './formatparse';\nimport {nullFilter} from './nullfilter';\nimport {filter} from './filter';\nimport {bin} from './bin';\nimport {formula} from './formula';\nimport {nonPositiveFilter} from './nonpositivenullfilter';\nimport {summary} from './summary';\nimport {stackScale} from './stackscale';\nimport {timeUnit} from './timeunit';\nimport {timeUnitDomain} from './timeunitdomain';\nimport {colorRank} from './colorrank';\n\n\n/**\n * Composable component instance of a model's data.\n */\nexport interface DataComponent {\n  source: VgData;\n\n  /** Mapping from field name to primitive data type.  */\n  formatParse: Dict<string>;\n\n  /** String set of fields for null filtering */\n  nullFilter: Dict<FieldDef>;\n\n  /** Hashset of a formula object */\n  calculate: Dict<Formula>;\n\n  /** Filter test expression */\n  filter: string;\n\n  /** Dictionary mapping a bin parameter hash to transforms of the binned field */\n  bin: Dict<VgTransform[]>;\n\n  /** Dictionary mapping an output field name (hash) to the time unit transform  */\n  timeUnit: Dict<VgTransform>;\n\n  /** String set of fields to be filtered */\n  nonPositiveFilter: Dict<boolean>;\n\n  /** Data source for feeding stacked scale. */\n  // TODO: need to revise if single VgData is sufficient with layer / concat\n  stackScale: VgData;\n\n  /** Dictionary mapping an output field name (hash) to the sort and rank transforms  */\n  colorRank: Dict<VgTransform[]>;\n\n  /** String set of time units that need their own data sources for scale domain */\n  timeUnitDomain: StringSet;\n\n  /** Array of summary component object for producing summary (aggregate) data source */\n  summary: SummaryComponent[];\n}\n\n/**\n * Composable component for a model's summary data\n */\nexport interface SummaryComponent {\n  /** Name of the summary data source */\n  name: string;\n\n  /** String set for all dimension fields  */\n  dimensions: StringSet;\n\n  /** dictionary mapping field name to string set of aggregate ops */\n  measures: Dict<StringSet>;\n}\n\n// TODO: split this file into multiple files and remove this linter flag\n/* tslint:disable:no-use-before-declare */\n\nexport function parseUnitData(model: UnitModel): DataComponent {\n  return {\n    formatParse: formatParse.parseUnit(model),\n    nullFilter: nullFilter.parseUnit(model),\n    filter: filter.parseUnit(model),\n    nonPositiveFilter: nonPositiveFilter.parseUnit(model),\n\n    source: source.parseUnit(model),\n    bin: bin.parseUnit(model),\n    calculate: formula.parseUnit(model),\n    timeUnit: timeUnit.parseUnit(model),\n    timeUnitDomain: timeUnitDomain.parseUnit(model),\n    summary: summary.parseUnit(model),\n    stackScale: stackScale.parseUnit(model),\n    colorRank: colorRank.parseUnit(model)\n  };\n}\n\nexport function parseFacetData(model: FacetModel): DataComponent {\n  return {\n    formatParse: formatParse.parseFacet(model),\n    nullFilter: nullFilter.parseFacet(model),\n    filter: filter.parseFacet(model),\n    nonPositiveFilter: nonPositiveFilter.parseFacet(model),\n\n    source: source.parseFacet(model),\n    bin: bin.parseFacet(model),\n    calculate: formula.parseFacet(model),\n    timeUnit: timeUnit.parseFacet(model),\n    timeUnitDomain: timeUnitDomain.parseFacet(model),\n    summary: summary.parseFacet(model),\n    stackScale: stackScale.parseFacet(model),\n    colorRank: colorRank.parseFacet(model)\n  };\n}\n\nexport function parseLayerData(model: LayerModel): DataComponent {\n  return {\n    // filter and formatParse could cause us to not be able to merge into parent\n    // so let's parse them first\n    filter: filter.parseLayer(model),\n    formatParse: formatParse.parseLayer(model),\n    nullFilter: nullFilter.parseLayer(model),\n    nonPositiveFilter: nonPositiveFilter.parseLayer(model),\n\n    // everything after here does not affect whether we can merge child data into parent or not\n    source: source.parseLayer(model),\n    bin: bin.parseLayer(model),\n    calculate: formula.parseLayer(model),\n    timeUnit: timeUnit.parseLayer(model),\n    timeUnitDomain: timeUnitDomain.parseLayer(model),\n    summary: summary.parseLayer(model),\n    stackScale: stackScale.parseLayer(model),\n    colorRank: colorRank.parseLayer(model)\n  };\n}\n\n\n/* tslint:enable:no-use-before-declare */\n\n/**\n * Creates Vega Data array from a given compiled model and append all of them to the given array\n *\n * @param  model\n * @param  data array\n * @return modified data array\n */\nexport function assembleData(model: Model, data: VgData[]) {\n  const component = model.component.data;\n\n  const sourceData = source.assemble(model, component);\n  if (sourceData) {\n    data.push(sourceData);\n  }\n\n  summary.assemble(component, model).forEach(function(summaryData) {\n    data.push(summaryData);\n  });\n\n  if (data.length > 0) {\n    const dataTable = data[data.length - 1];\n\n    // color rank\n    const colorRankTransform = colorRank.assemble(component);\n    if (colorRankTransform.length > 0) {\n      dataTable.transform = (dataTable.transform || []).concat(colorRankTransform);\n    }\n\n    // nonPositiveFilter\n    const nonPositiveFilterTransform = nonPositiveFilter.assemble(component);\n    if (nonPositiveFilterTransform.length > 0) {\n      dataTable.transform = (dataTable.transform || []).concat(nonPositiveFilterTransform);\n    }\n  } else {\n    if (keys(component.colorRank).length > 0) {\n      throw new Error('Invalid colorRank not merged');\n    } else if (keys(component.nonPositiveFilter).length > 0) {\n      throw new Error('Invalid nonPositiveFilter not merged');\n    }\n  }\n\n  // stack\n  // TODO: revise if this actually should be an array\n  const stackData = stackScale.assemble(component);\n  if (stackData) {\n    data.push(stackData);\n  }\n\n  timeUnitDomain.assemble(component).forEach(function(timeUnitDomainData) {\n    data.push(timeUnitDomainData);\n  });\n  return data;\n}\n",
    "import {expression} from '../../filter';\nimport {isArray} from '../../util';\n\nimport {FacetModel} from '../facet';\nimport {LayerModel} from '../layer';\nimport {Model} from '../model';\n\nimport {DataComponent} from './data';\n\nexport namespace filter {\n  /**\n   * @param v value to be converted into Vega Expression\n   * @param timeUnit\n   * @return Vega Expression of the value v. This could be one of:\n   * - a timestamp value of datetime object\n   * - a timestamp value of casted single time unit value\n   * - stringified value\n   */\n\n  export function parse(model: Model): string {\n    const filter = model.transform().filter;\n    if (isArray(filter)) {\n      return '(' +\n        filter.map((f) => expression(f))\n          .filter((f) => f !==undefined)\n          .join(') && (') +\n        ')';\n    } else if (filter) {\n      return expression(filter);\n    }\n    return undefined;\n  }\n\n  export const parseUnit = parse;\n\n  export function parseFacet(model: FacetModel) {\n    let filterComponent = parse(model);\n\n    const childDataComponent = model.child().component.data;\n\n    // If child doesn't have its own data source but has filter, then merge\n    if (!childDataComponent.source && childDataComponent.filter) {\n      // merge by adding &&\n      filterComponent =\n        (filterComponent ? filterComponent + ' && ' : '') +\n        childDataComponent.filter;\n      delete childDataComponent.filter;\n    }\n    return filterComponent;\n  }\n\n  export function parseLayer(model: LayerModel) {\n    // Note that this `filter.parseLayer` method is called before `source.parseLayer`\n    let filterComponent = parse(model);\n    model.children().forEach((child) => {\n      const childDataComponent = child.component.data;\n      if (model.compatibleSource(child) && childDataComponent.filter && childDataComponent.filter === filterComponent) {\n        // same filter in child so we can just delete it\n        delete childDataComponent.filter;\n      }\n    });\n    return filterComponent;\n  }\n\n  export function assemble(component: DataComponent) {\n    const filter = component.filter;\n    return filter ? [{\n      type: 'filter',\n      test: filter\n    }] : [];\n  }\n}\n",
    "import {FieldDef, isCount} from '../../fielddef';\nimport {QUANTITATIVE, TEMPORAL} from '../../type';\nimport {extend, differ, Dict} from '../../util';\n\nimport {FacetModel} from './../facet';\nimport {LayerModel} from './../layer';\nimport {Model} from './../model';\n\nexport namespace formatParse {\n  // TODO: need to take calculate into account across levels when merging\n  function parse(model: Model): Dict<string> {\n    const calcFieldMap = (model.transform().calculate || []).reduce(function(fieldMap, formula) {\n      fieldMap[formula.field] = true;\n      return fieldMap;\n    }, {});\n\n    let parseComponent: Dict<string> = {};\n    // use forEach rather than reduce so that it can return undefined\n    // if there is no parse needed\n    model.forEach(function(fieldDef: FieldDef) {\n      if (fieldDef.type === TEMPORAL) {\n        parseComponent[fieldDef.field] = 'date';\n      } else if (fieldDef.type === QUANTITATIVE) {\n        if (isCount(fieldDef) || calcFieldMap[fieldDef.field]) {\n          return;\n        }\n        parseComponent[fieldDef.field] = 'number';\n      }\n    });\n    return parseComponent;\n  }\n\n  export const parseUnit = parse;\n\n  export function parseFacet(model: FacetModel) {\n    let parseComponent = parse(model);\n\n    // If child doesn't have its own data source, but has its own parse, then merge\n    const childDataComponent = model.child().component.data;\n    if (!childDataComponent.source && childDataComponent.formatParse) {\n      extend(parseComponent, childDataComponent.formatParse);\n      delete childDataComponent.formatParse;\n    }\n    return parseComponent;\n  }\n\n  export function parseLayer(model: LayerModel) {\n    // note that we run this before source.parseLayer\n    let parseComponent = parse(model);\n    model.children().forEach((child) => {\n      const childDataComponent = child.component.data;\n      if (model.compatibleSource(child) && !differ(childDataComponent.formatParse, parseComponent)) {\n        // merge parse up if the child does not have an incompatible parse\n        extend(parseComponent, childDataComponent.formatParse);\n        delete childDataComponent.formatParse;\n      }\n    });\n    return parseComponent;\n  }\n\n  // Assemble for formatParse is an identity function, no need to declare\n}\n",
    "import {Formula} from '../../transform';\nimport {extend, vals, hash, Dict} from '../../util';\n\nimport {FacetModel} from './../facet';\nimport {LayerModel} from './../layer';\nimport {Model} from './../model';\n\nimport {DataComponent} from './data';\n\n\nexport namespace formula {\n  function parse(model: Model): Dict<Formula> {\n    return (model.transform().calculate || []).reduce(function(formulaComponent, formula) {\n      formulaComponent[hash(formula)] = formula;\n      return formulaComponent;\n    }, {} as Dict<Formula>);\n  }\n\n  export const parseUnit = parse;\n\n  export function parseFacet(model: FacetModel) {\n    let formulaComponent = parse(model);\n\n    const childDataComponent = model.child().component.data;\n\n    // If child doesn't have its own data source, then merge\n    if (!childDataComponent.source) {\n      extend(formulaComponent, childDataComponent.calculate);\n      delete childDataComponent.calculate;\n    }\n    return formulaComponent;\n  }\n\n  export function parseLayer(model: LayerModel) {\n    let formulaComponent = parse(model);\n    model.children().forEach((child) => {\n      const childDataComponent = child.component.data;\n      if (!childDataComponent.source && childDataComponent.calculate) {\n        extend(formulaComponent || {}, childDataComponent.calculate);\n        delete childDataComponent.calculate;\n      }\n    });\n    return formulaComponent;\n  }\n\n  export function assemble(component: DataComponent) {\n    return vals(component.calculate).reduce(function(transform, formula) {\n      transform.push(extend({ type: 'formula' }, formula));\n      return transform;\n    }, []);\n  }\n}\n",
    "import {ScaleType} from '../../scale';\nimport {extend, keys, differ, Dict} from '../../util';\n\nimport {FacetModel} from './../facet';\nimport {LayerModel} from './../layer';\nimport {Model} from './../model';\n\nimport {DataComponent} from './data';\n\n/**\n * Filter non-positive value for log scale\n */\nexport namespace nonPositiveFilter {\n  export function parseUnit(model: Model): Dict<boolean> {\n    return model.channels().reduce(function(nonPositiveComponent, channel) {\n      const scale = model.scale(channel);\n      if (!model.field(channel) || !scale) {\n        // don't set anything\n        return nonPositiveComponent;\n      }\n      nonPositiveComponent[model.field(channel)] = scale.type === ScaleType.LOG;\n      return nonPositiveComponent;\n    }, {} as Dict<boolean>);\n  }\n\n  export function parseFacet(model: FacetModel) {\n    const childDataComponent = model.child().component.data;\n\n    // If child doesn't have its own data source, then consider merging\n    if (!childDataComponent.source) {\n      // For now, let's assume it always has union scale\n      const nonPositiveFilterComponent = childDataComponent.nonPositiveFilter;\n      delete childDataComponent.nonPositiveFilter;\n      return nonPositiveFilterComponent;\n    }\n    return {} as Dict<boolean>;\n  }\n\n  export function parseLayer(model: LayerModel) {\n    // note that we run this before source.parseLayer\n    let nonPositiveFilter = {} as Dict<boolean>;\n\n    model.children().forEach((child) => {\n      const childDataComponent = child.component.data;\n      if (model.compatibleSource(child) && !differ(childDataComponent.nonPositiveFilter, nonPositiveFilter)) {\n        extend(nonPositiveFilter, childDataComponent.nonPositiveFilter);\n        delete childDataComponent.nonPositiveFilter;\n      }\n    });\n\n    return nonPositiveFilter;\n  }\n\n  export function assemble(component: DataComponent) {\n    return keys(component.nonPositiveFilter).filter((field) => {\n      // Only filter fields (keys) with value = true\n      return component.nonPositiveFilter[field];\n    }).map(function(field) {\n      return {\n        type: 'filter',\n        test: 'datum[\"' + field + '\"] > 0'\n      };\n    });\n  }\n}\n",
    "import {FieldDef} from '../../fielddef';\nimport {QUANTITATIVE, TEMPORAL} from '../../type';\nimport {contains, extend, keys, differ, Dict} from '../../util';\n\nimport {FacetModel} from './../facet';\nimport {LayerModel} from './../layer';\nimport {Model} from './../model';\n\nimport {DataComponent} from './data';\n\nconst DEFAULT_NULL_FILTERS = {\n  nominal: false,\n  ordinal: false,\n  quantitative: true,\n  temporal: true\n};\n\n// TODO: rename to invalidFilter\nexport namespace nullFilter {\n  /** Return Hashset of fields for null filtering (key=field, value = true). */\n  function parse(model: Model): Dict<boolean> {\n    const transform = model.transform();\n    let filterInvalid = transform.filterInvalid;\n\n    if (filterInvalid === undefined && transform['filterNull'] !== undefined) {\n      filterInvalid = transform['filterNull'];\n      console.warn('filterNull is deprecated. Please use filterInvalid instead.');\n    }\n\n    return model.reduce(function(aggregator, fieldDef: FieldDef) {\n      if (fieldDef.field !== '*') { // Ignore * for count(*) fields.\n        if (filterInvalid ||\n          (filterInvalid === undefined && fieldDef.field && DEFAULT_NULL_FILTERS[fieldDef.type])) {\n          aggregator[fieldDef.field] = fieldDef;\n        } else {\n          // define this so we know that we don't filter nulls for this field\n          // this makes it easier to merge into parents\n          aggregator[fieldDef.field] = null;\n        }\n      }\n      return aggregator;\n    }, {});\n  }\n\n  export const parseUnit = parse;\n\n  export function parseFacet(model: FacetModel) {\n    let nullFilterComponent = parse(model);\n\n    const childDataComponent = model.child().component.data;\n\n    // If child doesn't have its own data source, then merge\n    if (!childDataComponent.source) {\n      extend(nullFilterComponent, childDataComponent.nullFilter);\n      delete childDataComponent.nullFilter;\n    }\n    return nullFilterComponent;\n  }\n\n  export function parseLayer(model: LayerModel) {\n    // note that we run this before source.parseLayer\n\n    // FIXME: null filters are not properly propagated right now\n    let nullFilterComponent = parse(model);\n\n    model.children().forEach((child) => {\n      const childDataComponent = child.component.data;\n      if (model.compatibleSource(child) && !differ<FieldDef>(childDataComponent.nullFilter, nullFilterComponent)) {\n        extend(nullFilterComponent, childDataComponent.nullFilter);\n        delete childDataComponent.nullFilter;\n      }\n    });\n\n    return nullFilterComponent;\n  }\n\n  /** Convert the hashset of fields to a filter transform.  */\n  export function assemble(component: DataComponent) {\n    const filters = keys(component.nullFilter).reduce((_filters, field) => {\n      const fieldDef = component.nullFilter[field];\n      if (fieldDef !== null) {\n        _filters.push('datum[\"' + fieldDef.field + '\"] !== null');\n        if (contains([QUANTITATIVE, TEMPORAL], fieldDef.type)) {\n          // TODO(https://github.com/vega/vega-lite/issues/1436):\n          // We can be even smarter and add NaN filter for N,O that are numbers\n          // based on the `parse` property once we have it.\n          _filters.push('!isNaN(datum[\"'+ fieldDef.field + '\"])');\n        }\n      }\n      return _filters;\n    }, []);\n\n    return filters.length > 0 ?\n      [{\n        type: 'filter',\n        test: filters.join(' && ')\n      }] : [];\n  }\n}\n",
    "import {DataFormat, SOURCE} from '../../data';\nimport {contains, extend} from '../../util';\nimport {VgData} from '../../vega.schema';\n\nimport {FacetModel} from '../facet';\nimport {LayerModel} from '../layer';\nimport {Model} from './../model';\n\nimport {DataComponent} from './data';\nimport {nullFilter} from './nullfilter';\nimport {filter} from './filter';\nimport {bin} from './bin';\nimport {formula} from './formula';\nimport {timeUnit} from './timeunit';\n\nexport namespace source {\n  function parse(model: Model): VgData {\n    let data = model.data();\n\n    if (data) {\n      // If data is explicitly provided\n\n      let sourceData: VgData = { name: model.dataName(SOURCE) };\n      if (data.values && data.values.length > 0) {\n        sourceData.values = data.values;\n        sourceData.format = { type: 'json' };\n      } else if (data.url) {\n        sourceData.url = data.url;\n\n        // Extract extension from URL using snippet from\n        // http://stackoverflow.com/questions/680929/how-to-extract-extension-from-filename-string-in-javascript\n        let defaultExtension = /(?:\\.([^.]+))?$/.exec(sourceData.url)[1];\n        if (!contains(['json', 'csv', 'tsv', 'topojson'], defaultExtension)) {\n          defaultExtension = 'json';\n        }\n        const dataFormat: DataFormat = data.format || {};\n\n        // For backward compatability for former `data.formatType` property\n        const formatType: DataFormat = dataFormat.type || data['formatType'];\n        sourceData.format =\n          extend(\n            { type: formatType ? formatType : defaultExtension },\n            dataFormat.property ? { property: dataFormat.property } : {},\n            // Feature and mesh are two mutually exclusive properties\n            dataFormat.feature ?\n              { feature : dataFormat.feature } :\n            dataFormat.mesh ?\n              { mesh : dataFormat.mesh } :\n              {}\n          );\n      }\n      return sourceData;\n    } else if (!model.parent()) {\n      // If data is not explicitly provided but the model is a root,\n      // need to produce a source as well\n      return { name: model.dataName(SOURCE) };\n    }\n    return undefined;\n  }\n\n  export const parseUnit = parse;\n\n  export function parseFacet(model: FacetModel) {\n    let sourceData = parse(model);\n    if (!model.child().component.data.source) {\n      // If the child does not have its own source, have to rename its source.\n      model.child().renameData(model.child().dataName(SOURCE), model.dataName(SOURCE));\n    }\n\n    return sourceData;\n  }\n\n  export function parseLayer(model: LayerModel) {\n    let sourceData = parse(model);\n    model.children().forEach((child) => {\n      const childData = child.component.data;\n\n      if (model.compatibleSource(child)) {\n        // we cannot merge if the child has filters defined even after we tried to move them up\n        const canMerge = !childData.filter && !childData.formatParse && !childData.nullFilter;\n        if (canMerge) {\n          // rename source because we can just remove it\n          child.renameData(child.dataName(SOURCE), model.dataName(SOURCE));\n          delete childData.source;\n        } else {\n          // child does not have data defined or the same source so just use the parents source\n          childData.source = {\n            name: child.dataName(SOURCE),\n            source: model.dataName(SOURCE)\n          };\n        }\n      }\n    });\n    return sourceData;\n  }\n\n  export function assemble(model: Model, component: DataComponent) {\n    if (component.source) {\n      let sourceData: VgData = component.source;\n\n      if (component.formatParse) {\n        component.source.format = component.source.format || {};\n        component.source.format.parse = component.formatParse;\n      }\n\n      // null filter comes first so transforms are not performed on null values\n      // time and bin should come before filter so we can filter by time and bin\n      sourceData.transform = [].concat(\n        formula.assemble(component),\n        nullFilter.assemble(component),\n        filter.assemble(component),\n        bin.assemble(component),\n        timeUnit.assemble(component)\n      );\n\n      return sourceData;\n    }\n    return null;\n  }\n}\n",
    "import {STACKED_SCALE, SUMMARY} from '../../data';\nimport {field} from '../../fielddef';\nimport {VgData} from '../../vega.schema';\nimport {extend} from '../../util';\n\nimport {FacetModel} from './../facet';\nimport {LayerModel} from './../layer';\nimport {UnitModel} from './../unit';\n\nimport {DataComponent} from './data';\n\n\n/**\n * Stacked scale data source, for feeding the shared scale.\n */\nexport namespace stackScale {\n  export function parseUnit(model: UnitModel): VgData {\n    const stackProps = model.stack();\n\n    if (stackProps) {\n      // produce stacked scale\n      const groupbyChannel = stackProps.groupbyChannel;\n      const fieldChannel = stackProps.fieldChannel;\n\n      let fields = [];\n      const field = model.field(groupbyChannel);\n      if (field) {\n        fields.push(field);\n      }\n\n      return {\n        name: model.dataName(STACKED_SCALE),\n        source: model.dataName(SUMMARY), // always summary because stacked only works with aggregation\n        transform: [extend({\n          type: 'aggregate',\n          // produce sum of the field's value e.g., sum of sum, sum of distinct\n          summarize: [{ ops: ['sum'], field: model.field(fieldChannel) }]\n        }, fields.length > 0 ? {\n          // group by channel and other facets\n          groupby: fields\n        } : {})]\n      };\n    }\n    return null;\n  };\n\n  export function parseFacet(model: FacetModel) {\n    const child = model.child();\n    const childDataComponent = child.component.data;\n\n    // If child doesn't have its own data source, but has stack scale source, then merge\n    if (!childDataComponent.source && childDataComponent.stackScale) {\n      let stackComponent = childDataComponent.stackScale;\n\n      const newName = model.dataName(STACKED_SCALE);\n      child.renameData(stackComponent.name, newName);\n      stackComponent.name = newName;\n\n      // Refer to facet's summary instead (always summary because stacked only works with aggregation)\n      stackComponent.source = model.dataName(SUMMARY);\n\n      // Add more dimensions for row/column\n      stackComponent.transform[0].groupby = model.reduce(function(groupby, fieldDef) {\n        groupby.push(field(fieldDef));\n        return groupby;\n      }, stackComponent.transform[0].groupby);\n\n      delete childDataComponent.stackScale;\n      return stackComponent;\n    }\n    return null;\n  }\n\n  export function parseLayer(model: LayerModel) {\n    // TODO\n    return null;\n  }\n\n  export function assemble(component: DataComponent) {\n    return component.stackScale;\n  }\n}\n",
    "import {AggregateOp} from '../../aggregate';\nimport {Channel} from '../../channel';\nimport {SOURCE, SUMMARY} from '../../data';\nimport {field, FieldDef} from '../../fielddef';\nimport {keys, vals, reduce, hash, Dict, StringSet} from '../../util';\nimport {VgData} from '../../vega.schema';\n\nimport {FacetModel} from './../facet';\nimport {LayerModel} from './../layer';\nimport {Model} from './../model';\n\nimport {DataComponent, SummaryComponent} from './data';\n\n\nexport namespace summary {\n  function addDimension(dims: { [field: string]: boolean }, fieldDef: FieldDef) {\n    if (fieldDef.bin) {\n      dims[field(fieldDef, { binSuffix: 'start' })] = true;\n      dims[field(fieldDef, { binSuffix: 'mid' })] = true;\n      dims[field(fieldDef, { binSuffix: 'end' })] = true;\n\n      // const scale = model.scale(channel);\n      // if (scaleType(scale, fieldDef, channel, model.mark()) === ScaleType.ORDINAL) {\n      // also produce bin_range if the binned field use ordinal scale\n      dims[field(fieldDef, { binSuffix: 'range' })] = true;\n      // }\n    } else {\n      dims[field(fieldDef)] = true;\n    }\n    return dims;\n  }\n\n  export function parseUnit(model: Model): SummaryComponent[] {\n    /* string set for dimensions */\n    let dims: StringSet = {};\n\n    /* dictionary mapping field name => dict set of aggregation functions */\n    let meas: Dict<StringSet> = {};\n\n    model.forEach(function(fieldDef: FieldDef, channel: Channel) {\n      if (fieldDef.aggregate) {\n        if (fieldDef.aggregate === AggregateOp.COUNT) {\n          meas['*'] = meas['*'] || {};\n          /* tslint:disable:no-string-literal */\n          meas['*']['count'] = true;\n          /* tslint:enable:no-string-literal */\n        } else {\n          meas[fieldDef.field] = meas[fieldDef.field] || {};\n          meas[fieldDef.field][fieldDef.aggregate] = true;\n        }\n      } else {\n        addDimension(dims, fieldDef);\n      }\n    });\n\n    return [{\n      name: model.dataName(SUMMARY),\n      dimensions: dims,\n      measures: meas\n    }];\n  }\n\n  export function parseFacet(model: FacetModel): SummaryComponent[] {\n    const childDataComponent = model.child().component.data;\n\n    // If child doesn't have its own data source but has a summary data source, merge\n    if (!childDataComponent.source && childDataComponent.summary) {\n      let summaryComponents = childDataComponent.summary.map(function(summaryComponent) {\n        // add facet fields as dimensions\n        summaryComponent.dimensions = model.reduce(addDimension, summaryComponent.dimensions);\n\n        const summaryNameWithoutPrefix = summaryComponent.name.substr(model.child().name('').length);\n        model.child().renameData(summaryComponent.name, summaryNameWithoutPrefix);\n        summaryComponent.name = summaryNameWithoutPrefix;\n        return summaryComponent;\n      });\n\n      delete childDataComponent.summary;\n      return summaryComponents;\n    }\n    return [];\n  }\n\n  function mergeMeasures(parentMeasures: Dict<Dict<boolean>>, childMeasures: Dict<Dict<boolean>>) {\n    for (const field in childMeasures) {\n      if (childMeasures.hasOwnProperty(field)) {\n        // when we merge a measure, we either have to add an aggregation operator or even a new field\n        const ops = childMeasures[field];\n        for (const op in ops) {\n          if (ops.hasOwnProperty(op)) {\n            if (field in parentMeasures) {\n              // add operator to existing measure field\n              parentMeasures[field][op] = true;\n            } else {\n              parentMeasures[field] = { op: true };\n            }\n          }\n        }\n      }\n    }\n  }\n\n  export function parseLayer(model: LayerModel): SummaryComponent[] {\n    // Index by the fields we are grouping by\n    let summaries = {} as Dict<SummaryComponent>;\n\n    // Combine summaries for children that don't have a distinct source\n    // (either having its own data source, or its own tranformation of the same data source).\n    model.children().forEach((child) => {\n      const childDataComponent = child.component.data;\n      if (!childDataComponent.source && childDataComponent.summary) {\n        // Merge the summaries if we can\n        childDataComponent.summary.forEach((childSummary) => {\n          // The key is a hash based on the dimensions;\n          // we use it to find out whether we have a summary that uses the same group by fields.\n          const key = hash(childSummary.dimensions);\n          if (key in summaries) {\n            // yes, there is a summary hat we need to merge into\n            // we know that the dimensions are the same so we only need to merge the measures\n            mergeMeasures(summaries[key].measures, childSummary.measures);\n          } else {\n            // give the summary a new name\n            childSummary.name = model.dataName(SUMMARY) + '_' + keys(summaries).length;\n            summaries[key] = childSummary;\n          }\n\n          // remove summary from child\n          child.renameData(child.dataName(SUMMARY), summaries[key].name);\n          delete childDataComponent.summary;\n        });\n      }\n    });\n\n    return vals(summaries);\n  }\n\n  /**\n   * Assemble the summary. Needs a rename function because we cannot guarantee that the\n   * parent data before the children data.\n   */\n  export function assemble(component: DataComponent, model: Model): VgData[] {\n    if (!component.summary) {\n      return [];\n    }\n    return component.summary.reduce(function(summaryData, summaryComponent) {\n      const dims = summaryComponent.dimensions;\n      const meas = summaryComponent.measures;\n\n      const groupby = keys(dims);\n\n      // short-format summarize object for Vega's aggregate transform\n      // https://github.com/vega/vega/wiki/Data-Transforms#-aggregate\n      const summarize = reduce(meas, function(aggregator, fnDictSet, field) {\n        aggregator[field] = keys(fnDictSet);\n        return aggregator;\n      }, {});\n\n      if (keys(meas).length > 0) { // has aggregate\n        summaryData.push({\n          name: summaryComponent.name,\n          source: model.dataName(SOURCE),\n          transform: [{\n            type: 'aggregate',\n            groupby: groupby,\n            summarize: summarize\n          }]\n        });\n      }\n      return summaryData;\n    }, []);\n  }\n}\n",
    "import {Channel} from '../../channel';\nimport {field, FieldDef} from '../../fielddef';\nimport {fieldExpr} from '../../timeunit';\nimport {TEMPORAL} from '../../type';\nimport {extend, vals, Dict} from '../../util';\nimport {VgTransform} from '../../vega.schema';\n\nimport {FacetModel} from '../facet';\nimport {LayerModel} from '../layer';\nimport {Model} from '../model';\n\nimport {DataComponent} from './data';\n\nexport namespace timeUnit {\n  function parse(model: Model): Dict<VgTransform> {\n    return model.reduce(function(timeUnitComponent, fieldDef: FieldDef, channel: Channel) {\n      if (fieldDef.type === TEMPORAL && fieldDef.timeUnit) {\n\n        const hash = field(fieldDef);\n\n        timeUnitComponent[hash] = {\n          type: 'formula',\n          field: field(fieldDef),\n          expr: fieldExpr(fieldDef.timeUnit, fieldDef.field)\n        };\n      }\n      return timeUnitComponent;\n    }, {});\n  }\n\n  export const parseUnit = parse;\n\n  export function parseFacet(model: FacetModel) {\n    let timeUnitComponent = parse(model);\n\n    const childDataComponent = model.child().component.data;\n\n    // If child doesn't have its own data source, then merge\n    if (!childDataComponent.source) {\n      extend(timeUnitComponent, childDataComponent.timeUnit);\n      delete childDataComponent.timeUnit;\n    }\n    return timeUnitComponent;\n  }\n\n  export function parseLayer(model: LayerModel) {\n    let timeUnitComponent = parse(model);\n    model.children().forEach((child) => {\n      const childDataComponent = child.component.data;\n      if (!childDataComponent.source) {\n        extend(timeUnitComponent, childDataComponent.timeUnit);\n        delete childDataComponent.timeUnit;\n      }\n    });\n    return timeUnitComponent;\n  }\n\n  export function assemble(component: DataComponent) {\n    // just join the values, which are already transforms\n    return vals(component.timeUnit);\n  }\n}\n",
    "import {Channel} from '../../channel';\nimport {dateTimeExpr, DateTimeExpr} from '../../datetime';\nimport {FieldDef} from '../../fielddef';\nimport {TimeUnit, rawDomain} from '../../timeunit';\nimport {extend, keys, StringSet} from '../../util';\nimport {VgData} from '../../vega.schema';\n\nimport {FacetModel} from './../facet';\nimport {LayerModel} from './../layer';\nimport {Model} from './../model';\n\nimport {DataComponent} from './data';\n\n\nexport namespace timeUnitDomain {\n  function parse(model: Model): StringSet {\n    return model.reduce(function(timeUnitDomainMap, fieldDef: FieldDef, channel: Channel) {\n      if (fieldDef.timeUnit) {\n        const domain = rawDomain(fieldDef.timeUnit, channel);\n        if (domain) {\n          timeUnitDomainMap[fieldDef.timeUnit] = true;\n        }\n      }\n      return timeUnitDomainMap;\n    }, {});\n  }\n\n  export const parseUnit = parse;\n\n  export function parseFacet(model: FacetModel) {\n    // always merge with child\n    return extend(parse(model), model.child().component.data.timeUnitDomain);\n  }\n\n  export function parseLayer(model: LayerModel) {\n    // always merge with children\n    return extend(parse(model), model.children().forEach((child) => {\n      return child.component.data.timeUnitDomain;\n    }));\n  }\n\n  export function assemble(component: DataComponent): VgData[] {\n    return keys(component.timeUnitDomain).reduce(function(timeUnitData, tu: any) {\n      const timeUnit: TimeUnit = tu; // cast string back to enum\n      const domain = rawDomain(timeUnit, null); // FIXME fix rawDomain signature\n      if (domain) {\n        let datetime: DateTimeExpr = {};\n        datetime[timeUnit] = 'datum[\"data\"]';\n\n        timeUnitData.push({\n          name: timeUnit,\n          values: domain,\n          transform: [{\n            type: 'formula',\n            field: 'date',\n            expr: dateTimeExpr(datetime)\n          }]\n        });\n      }\n      return timeUnitData;\n    }, []);\n  }\n}\n",
    "import {AxisOrient, Axis} from '../axis';\nimport {COLUMN, ROW, X, Y, Channel} from '../channel';\nimport {defaultConfig, Config} from '../config';\nimport {SOURCE, SUMMARY} from '../data';\nimport {Facet} from '../facet';\nimport {channelMappingForEach} from '../encoding';\nimport {FieldDef, isDimension} from '../fielddef';\nimport {Scale, ScaleType} from '../scale';\nimport {FacetSpec} from '../spec';\nimport {getFullName} from '../type';\nimport {extend, keys, vals, flatten, duplicate, mergeDeep, Dict} from '../util';\nimport {VgData, VgMarkGroup} from '../vega.schema';\n\nimport {parseAxis, parseInnerAxis, gridShow, parseAxisComponent} from './axis';\nimport {buildModel} from './common';\nimport {assembleData, parseFacetData} from './data/data';\nimport {assembleLayout, parseFacetLayout} from './layout';\nimport {Model} from './model';\nimport {parseScaleComponent} from './scale';\n\nexport class FacetModel extends Model {\n  private _facet: Facet;\n\n  private _child: Model;\n\n  constructor(spec: FacetSpec, parent: Model, parentGivenName: string) {\n    super(spec, parent, parentGivenName);\n\n    // Config must be initialized before child as it gets cascaded to the child\n    const config = this._config = this._initConfig(spec.config, parent);\n\n    const child  = this._child = buildModel(spec.spec, this, this.name('child'));\n\n    const facet  = this._facet = this._initFacet(spec.facet);\n    this._scale  = this._initScale(facet, config, child);\n    this._axis   = this._initAxis(facet, config, child);\n  }\n\n  private _initConfig(specConfig: Config, parent: Model) {\n    return mergeDeep(duplicate(defaultConfig), specConfig, parent ? parent.config() : {});\n  }\n\n  private _initFacet(facet: Facet) {\n    // clone to prevent side effect to the original spec\n    facet = duplicate(facet);\n\n    const model = this;\n\n    channelMappingForEach(this.channels(), facet, function(fieldDef: FieldDef, channel: Channel) {\n      // TODO: if has no field / datum, then drop the field\n\n      if (!isDimension(fieldDef)) {\n        model.addWarning(channel + ' encoding should be ordinal.');\n      }\n\n      if (fieldDef.type) {\n        // convert short type to full type\n        fieldDef.type = getFullName(fieldDef.type);\n      }\n    });\n    return facet;\n  }\n\n  private _initScale(facet: Facet, config: Config, child: Model): Dict<Scale> {\n    return [ROW, COLUMN].reduce(function(_scale, channel) {\n      if (facet[channel]) {\n\n        const scaleSpec = facet[channel].scale || {};\n        _scale[channel] = extend({\n          type: ScaleType.ORDINAL,\n          round: config.facet.scale.round,\n\n          // TODO: revise this rule for multiple level of nesting\n          padding: (channel === ROW && child.has(Y)) || (channel === COLUMN && child.has(X)) ?\n                   config.facet.scale.padding : 0\n        }, scaleSpec);\n      }\n      return _scale;\n    }, {} as Dict<Scale>);\n  }\n\n  private _initAxis(facet: Facet, config: Config, child: Model): Dict<Axis> {\n    return [ROW, COLUMN].reduce(function(_axis, channel) {\n      if (facet[channel]) {\n        const axisSpec = facet[channel].axis;\n        if (axisSpec !== false) {\n          const modelAxis = _axis[channel] = extend({},\n            config.facet.axis,\n            axisSpec === true ? {} : axisSpec || {}\n          );\n\n          if (channel === ROW) {\n            const yAxis: any = child.axis(Y);\n            if (yAxis && yAxis.orient !== AxisOrient.RIGHT && !modelAxis.orient) {\n              modelAxis.orient = AxisOrient.RIGHT;\n            }\n            if( child.has(X) && !modelAxis.labelAngle) {\n              modelAxis.labelAngle = modelAxis.orient === AxisOrient.RIGHT ? 90 : 270;\n            }\n          }\n        }\n      }\n      return _axis;\n    }, {} as Dict<Axis>);\n  }\n\n  public facet() {\n    return this._facet;\n  }\n\n  public has(channel: Channel): boolean {\n    return !!this._facet[channel];\n  }\n\n  public child() {\n    return this._child;\n  }\n\n  private hasSummary() {\n    const summary = this.component.data.summary;\n    for (let i = 0 ; i < summary.length ; i++) {\n      if (keys(summary[i].measures).length > 0) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  public dataTable(): string {\n    return (this.hasSummary() ? SUMMARY : SOURCE) + '';\n  }\n\n  public fieldDef(channel: Channel): FieldDef {\n    return this.facet()[channel];\n  }\n\n  public stack() {\n    return null; // this is only a property for UnitModel\n  }\n\n  public parseData() {\n    this.child().parseData();\n    this.component.data = parseFacetData(this);\n  }\n\n  public parseSelectionData() {\n    // TODO: @arvind can write this\n    // We might need to split this into compileSelectionData and compileSelectionSignals?\n  }\n\n  public parseLayoutData() {\n    this.child().parseLayoutData();\n    this.component.layout = parseFacetLayout(this);\n  }\n\n  public parseScale() {\n    const child = this.child();\n    const model = this;\n\n    child.parseScale();\n\n    // TODO: support scales for field reference of parent data (e.g., for SPLOM)\n\n    // First, add scale for row and column.\n    let scaleComponent = this.component.scale = parseScaleComponent(this);\n\n    // Then, move shared/union from its child spec.\n    keys(child.component.scale).forEach(function(channel) {\n      // TODO: correctly implement independent scale\n      if (true) { // if shared/union scale\n        scaleComponent[channel] = child.component.scale[channel];\n\n        // for each scale, need to rename\n        vals(scaleComponent[channel]).forEach(function(scale) {\n          const scaleNameWithoutPrefix = scale.name.substr(child.name('').length);\n          const newName = model.scaleName(scaleNameWithoutPrefix);\n          child.renameScale(scale.name, newName);\n          scale.name = newName;\n        });\n\n        // Once put in parent, just remove the child's scale.\n        delete child.component.scale[channel];\n      }\n    });\n  }\n\n  public parseMark() {\n    this.child().parseMark();\n\n    this.component.mark = extend(\n      {\n        name: this.name('cell'),\n        type: 'group',\n        from: extend(\n          this.dataTable() ? {data: this.dataTable()} : {},\n          {\n            transform: [{\n              type: 'facet',\n              groupby: [].concat(\n                this.has(ROW) ? [this.field(ROW)] : [],\n                this.has(COLUMN) ? [this.field(COLUMN)] : []\n              )\n            }]\n          }\n        ),\n        properties: {\n          update: getFacetGroupProperties(this)\n        }\n      },\n      // Call child's assembleGroup to add marks, scales, axes, and legends.\n      // Note that we can call child's assembleGroup() here because parseMark()\n      // is the last method in compile() and thus the child is completely compiled\n      // at this point.\n      this.child().assembleGroup()\n    );\n  }\n\n  public parseAxis() {\n    this.child().parseAxis();\n    this.component.axis = parseAxisComponent(this, [ROW, COLUMN]);\n  }\n\n  public parseAxisGroup() {\n    // TODO: with nesting, we might need to consider calling child\n    // this.child().parseAxisGroup();\n\n    const xAxisGroup = parseAxisGroup(this, X);\n    const yAxisGroup = parseAxisGroup(this, Y);\n\n    this.component.axisGroup = extend(\n      xAxisGroup ? {x: xAxisGroup} : {},\n      yAxisGroup ? {y: yAxisGroup} : {}\n    );\n  }\n\n  public parseGridGroup() {\n    // TODO: with nesting, we might need to consider calling child\n    // this.child().parseGridGroup();\n\n    const child = this.child();\n\n    this.component.gridGroup = extend(\n      !child.has(X) && this.has(COLUMN) ? { column: getColumnGridGroups(this) } : {},\n      !child.has(Y) && this.has(ROW) ? { row: getRowGridGroups(this) } : {}\n    );\n  }\n\n  public parseLegend() {\n    this.child().parseLegend();\n\n    // TODO: support legend for independent non-position scale across facets\n    // TODO: support legend for field reference of parent data (e.g., for SPLOM)\n\n    // For now, assuming that non-positional scales are always shared across facets\n    // Thus, just move all legends from its child\n    this.component.legend = this._child.component.legend;\n    this._child.component.legend = {};\n  }\n\n  public assembleParentGroupProperties() {\n    return null;\n  }\n\n  public assembleData(data: VgData[]): VgData[] {\n    // Prefix traversal – parent data might be referred by children data\n    assembleData(this, data);\n    return this._child.assembleData(data);\n  }\n\n  public assembleLayout(layoutData: VgData[]): VgData[] {\n    // Postfix traversal – layout is assembled bottom-up\n    this._child.assembleLayout(layoutData);\n    return assembleLayout(this, layoutData);\n  }\n\n  public assembleMarks(): any[] {\n    return [].concat(\n      // axisGroup is a mapping to VgMarkGroup\n      vals(this.component.axisGroup),\n      flatten(vals(this.component.gridGroup)),\n      this.component.mark\n    );\n  }\n\n  public channels() {\n    return [ROW, COLUMN];\n  }\n\n  protected mapping() {\n    return this.facet();\n  }\n\n  public isFacet() {\n    return true;\n  }\n}\n\n// TODO: move the rest of the file into FacetModel if possible\n\nfunction getFacetGroupProperties(model: FacetModel) {\n  const child = model.child();\n  const mergedCellConfig = extend({}, child.config().cell, child.config().facet.cell);\n\n  return extend({\n      x: model.has(COLUMN) ? {\n          scale: model.scaleName(COLUMN),\n          field: model.field(COLUMN),\n          // offset by the padding\n          offset: model.scale(COLUMN).padding / 2\n        } : {value: model.config().facet.scale.padding / 2},\n\n      y: model.has(ROW) ? {\n        scale: model.scaleName(ROW),\n        field: model.field(ROW),\n        // offset by the padding\n        offset: model.scale(ROW).padding / 2\n      } : {value: model.config().facet.scale.padding / 2},\n\n      width: {field: {parent: model.child().sizeName('width')}},\n      height: {field: {parent: model.child().sizeName('height')}}\n    },\n    child.assembleParentGroupProperties(mergedCellConfig)\n  );\n}\n\nfunction parseAxisGroup(model: FacetModel, channel: Channel) {\n  // TODO: add a case where inner spec is not a unit (facet/layer/concat)\n  let axisGroup = null;\n\n  const child = model.child();\n  if (child.has(channel)) {\n    if (child.axis(channel)) {\n      if (true) { // the channel has shared axes\n\n        // add a group for the shared axes\n        axisGroup = channel === X ? getXAxesGroup(model) : getYAxesGroup(model);\n\n        if (child.axis(channel) && gridShow(child, channel)) { // show inner grid\n          // add inner axis (aka axis that shows only grid to )\n          child.component.axis[channel] = parseInnerAxis(channel, child);\n        } else {\n          delete child.component.axis[channel];\n        }\n      } else {\n        // TODO: implement independent axes support\n      }\n    }\n  }\n  return axisGroup;\n}\n\n\nfunction getXAxesGroup(model: FacetModel): VgMarkGroup {\n  const hasCol = model.has(COLUMN);\n  return extend(\n    {\n      name: model.name('x-axes'),\n      type: 'group'\n    },\n    hasCol ? {\n      from: { // TODO: if we do facet transform at the parent level we can same some transform here\n        data: model.dataTable(),\n        transform: [{\n          type: 'aggregate',\n          groupby: [model.field(COLUMN)],\n          summarize: {'*': ['count']} // just a placeholder aggregation\n        }]\n      }\n    } : {},\n    {\n      properties: {\n        update: {\n          width: {field: {parent: model.child().sizeName('width')}},\n          height: {\n            field: {group: 'height'}\n          },\n          x: hasCol ? {\n            scale: model.scaleName(COLUMN),\n            field: model.field(COLUMN),\n            // offset by the padding\n            offset: model.scale(COLUMN).padding / 2\n          } : {\n            // offset by the padding\n            value: model.config().facet.scale.padding / 2\n          }\n        }\n      },\n      axes: [parseAxis(X, model.child())]\n    }\n  );\n}\n\nfunction getYAxesGroup(model: FacetModel): VgMarkGroup {\n  const hasRow = model.has(ROW);\n  return extend(\n    {\n      name: model.name('y-axes'),\n      type: 'group'\n    },\n    hasRow ? {\n      from: {\n        data: model.dataTable(),\n        transform: [{\n          type: 'aggregate',\n          groupby: [model.field(ROW)],\n          summarize: {'*': ['count']} // just a placeholder aggregation\n        }]\n      }\n    } : {},\n    {\n      properties: {\n        update: {\n          width: {\n            field: {group: 'width'}\n          },\n          height: {field: {parent: model.child().sizeName('height')}},\n          y: hasRow ? {\n            scale: model.scaleName(ROW),\n            field: model.field(ROW),\n            // offset by the padding\n            offset: model.scale(ROW).padding / 2\n          } : {\n            // offset by the padding\n            value: model.config().facet.scale.padding / 2\n          }\n        }\n      },\n      axes: [parseAxis(Y, model.child())]\n    }\n  );\n}\n\nfunction getRowGridGroups(model: Model): any[] { // TODO: VgMarks\n  const facetGridConfig = model.config().facet.grid;\n\n  const rowGrid = {\n    name: model.name('row-grid'),\n    type: 'rule',\n    from: {\n      data: model.dataTable(),\n      transform: [{type: 'facet', groupby: [model.field(ROW)]}]\n    },\n    properties: {\n      update: {\n        y: {\n          scale: model.scaleName(ROW),\n          field: model.field(ROW)\n        },\n        x: {value: 0, offset: -facetGridConfig.offset },\n        x2: {field: {group: 'width'}, offset: facetGridConfig.offset },\n        stroke: { value: facetGridConfig.color },\n        strokeOpacity: { value: facetGridConfig.opacity },\n        strokeWidth: {value: 0.5}\n      }\n    }\n  };\n\n  return [rowGrid, {\n    name: model.name('row-grid-end'),\n    type: 'rule',\n    properties: {\n      update: {\n        y: { field: {group: 'height'}},\n        x: {value: 0, offset: -facetGridConfig.offset },\n        x2: {field: {group: 'width'}, offset: facetGridConfig.offset },\n        stroke: { value: facetGridConfig.color },\n        strokeOpacity: { value: facetGridConfig.opacity },\n        strokeWidth: {value: 0.5}\n      }\n    }\n  }];\n}\n\nfunction getColumnGridGroups(model: Model): any { // TODO: VgMarks\n  const facetGridConfig = model.config().facet.grid;\n\n  const columnGrid = {\n    name: model.name('column-grid'),\n    type: 'rule',\n    from: {\n      data: model.dataTable(),\n      transform: [{type: 'facet', groupby: [model.field(COLUMN)]}]\n    },\n    properties: {\n      update: {\n        x: {\n          scale: model.scaleName(COLUMN),\n          field: model.field(COLUMN)\n        },\n        y: {value: 0, offset: -facetGridConfig.offset},\n        y2: {field: {group: 'height'}, offset: facetGridConfig.offset },\n        stroke: { value: facetGridConfig.color },\n        strokeOpacity: { value: facetGridConfig.opacity },\n        strokeWidth: {value: 0.5}\n      }\n    }\n  };\n\n  return [columnGrid,  {\n    name: model.name('column-grid-end'),\n    type: 'rule',\n    properties: {\n      update: {\n        x: { field: {group: 'width'}},\n        y: {value: 0, offset: -facetGridConfig.offset},\n        y2: {field: {group: 'height'}, offset: facetGridConfig.offset },\n        stroke: { value: facetGridConfig.color },\n        strokeOpacity: { value: facetGridConfig.opacity },\n        strokeWidth: {value: 0.5}\n      }\n    }\n  }];\n}\n",
    "import {Channel} from '../channel';\nimport {keys, duplicate, mergeDeep, flatten, unique, isArray, vals, hash, Dict} from '../util';\nimport {defaultConfig, Config} from '../config';\nimport {LayerSpec} from '../spec';\nimport {assembleData, parseLayerData} from './data/data';\nimport {assembleLayout, parseLayerLayout} from './layout';\nimport {Model} from './model';\nimport {UnitModel} from './unit';\nimport {buildModel} from './common';\nimport {FieldDef} from '../fielddef';\nimport {ScaleComponents} from './scale';\nimport {VgData, VgAxis, VgLegend, isUnionedDomain, isDataRefDomain, VgDataRef} from '../vega.schema';\n\n\nexport class LayerModel extends Model {\n  private _children: UnitModel[];\n\n  /**\n   * Fixed width for the unit visualization.\n   * If undefined (e.g., for ordinal scale), the width of the\n   * visualization will be calculated dynamically.\n   */\n  private _width: number;\n\n  /**\n   * Fixed height for the unit visualization.\n   * If undefined (e.g., for ordinal scale), the height of the\n   * visualization will be calculated dynamically.\n   */\n  private _height: number;\n\n\n  constructor(spec: LayerSpec, parent: Model, parentGivenName: string) {\n    super(spec, parent, parentGivenName);\n\n    this._width = spec.width;\n    this._height = spec.height;\n\n    this._config = this._initConfig(spec.config, parent);\n    this._children = spec.layers.map((layer, i) => {\n      // we know that the model has to be a unit model because we pass in a unit spec\n      return buildModel(layer, this, this.name('layer_' + i)) as UnitModel;\n    });\n  }\n\n  private _initConfig(specConfig: Config, parent: Model) {\n    return mergeDeep(duplicate(defaultConfig), specConfig, parent ? parent.config() : {});\n  }\n\n  public get width(): number {\n    return this._width;\n  }\n\n  public get height(): number {\n    return this._height;\n  }\n\n  public has(channel: Channel): boolean {\n    // layer does not have any channels\n    return false;\n  }\n\n  public children() {\n    return this._children;\n  }\n\n  public isOrdinalScale(channel: Channel) {\n    // since we assume shared scales we can just ask the first child\n    return this._children[0].isOrdinalScale(channel);\n  }\n\n  public dataTable(): string {\n    // FIXME: don't just use the first child\n    return this._children[0].dataTable();\n  }\n\n  public fieldDef(channel: Channel): FieldDef {\n    return null; // layer does not have field defs\n  }\n\n  public stack() {\n    return null; // this is only a property for UnitModel\n  }\n\n  public parseData() {\n    this._children.forEach((child) => {\n      child.parseData();\n    });\n    this.component.data = parseLayerData(this);\n  }\n\n  public parseSelectionData() {\n    // TODO: @arvind can write this\n    // We might need to split this into compileSelectionData and compileSelectionSignals?\n  }\n\n  public parseLayoutData() {\n    // TODO: correctly union ordinal scales rather than just using the layout of the first child\n    this._children.forEach((child, i) => {\n      child.parseLayoutData();\n    });\n    this.component.layout = parseLayerLayout(this);\n  }\n\n  public parseScale() {\n    const model = this;\n\n    let scaleComponent = this.component.scale = {} as Dict<ScaleComponents>;\n\n    this._children.forEach(function(child) {\n      child.parseScale();\n\n      // FIXME: correctly implement independent scale\n      if (true) { // if shared/union scale\n        keys(child.component.scale).forEach(function(channel) {\n          let childScales: ScaleComponents = child.component.scale[channel];\n          if (!childScales) {\n            // the child does not have any scales so we have nothing to merge\n            return;\n          }\n\n          const modelScales: ScaleComponents = scaleComponent[channel];\n          if (modelScales && modelScales.main) {\n            // Scales are unioned by combining the domain of the main scale.\n            // Other scales that are used for ordinal legends are appended.\n            const modelDomain = modelScales.main.domain;\n            const childDomain = childScales.main.domain;\n\n            if (isArray(modelDomain)) {\n              if (isArray(childScales.main.domain)) {\n                modelScales.main.domain = modelDomain.concat(childDomain);\n              } else {\n                model.addWarning('custom domain scale cannot be unioned with default field-based domain');\n              }\n            } else {\n              const unionedFields = isUnionedDomain(modelDomain) ? modelDomain.fields : [modelDomain] as VgDataRef[];\n\n              if (isArray(childDomain)) {\n                model.addWarning('custom domain scale cannot be unioned with default field-based domain');\n              }\n\n              let fields = isDataRefDomain(childDomain) ? unionedFields.concat([childDomain]) :\n                // if the domain is itself a union domain, concat\n                isUnionedDomain(childDomain) ? unionedFields.concat(childDomain.fields) :\n                  // we have to ignore explicit data domains for now because vega does not support unioning them\n                  unionedFields;\n              fields = unique(fields, hash);\n              // TODO: if all domains use the same data, we can merge them\n              if (fields.length > 1) {\n                modelScales.main.domain = { fields: fields };\n              } else {\n                modelScales.main.domain = fields[0];\n              }\n            }\n\n            // create color legend and color legend bin scales if we don't have them yet\n            modelScales.colorLegend = modelScales.colorLegend ? modelScales.colorLegend : childScales.colorLegend;\n            modelScales.binColorLegend = modelScales.binColorLegend ? modelScales.binColorLegend : childScales.binColorLegend;\n          } else {\n            scaleComponent[channel] = childScales;\n          }\n\n          // rename child scales to parent scales\n          vals(childScales).forEach(function(scale) {\n            const scaleNameWithoutPrefix = scale.name.substr(child.name('').length);\n            const newName = model.scaleName(scaleNameWithoutPrefix);\n            child.renameScale(scale.name, newName);\n            scale.name = newName;\n          });\n\n          delete childScales[channel];\n        });\n      }\n    });\n  }\n\n  public parseMark() {\n    this._children.forEach(function(child) {\n      child.parseMark();\n    });\n  }\n\n  public parseAxis() {\n    let axisComponent = this.component.axis = {} as Dict<VgAxis[]>;\n\n    this._children.forEach(function(child) {\n      child.parseAxis();\n\n      // TODO: correctly implement independent axes\n      if (true) { // if shared/union scale\n        keys(child.component.axis).forEach(function(channel) {\n          // TODO: support multiple axes for shared scale\n\n          // just use the first axis definition for each channel\n          if (!axisComponent[channel]) {\n            axisComponent[channel] = child.component.axis[channel];\n          }\n        });\n      }\n    });\n  }\n\n  public parseAxisGroup() {\n    return null;\n  }\n\n  public parseGridGroup() {\n    return null;\n  }\n\n  public parseLegend() {\n    let legendComponent = this.component.legend = {} as Dict<VgLegend>;\n\n    this._children.forEach(function(child) {\n      child.parseLegend();\n\n      // TODO: correctly implement independent axes\n      if (true) { // if shared/union scale\n        keys(child.component.legend).forEach(function(channel) {\n          // just use the first legend definition for each channel\n          if (!legendComponent[channel]) {\n            legendComponent[channel] = child.component.legend[channel];\n          }\n        });\n      }\n    });\n  }\n\n  public assembleParentGroupProperties() {\n    return null;\n  }\n\n  public assembleData(data: VgData[]): VgData[] {\n    // Prefix traversal – parent data might be referred to by children data\n    assembleData(this, data);\n    this._children.forEach((child) => {\n      child.assembleData(data);\n    });\n    return data;\n  }\n\n  public assembleLayout(layoutData: VgData[]): VgData[] {\n    // Postfix traversal – layout is assembled bottom-up\n    this._children.forEach((child) => {\n      child.assembleLayout(layoutData);\n    });\n    return assembleLayout(this, layoutData);\n  }\n\n  public assembleMarks(): any[] {\n    // only children have marks\n    return flatten(this._children.map((child) => {\n      return child.assembleMarks();\n    }));\n  }\n\n  public channels() {\n    return [];\n  }\n\n  protected mapping() {\n    return null;\n  }\n\n  public isLayer() {\n    return true;\n  }\n\n  /**\n   * Returns true if the child either has no source defined or uses the same url.\n   * This is useful if you want to know whether it is possible to move a filter up.\n   *\n   * This function can only be called once th child has been parsed.\n   */\n  public compatibleSource(child: UnitModel) {\n    const data = this.data();\n    const childData = child.component.data;\n    const compatible = !childData.source || (data && data.url === childData.source.url);\n    return compatible;\n  }\n}\n",
    "\nimport {Channel, X, Y, ROW, COLUMN} from '../channel';\nimport {LAYOUT} from '../data';\nimport {ScaleType, BANDSIZE_FIT} from '../scale';\nimport {Formula} from '../transform';\nimport {extend, keys, StringSet} from '../util';\nimport {VgData} from '../vega.schema';\n\nimport {FacetModel} from './facet';\nimport {LayerModel} from './layer';\nimport {Model} from './model';\nimport {rawDomain} from '../timeunit';\nimport {UnitModel} from './unit';\n\n// FIXME: for nesting x and y, we need to declare x,y layout separately before joining later\n// For now, let's always assume shared scale\nexport interface LayoutComponent {\n  width: SizeComponent;\n  height: SizeComponent;\n}\n\nexport interface SizeComponent {\n  /** Field that we need to calculate distinct */\n  distinct: StringSet;\n\n  /** Array of formulas */\n  formula: Formula[];\n}\n\nexport function assembleLayout(model: Model, layoutData: VgData[]): VgData[] {\n  const layoutComponent = model.component.layout;\n  if (!layoutComponent.width && !layoutComponent.height) {\n    return layoutData; // Do nothing\n  }\n\n  if (true) { // if both are shared scale, we can simply merge data source for width and for height\n    const distinctFields = keys(extend(layoutComponent.width.distinct, layoutComponent.height.distinct));\n    const formula = layoutComponent.width.formula.concat(layoutComponent.height.formula)\n      .map(function(formula) {\n        return extend({type: 'formula'}, formula);\n      });\n\n    return [\n      distinctFields.length > 0 ? {\n        name: model.dataName(LAYOUT),\n        source: model.dataTable(),\n        transform: [{\n          type: 'aggregate',\n          summarize: distinctFields.map(function(field) {\n            return { field: field, ops: ['distinct'] };\n          })\n        }].concat(formula)\n      } : {\n        name: model.dataName(LAYOUT),\n        values: [{}],\n        transform: formula\n      }\n    ];\n  }\n  // FIXME: implement\n  // otherwise, we need to join width and height (cross)\n}\n\n// FIXME: for nesting x and y, we need to declare x,y layout separately before joining later\n// For now, let's always assume shared scale\nexport function parseUnitLayout(model: UnitModel): LayoutComponent {\n  return {\n    width: parseUnitSizeLayout(model, X),\n    height: parseUnitSizeLayout(model, Y)\n  };\n}\n\nfunction parseUnitSizeLayout(model: UnitModel, channel: Channel): SizeComponent {\n  return {\n    distinct: getDistinct(model, channel),\n    formula: [{\n      field: model.channelSizeName(channel),\n      expr: unitSizeExpr(model, channel)\n    }]\n  };\n}\n\nexport function unitSizeExpr(model: UnitModel, channel: Channel): string {\n  const scale = model.scale(channel);\n  if (scale) {\n    if (scale.type === ScaleType.ORDINAL && scale.bandSize !== BANDSIZE_FIT) {\n      return '(' + cardinalityExpr(model, channel) +\n        ' + ' + 1 +\n        ') * ' + scale.bandSize;\n    }\n  }\n  return (channel === X ? model.width : model.height) + '';\n}\n\nexport function parseFacetLayout(model: FacetModel): LayoutComponent {\n  return {\n    width: parseFacetSizeLayout(model, COLUMN),\n    height: parseFacetSizeLayout(model, ROW)\n  };\n}\n\nfunction parseFacetSizeLayout(model: FacetModel, channel: Channel): SizeComponent {\n  const childLayoutComponent = model.child().component.layout;\n  const sizeType = channel === ROW ? 'height' : 'width';\n  const childSizeComponent: SizeComponent = childLayoutComponent[sizeType];\n\n  if (true) { // assume shared scale\n    // For shared scale, we can simply merge the layout into one data source\n\n    const distinct = extend(getDistinct(model, channel), childSizeComponent.distinct);\n    const formula = childSizeComponent.formula.concat([{\n      field: model.channelSizeName(channel),\n      expr: facetSizeFormula(model, channel, model.child().channelSizeName(channel))\n    }]);\n\n    delete childLayoutComponent[sizeType];\n    return {\n      distinct: distinct,\n      formula: formula\n    };\n  }\n  // FIXME implement independent scale as well\n  // TODO: - also consider when children have different data source\n}\n\nfunction facetSizeFormula(model: Model, channel: Channel, innerSize: string) {\n  const scale = model.scale(channel);\n  if (model.has(channel)) {\n    return '(datum[\"' + innerSize + '\"] + ' + scale.padding + ')' + ' * ' + cardinalityExpr(model, channel);\n  } else {\n    return 'datum[\"' + innerSize + '\"] + ' + model.config().facet.scale.padding; // need to add outer padding for facet\n  }\n}\n\nexport function parseLayerLayout(model: LayerModel): LayoutComponent {\n  return {\n    width: parseLayerSizeLayout(model, X),\n    height: parseLayerSizeLayout(model, Y)\n  };\n}\n\nfunction parseLayerSizeLayout(model: LayerModel, channel: Channel): SizeComponent {\n  if (true) {\n    // For shared scale, we can simply merge the layout into one data source\n    // TODO: don't just take the layout from the first child\n\n    const childLayoutComponent = model.children()[0].component.layout;\n    const sizeType = channel === Y ? 'height' : 'width';\n    const childSizeComponent: SizeComponent = childLayoutComponent[sizeType];\n\n    const distinct = childSizeComponent.distinct;\n    const formula = [{\n      field: model.channelSizeName(channel),\n      expr: childSizeComponent.formula[0].expr\n    }];\n\n    model.children().forEach((child) => {\n      delete child.component.layout[sizeType];\n    });\n\n    return {\n      distinct: distinct,\n      formula: formula\n    };\n  }\n}\n\nfunction getDistinct(model: Model, channel: Channel): StringSet {\n  if (model.has(channel) && model.isOrdinalScale(channel)) {\n    const scale = model.scale(channel);\n    if (scale.type === ScaleType.ORDINAL && !(scale.domain instanceof Array)) {\n      // if explicit domain is declared, use array length\n      const distinctField = model.field(channel);\n      let distinct: StringSet = {};\n      distinct[distinctField] = true;\n      return distinct;\n    }\n  }\n  return {};\n}\n\nexport function cardinalityExpr(model: Model, channel: Channel) {\n  const scale = model.scale(channel);\n  if (scale.domain instanceof Array) {\n    return scale.domain.length;\n  }\n\n  const timeUnit = model.fieldDef(channel).timeUnit;\n  const timeUnitDomain = timeUnit ? rawDomain(timeUnit, channel) : null;\n\n  // FIXME: production rule will break here!\n  return timeUnitDomain !== null ? timeUnitDomain.length :\n    model.field(channel, {datum: true, prefix: 'distinct'});\n}\n",
    "import {COLOR, SIZE, SHAPE, OPACITY, Channel} from '../channel';\nimport {Config} from '../config';\nimport {FieldDef} from '../fielddef';\nimport {Legend} from '../legend';\nimport {title as fieldTitle} from '../fielddef';\nimport {AREA, BAR, TICK, TEXT, LINE, POINT, CIRCLE, SQUARE} from '../mark';\nimport {ORDINAL, TEMPORAL} from '../type';\nimport {extend, keys, without, Dict} from '../util';\n\nimport {applyMarkConfig, FILL_STROKE_CONFIG, numberFormat, timeTemplate} from './common';\nimport {COLOR_LEGEND, COLOR_LEGEND_LABEL} from './scale';\nimport {UnitModel} from './unit';\nimport {VgLegend} from '../vega.schema';\n\n\nexport function parseLegendComponent(model: UnitModel): Dict<VgLegend> {\n  return [COLOR, SIZE, SHAPE, OPACITY].reduce(function(legendComponent, channel) {\n    if (model.legend(channel)) {\n      legendComponent[channel] = parseLegend(model, channel);\n    }\n    return legendComponent;\n  }, {} as Dict<VgLegend>);\n}\n\nfunction getLegendDefWithScale(model: UnitModel, channel: Channel): VgLegend {\n  switch (channel) {\n    case COLOR:\n      const fieldDef = model.encoding().color;\n      const scale = model.scaleName(useColorLegendScale(fieldDef) ?\n        // To produce ordinal legend (list, rather than linear range) with correct labels:\n        // - For an ordinal field, provide an ordinal scale that maps rank values to field values\n        // - For a field with bin or timeUnit, provide an identity ordinal scale\n        // (mapping the field values to themselves)\n        COLOR_LEGEND :\n        COLOR\n      );\n\n      return model.config().mark.filled ? { fill: scale } : { stroke: scale };\n    case SIZE:\n      return { size: model.scaleName(SIZE) };\n    case SHAPE:\n      return { shape: model.scaleName(SHAPE) };\n    case OPACITY:\n      return { opacity: model.scaleName(OPACITY) };\n  }\n  return null;\n}\n\nexport function parseLegend(model: UnitModel, channel: Channel): VgLegend {\n  const fieldDef = model.fieldDef(channel);\n  const legend = model.legend(channel);\n  const config = model.config();\n\n  let def: VgLegend = getLegendDefWithScale(model, channel);\n\n  // 1.1 Add properties with special rules\n  def.title = title(legend, fieldDef, config);\n  const format = numberFormat(fieldDef, legend.format, config);\n  if (format) {\n    def.format = format;\n  }\n\n  // 1.2 Add properties without rules\n  ['offset', 'orient', 'values'].forEach(function(property) {\n    const value = legend[property];\n    if (value !== undefined) {\n      def[property] = value;\n    }\n  });\n\n  // 2) Add mark property definition groups\n  const props = (typeof legend !== 'boolean' && legend.properties) || {};\n  ['title', 'symbols', 'legend', 'labels'].forEach(function(group) {\n    let value = properties[group] ?\n      properties[group](fieldDef, props[group], model, channel) : // apply rule\n      props[group]; // no rule -- just default values\n    if (value !== undefined && keys(value).length > 0) {\n      def.properties = def.properties || {};\n      def.properties[group] = value;\n    }\n  });\n\n  return def;\n}\n\nexport function title(legend: Legend, fieldDef: FieldDef, config: Config) {\n  if (typeof legend !== 'boolean' && legend.title) {\n    return legend.title;\n  }\n\n  return fieldTitle(fieldDef, config);\n}\n\n// we have to use special scales for ordinal or binned fields for the color channel\nexport function useColorLegendScale(fieldDef: FieldDef) {\n  return fieldDef.type === ORDINAL || fieldDef.bin || fieldDef.timeUnit;\n}\n\nexport namespace properties {\n  export function symbols(fieldDef: FieldDef, symbolsSpec, model: UnitModel, channel: Channel) {\n    let symbols:any = {};\n    const mark = model.mark();\n    const legend = model.legend(channel);\n\n    switch (mark) {\n      case BAR:\n      case TICK:\n      case TEXT:\n        symbols.shape = {value: 'square'};\n        break;\n      case CIRCLE:\n      case SQUARE:\n        symbols.shape = { value: mark };\n        break;\n      case POINT:\n      case LINE:\n      case AREA:\n        // use default circle\n        break;\n    }\n\n    const cfg = model.config();\n    const filled = cfg.mark.filled;\n\n    let config = channel === COLOR ?\n        /* For color's legend, do not set fill (when filled) or stroke (when unfilled) property from config because the the legend's `fill` or `stroke` scale should have precedence */\n        without(FILL_STROKE_CONFIG, [ filled ? 'fill' : 'stroke', 'strokeDash', 'strokeDashOffset']) :\n        /* For other legend, no need to omit. */\n        without(FILL_STROKE_CONFIG, ['strokeDash', 'strokeDashOffset']);\n\n    config = without(config, ['strokeDash', 'strokeDashOffset']);\n\n    applyMarkConfig(symbols, model, config);\n\n    if (filled) {\n      symbols.strokeWidth = { value: 0 };\n    }\n\n    // Avoid override default mapping for opacity channel\n    if (channel === OPACITY) {\n      delete symbols.opacity;\n    }\n\n    let value;\n    if (model.has(COLOR) && channel === COLOR) {\n      if (useColorLegendScale(fieldDef)) {\n        // for color legend scale, we need to override\n        value = { scale: model.scaleName(COLOR), field: 'data' };\n      }\n    } else if (model.encoding().color && model.encoding().color.value) {\n      value = { value: model.encoding().color.value };\n    }\n\n    if (value !== undefined) {\n      // apply the value\n      if (filled) {\n        symbols.fill = value;\n      } else {\n        symbols.stroke = value;\n      }\n    } else if (channel !== COLOR) {\n      // For non-color legend, apply color config if there is no fill / stroke config.\n      // (For color, do not override scale specified!)\n      symbols[filled ? 'fill' : 'stroke'] = symbols[filled ? 'fill' : 'stroke'] ||\n        {value: cfg.mark.color};\n    }\n\n    if (legend.symbolColor !== undefined) {\n      symbols.fill = {value: legend.symbolColor};\n    } else if (symbols.fill === undefined) {\n      // fall back to mark config colors for legend fill\n      if (cfg.mark.fill !== undefined) {\n        symbols.fill = {value: cfg.mark.fill};\n      } else if (cfg.mark.stroke !== undefined) {\n        symbols.stroke = {value: cfg.mark.stroke};\n      }\n    }\n\n    if (channel !== SHAPE) {\n      if (legend.symbolShape !== undefined) {\n        symbols.shape = {value: legend.symbolShape};\n      } else if (cfg.mark.shape !== undefined) {\n        symbols.shape = {value: cfg.mark.shape};\n      }\n    }\n\n    if (channel !== SIZE) {\n      if (legend.symbolSize !== undefined) {\n        symbols.size = {value: legend.symbolSize};\n      }\n    }\n\n    if (legend.symbolStrokeWidth !== undefined) {\n      symbols.strokeWidth = {value: legend.symbolStrokeWidth};\n    }\n\n    symbols = extend(symbols, symbolsSpec || {});\n\n    return keys(symbols).length > 0 ? symbols : undefined;\n  }\n\n  export function labels(fieldDef: FieldDef, labelsSpec, model: UnitModel, channel: Channel) {\n    const legend = model.legend(channel);\n    const config = model.config();\n\n    let labels:any = {};\n\n    if (channel === COLOR) {\n      if (fieldDef.type === ORDINAL) {\n        labelsSpec = extend({\n          text: {\n            scale: model.scaleName(COLOR_LEGEND),\n            field: 'data'\n          }\n        }, labelsSpec || {});\n      } else if (fieldDef.bin) {\n        labelsSpec = extend({\n          text: {\n            scale: model.scaleName(COLOR_LEGEND_LABEL),\n            field: 'data'\n          }\n        }, labelsSpec || {});\n      } else if (fieldDef.type === TEMPORAL) {\n        labelsSpec = extend({\n          text: {\n            template: timeTemplate('datum[\"data\"]', fieldDef.timeUnit, legend.format, legend.shortTimeLabels, config)\n          }\n        }, labelsSpec || {});\n      }\n    }\n\n    if (legend.labelAlign !== undefined) {\n      labels.align = {value: legend.labelAlign};\n    }\n\n    if (legend.labelColor !== undefined) {\n      labels.stroke = {value: legend.labelColor};\n    }\n\n    if (legend.labelFont !== undefined) {\n      labels.font = {value: legend.labelFont};\n    }\n\n    if (legend.labelFontSize !== undefined) {\n      labels.fontSize = {value: legend.labelFontSize};\n    }\n\n    if (legend.labelBaseline !== undefined) {\n      labels.baseline = {value: legend.labelBaseline};\n    }\n\n    labels = extend(labels, labelsSpec || {});\n\n    return keys(labels).length > 0 ? labels : undefined;\n  }\n\n  export function title(fieldDef: FieldDef, titleSpec, model: UnitModel, channel: Channel) {\n    const legend = model.legend(channel);\n\n    let titles:any = {};\n\n    if (legend.titleColor !== undefined) {\n      titles.stroke = {value: legend.titleColor};\n    }\n\n    if (legend.titleFont !== undefined) {\n      titles.font = {value: legend.titleFont};\n    }\n\n    if (legend.titleFontSize !== undefined) {\n      titles.fontSize = {value: legend.titleFontSize};\n    }\n\n    if (legend.titleFontWeight !== undefined) {\n      titles.fontWeight = {value: legend.titleFontWeight};\n    }\n\n    titles = extend(titles, titleSpec || {});\n\n    return keys(titles).length > 0 ? titles : undefined;\n  }\n}\n",
    "import {VgValueRef} from '../../vega.schema';\n\nimport {X, Y} from '../../channel';\nimport {Orient} from '../../config';\nimport {FieldDef, field} from '../../fielddef';\nimport {Scale, ScaleType} from '../../scale';\nimport {StackProperties} from '../../stack';\n\nimport {applyColorAndOpacity, applyMarkConfig} from '../common';\nimport {UnitModel} from '../unit';\n\nexport namespace area {\n  export function markType() {\n    return 'area';\n  }\n\n  export function properties(model: UnitModel) {\n    // TODO Use Vega's marks properties interface\n    let p: any = {};\n    const config = model.config();\n\n    // We should always have orient as we augment it in config.ts\n    const orient = config.mark.orient;\n    p.orient = { value: orient} ;\n\n    const stack = model.stack();\n\n    p.x = x(model.encoding().x, model.scaleName(X), model.scale(X), orient, stack);\n    p.y = y(model.encoding().y, model.scaleName(Y), model.scale(Y), orient, stack);\n\n    // Have only x2 or y2\n    const _x2 = x2(model.encoding().x, model.encoding().x2, model.scaleName(X), model.scale(X), orient, stack);\n    if (_x2) {\n      p.x2 = _x2;\n    }\n\n    const _y2 = y2(model.encoding().y, model.encoding().y2, model.scaleName(Y), model.scale(Y), orient, stack);\n    if (_y2) {\n      p.y2 = _y2;\n    }\n\n    applyColorAndOpacity(p, model);\n    applyMarkConfig(p, model, ['interpolate', 'tension']);\n    return p;\n  }\n\n  export function x(fieldDef: FieldDef, scaleName: string, scale: Scale, orient: Orient, stack: StackProperties): VgValueRef {\n    if (stack && X === stack.fieldChannel) { // Stacked Measure\n      return {\n        scale: scaleName,\n        field: field(fieldDef, { suffix: 'start' })\n      };\n    } else if (fieldDef) {\n      if (fieldDef.field) {\n        return {\n          scale: scaleName,\n          field: field(fieldDef, { binSuffix: 'mid' })\n        };\n      } else if (fieldDef.value) {\n        return {\n          scale: scaleName,\n          value: fieldDef.value\n        };\n      }\n    }\n\n    return { value: 0 };\n  }\n\n  export function x2(xFieldDef: FieldDef, x2FieldDef: FieldDef, scaleName: string, scale: Scale, orient: Orient, stack: StackProperties): VgValueRef {\n    // x\n    if (orient === Orient.HORIZONTAL) {\n      if (stack && X === stack.fieldChannel) { // Stacked Measure\n        return {\n          scale: scaleName,\n          field: field(xFieldDef, { suffix: 'end' })\n        };\n      } else if (x2FieldDef) {\n        if (x2FieldDef.field) {\n          return {\n            scale: scaleName,\n            field: field(x2FieldDef)\n          };\n        } else if (x2FieldDef.value) {\n          return {\n            scale: scaleName,\n            value: x2FieldDef.value\n          };\n        }\n      }\n\n      if (scale.type === ScaleType.LOG || scale.zero === false) {\n        return {\n          value: 0\n        };\n      }\n\n      return {\n        scale: scaleName,\n        value: 0\n      };\n    }\n    return undefined;\n  }\n\n  export function y(fieldDef: FieldDef, scaleName: string, scale: Scale, orient: Orient, stack: StackProperties): VgValueRef {\n    if (stack && Y === stack.fieldChannel) { // Stacked Measure\n      return {\n        scale: scaleName,\n        field: field(fieldDef, { suffix: 'start' })\n      };\n    } else if (fieldDef) {\n      if (fieldDef.field) {\n        return {\n          scale: scaleName,\n          field: field(fieldDef, { binSuffix: 'mid' })\n        };\n      } else if (fieldDef.value) {\n        return {\n          scale: scaleName,\n          value: fieldDef.value\n        };\n      }\n    }\n    return { value: 0 };\n  }\n\n  export function y2(yFieldDef: FieldDef, y2FieldDef: FieldDef,\n      scaleName: string, scale: Scale, orient: Orient, stack: StackProperties): VgValueRef {\n\n    if (orient !== Orient.HORIZONTAL) {\n      if (stack && Y === stack.fieldChannel) { // Stacked Measure\n        return {\n          scale: scaleName,\n          field: field(yFieldDef, { suffix: 'end' })\n        };\n      } else if (y2FieldDef) {\n        // y2\n        if (y2FieldDef.field) {\n          return {\n            scale: scaleName,\n            field: field(y2FieldDef)\n          };\n        } else if (y2FieldDef.value) {\n          return {\n            scale: scaleName,\n            value: y2FieldDef.value\n          };\n        }\n      }\n\n      if (scale.type === ScaleType.LOG || scale.zero === false) {\n        return {\n          field: {group: 'height'}\n        };\n      }\n\n      return {\n        scale: scaleName,\n        value: 0\n      };\n    }\n    return undefined;\n  }\n}\n",
    "import {X, Y, X2, Y2, SIZE, Channel} from '../../channel';\nimport {Orient} from '../../config';\nimport {isMeasure} from '../../fielddef';\nimport {BANDSIZE_FIT, ScaleType} from '../../scale';\nimport {UnitModel} from '../unit';\nimport {applyColorAndOpacity} from '../common';\n\nexport namespace bar {\n  export function markType() {\n    return 'rect';\n  }\n\n  export function properties(model: UnitModel) {\n    // TODO Use Vega's marks properties interface\n    let p: any = {};\n\n    const orient = model.config().mark.orient;\n\n    const stack = model.stack();\n    const xFieldDef = model.encoding().x;\n    const x2FieldDef = model.encoding().x2;\n\n    const xIsMeasure = isMeasure(xFieldDef) || isMeasure(x2FieldDef);\n\n    // x, x2, and width -- we must specify two of these in all conditions\n    if (stack && X === stack.fieldChannel) {\n      // 'x' is a stacked measure, thus use <field>_start and <field>_end for x, x2.\n      p.x = {\n        scale: model.scaleName(X),\n        field: model.field(X, { suffix: 'start' })\n      };\n      p.x2 = {\n        scale: model.scaleName(X),\n        field: model.field(X, { suffix: 'end' })\n      };\n    } else if (xIsMeasure) {\n      if (orient === Orient.HORIZONTAL) {\n        if (model.has(X)) {\n          p.x = {\n            scale: model.scaleName(X),\n            field: model.field(X)\n          };\n        } else {\n          p.x = {\n            scale: model.scaleName(X),\n            value: 0\n          };\n        }\n\n        if (model.has(X2)) {\n          p.x2 = {\n            scale: model.scaleName(X),\n            field: model.field(X2)\n          };\n        } else {\n          if (model.scale(X).type === ScaleType.LOG || model.scale(X).zero === false) {\n            p.x2 = { value: 0 };\n          } else {\n            p.x2 = {\n              scale: model.scaleName(X),\n              value: 0\n            };\n          }\n\n        }\n      } else { // vertical\n        p.xc = {\n          scale: model.scaleName(X),\n          field: model.field(X)\n        };\n        p.width = {value: sizeValue(model, X)};\n      }\n    } else { // x is dimension or unspecified\n      if (model.has(X)) { // is ordinal\n        if (model.encoding().x.bin) {\n          if (model.has(SIZE) && orient !== Orient.HORIZONTAL) {\n            // For vertical chart that has binned X and size,\n            // center bar and apply size to width.\n            p.xc = {\n              scale: model.scaleName(X),\n              field: model.field(X, { binSuffix: 'mid' })\n            };\n            p.width = {\n              scale: model.scaleName(SIZE),\n              field: model.field(SIZE)\n            };\n          } else {\n            p.x = {\n              scale: model.scaleName(X),\n              field: model.field(X, { binSuffix: 'start' }),\n              offset: 1\n            };\n            p.x2 = {\n              scale: model.scaleName(X),\n              field: model.field(X, { binSuffix: 'end' })\n            };\n          }\n        } else if (model.scale(X).bandSize === BANDSIZE_FIT) {\n          p.x = {\n            scale: model.scaleName(X),\n            field: model.field(X),\n            offset: 0.5 // TODO offset or padding\n          };\n        } else {\n          p.xc = {\n            scale: model.scaleName(X),\n            field: model.field(X)\n          };\n        }\n     } else { // no x\n        p.x = { value: 0, offset: 2 };\n      }\n\n      p.width = model.has(X) && model.scale(X).bandSize === BANDSIZE_FIT ? {\n          scale: model.scaleName(X),\n          band: true,\n          offset: -0.5 // TODO offset or padding\n        } : model.has(SIZE) && orient !== Orient.HORIZONTAL ? {\n          // apply size scale if has size and is vertical (explicit \"vertical\" or undefined)\n          scale: model.scaleName(SIZE),\n          field: model.field(SIZE)\n        } : {\n          // otherwise, use fixed size\n          value: sizeValue(model, (X))\n        };\n    }\n\n    const yFieldDef = model.encoding().y;\n    const y2FieldDef = model.encoding().y2;\n\n    const yIsMeasure = isMeasure(yFieldDef) || isMeasure(y2FieldDef);\n    // y, y2 & height -- we must specify two of these in all conditions\n    if (stack && Y === stack.fieldChannel) { // y is stacked measure\n      p.y = {\n        scale: model.scaleName(Y),\n        field: model.field(Y, { suffix: 'start' })\n      };\n      p.y2 = {\n        scale: model.scaleName(Y),\n        field: model.field(Y, { suffix: 'end' })\n      };\n    } else if (yIsMeasure) {\n      if (orient !== Orient.HORIZONTAL) { // vertical (explicit 'vertical' or undefined)\n        if (model.has(Y)) {\n          p.y = {\n            scale: model.scaleName(Y),\n            field: model.field(Y)\n          };\n        } else {\n          p.y = {\n            scale: model.scaleName(Y),\n            value: 0\n          };\n        }\n\n        if (model.has(Y2)) {\n          p.y2 = {\n            scale: model.scaleName(Y),\n            field: model.field(Y2)\n          };\n        } else {\n          if (model.scale(Y).type === ScaleType.LOG || model.scale(Y).zero === false) {\n            // end on axis\n            p.y2 = {\n              field: {group: 'height'}\n            };\n          } else {\n            p.y2 = {\n              scale: model.scaleName(Y),\n              value: 0\n            };\n          }\n        }\n      } else {\n        p.yc = {\n          scale: model.scaleName(Y),\n          field: model.field(Y)\n        };\n        p.height = { value: sizeValue(model, Y) };\n      }\n    } else { // y is ordinal or unspecified\n\n      if (model.has(Y)) { // is ordinal\n        if (model.encoding().y.bin) {\n          if (model.has(SIZE) && orient === Orient.HORIZONTAL) {\n            // For horizontal chart that has binned Y and size,\n            // center bar and apply size to height.\n            p.yc = {\n              scale: model.scaleName(Y),\n              field: model.field(Y, { binSuffix: 'mid' })\n            };\n            p.height = {\n              scale: model.scaleName(SIZE),\n              field: model.field(SIZE)\n            };\n          } else {\n            // Otherwise, simply use <field>_start, <field>_end\n            p.y = {\n              scale: model.scaleName(Y),\n              field: model.field(Y, { binSuffix: 'start' })\n            };\n            p.y2 = {\n              scale: model.scaleName(Y),\n              field: model.field(Y, { binSuffix: 'end' }),\n              offset: 1\n            };\n          }\n        } else if (model.scale(Y).bandSize === BANDSIZE_FIT) {\n          p.y = {\n            scale: model.scaleName(Y),\n            field: model.field(Y),\n            offset: 0.5 // TODO offset or padding\n          };\n        } else {\n          p.yc = {\n            scale: model.scaleName(Y),\n            field: model.field(Y)\n          };\n        }\n      } else { // No Y\n        p.y2 = {\n          field: { group: 'height' },\n          offset: -1\n        };\n      }\n\n      p.height = model.has(Y) && model.scale(Y).bandSize === BANDSIZE_FIT ? {\n          scale: model.scaleName(Y),\n          band: true,\n          offset: -0.5 // TODO offset or padding\n        } : model.has(SIZE)  && orient === Orient.HORIZONTAL ? {\n          // apply size scale if has size and is horizontal\n          scale: model.scaleName(SIZE),\n          field: model.field(SIZE)\n        } : {\n          value: sizeValue(model, Y)\n        };\n    }\n\n    applyColorAndOpacity(p, model);\n    return p;\n  }\n\n  // TODO: make this a mixins\n  function sizeValue(model: UnitModel, channel: Channel) {\n    const fieldDef = model.encoding().size;\n    if (fieldDef && fieldDef.value !== undefined) {\n       return fieldDef.value;\n    }\n\n    const markConfig = model.config().mark;\n    if (markConfig.barSize) {\n      return markConfig.barSize;\n    }\n    // BAR's size is applied on either X or Y\n    return model.isOrdinalScale(channel) ?\n        // For ordinal scale or single bar, we can use bandSize - 1\n        // (-1 so that the border of the bar falls on exact pixel)\n        model.scale(channel).bandSize - 1 :\n        // TODO: {band: true}\n      !model.has(channel) ?\n        model.config().scale.bandSize - 1 :\n        // otherwise, set to thinBarWidth by default\n        markConfig.barThinSize;\n  }\n}\n",
    "import {X, Y} from '../../channel';\nimport {Config} from '../../config';\nimport {FieldDef, field} from '../../fielddef';\nimport {VgValueRef} from '../../vega.schema';\n\nimport {applyColorAndOpacity, applyMarkConfig} from '../common';\nimport {UnitModel} from '../unit';\n\nexport namespace line {\n  export function markType() {\n    return 'line';\n  }\n\n  export function properties(model: UnitModel) {\n    // TODO Use Vega's marks properties interface\n    let p: any = {};\n    const config = model.config();\n\n    p.x = x(model.encoding().x, model.scaleName(X), config);\n\n    p.y = y(model.encoding().y, model.scaleName(Y), config);\n\n    const _size = size(model.encoding().size, config);\n    if (_size) { p.strokeWidth = _size; }\n\n    applyColorAndOpacity(p, model);\n    applyMarkConfig(p, model, ['interpolate', 'tension']);\n    return p;\n  }\n\n  function x(fieldDef: FieldDef, scaleName: string, config: Config): VgValueRef {\n    // x\n    if (fieldDef) {\n      if (fieldDef.field) {\n        return {\n          scale: scaleName,\n          field: field(fieldDef, { binSuffix: 'mid' })\n        };\n      }\n      // TODO: fieldDef.value (for layering)\n    }\n    return { value: 0 };\n  }\n\n  function y(fieldDef: FieldDef, scaleName: string, config: Config): VgValueRef {\n    // y\n    if (fieldDef) {\n      if (fieldDef.field) {\n        return {\n          scale: scaleName,\n          field: field(fieldDef, { binSuffix: 'mid' })\n        };\n      }\n      // TODO: fieldDef.value (for layering)\n    }\n    return { field: { group: 'height' } };\n  }\n\n  function size(fieldDef: FieldDef, config: Config) {\n    if (fieldDef && fieldDef.value !== undefined) {\n       return { value: fieldDef.value};\n    }\n    return { value: config.mark.lineSize };\n  }\n}\n",
    "import {X, Y, COLOR, TEXT, SHAPE, PATH, ORDER, OPACITY, DETAIL, STACK_GROUP_CHANNELS} from '../../channel';\nimport {Orient} from '../../config';\nimport {has, isAggregate} from '../../encoding';\nimport {OrderChannelDef, FieldDef, field} from '../../fielddef';\nimport {AREA, LINE, TEXT as TEXTMARK} from '../../mark';\nimport {ScaleType} from '../../scale';\nimport {isSortField} from '../../sort';\nimport {contains, extend, isArray} from '../../util';\nimport {VgStackTransform} from '../../vega.schema';\n\nimport {area} from './area';\nimport {bar} from './bar';\nimport {sortField} from '../common';\nimport {line} from './line';\nimport {point, circle, square} from './point';\nimport {rule} from './rule';\nimport {text} from './text';\nimport {tick} from './tick';\nimport {UnitModel} from '../unit';\n\nconst markCompiler = {\n  area: area,\n  bar: bar,\n  line: line,\n  point: point,\n  text: text,\n  tick: tick,\n  rule: rule,\n  circle: circle,\n  square: square\n};\n\nexport function parseMark(model: UnitModel): any[] {\n  if (contains([LINE, AREA], model.mark())) {\n    return parsePathMark(model);\n  } else {\n    return parseNonPathMark(model);\n  }\n}\n\nfunction parsePathMark(model: UnitModel) { // TODO: extract this into compilePathMark\n  const mark = model.mark();\n  // TODO: replace this with more general case for composition\n  const isFaceted = model.parent() && model.parent().isFacet();\n  const dataFrom = {data: model.dataTable()};\n  const details = detailFields(model);\n\n  let pathMarks: any = [\n    {\n      name: model.name('marks'),\n      type: markCompiler[mark].markType(),\n      from: extend(\n        // If has facet, `from.data` will be added in the cell group.\n        // If has subfacet for line/area group, `from.data` will be added in the outer subfacet group below.\n        // If has no subfacet, add from.data.\n        isFaceted || details.length > 0 ? {} : dataFrom,\n\n        // sort transform\n        {transform: [{ type: 'sort', by: sortPathBy(model)}]}\n      ),\n      properties: { update: markCompiler[mark].properties(model) }\n    }\n  ];\n\n  if (details.length > 0) { // have level of details - need to facet line into subgroups\n    const facetTransform = { type: 'facet', groupby: details };\n    const transform: any[] = mark === AREA && model.stack() ?\n      // For stacked area, we need to impute missing tuples and stack values\n      // (Mark layer order does not matter for stacked charts)\n      stackTransforms(model, true).concat(facetTransform) :\n      // For non-stacked path (line/area), we need to facet and possibly sort\n      [].concat(\n        facetTransform,\n        // if model has `order`, then sort mark's layer order by `order` field(s)\n        model.has(ORDER) ? [{type:'sort', by: sortBy(model)}] : []\n      );\n\n    return [{\n      name: model.name('pathgroup'),\n      type: 'group',\n      from: extend(\n        // If has facet, `from.data` will be added in the cell group.\n        // Otherwise, add it here.\n        isFaceted ? {} : dataFrom,\n        {transform: transform}\n      ),\n      properties: {\n        update: {\n          width: { field: { group: 'width' } },\n          height: { field: { group: 'height' } }\n        }\n      },\n      marks: pathMarks\n    }];\n  } else {\n    return pathMarks;\n  }\n}\n\nfunction parseNonPathMark(model: UnitModel) {\n  const mark = model.mark();\n  const isFaceted = model.parent() && model.parent().isFacet();\n  const dataFrom = {data: model.dataTable()};\n\n  let marks = []; // TODO: vgMarks\n  if (mark === TEXTMARK &&\n    model.has(COLOR) &&\n    model.config().mark.applyColorToBackground && !model.has(X) && !model.has(Y)\n  ) {\n    // add background to 'text' marks if has color\n    marks.push(extend(\n      {\n        name: model.name('background'),\n        type: 'rect'\n      },\n      // If has facet, `from.data` will be added in the cell group.\n      // Otherwise, add it here.\n      isFaceted ? {} : {from: dataFrom},\n      // Properties\n      { properties: { update: text.background(model) } }\n    ));\n  }\n\n  marks.push(extend(\n    {\n      name: model.name('marks'),\n      type: markCompiler[mark].markType()\n    },\n    // Add `from` if needed\n    (!isFaceted || model.stack() || model.has(ORDER)) ? {\n      from: extend(\n        // If faceted, `from.data` will be added in the cell group.\n        // Otherwise, add it here\n        isFaceted ? {} : dataFrom,\n        // `from.transform`\n        model.stack() ? // Stacked Chart need stack transform\n          { transform: stackTransforms(model, false) } :\n        model.has(ORDER) ?\n          // if non-stacked, detail field determines the layer order of each mark\n          { transform: [{type:'sort', by: sortBy(model)}] } :\n          {}\n      )\n    } : {},\n    // properties groups\n    { properties: { update: markCompiler[mark].properties(model) } }\n  ));\n\n  return marks;\n}\n\nfunction sortBy(model: UnitModel): string | string[] {\n  if (model.has(ORDER)) {\n    let channelDef = model.encoding().order;\n    if (channelDef instanceof Array) {\n      // sort by multiple fields\n      return channelDef.map(sortField);\n    } else {\n      // sort by one field\n      return sortField(channelDef as OrderChannelDef); // have to add OrderChannelDef to make tsify not complaining\n    }\n  }\n  return null; // use default order\n}\n\n/**\n * Return path order for sort transform's by property\n */\nfunction sortPathBy(model: UnitModel): string | string[] {\n  if (model.mark() === LINE && model.has(PATH)) {\n    // For only line, sort by the path field if it is specified.\n    const channelDef = model.encoding().path;\n    if (channelDef instanceof Array) {\n      // sort by multiple fields\n      return channelDef.map(sortField);\n    } else {\n      // sort by one field\n      return sortField(channelDef as OrderChannelDef); // have to add OrderChannelDef to make tsify not complaining\n    }\n  } else {\n    // For both line and area, we sort values based on dimension by default\n    const dimensionChannel = model.config().mark.orient === Orient.HORIZONTAL ? Y : X;\n    const sort = model.sort(dimensionChannel);\n    if (isSortField(sort)) {\n      return '-' + field({\n        aggregate: isAggregate(model.encoding()) ? sort.op : undefined,\n        field: sort.field\n      });\n    } else {\n      return '-' + model.field(dimensionChannel, {binSuffix: 'mid'});\n    }\n  }\n}\n\n/**\n * Returns list of detail fields (for 'color', 'shape', or 'detail' channels)\n * that the model's spec contains.\n */\nfunction detailFields(model: UnitModel): string[] {\n  return [COLOR, DETAIL, OPACITY, SHAPE].reduce(function(details, channel) {\n    if (model.has(channel) && !model.fieldDef(channel).aggregate) {\n      details.push(model.field(channel));\n    }\n    return details;\n  }, []);\n}\n\n\nfunction stackTransforms(model: UnitModel, impute: boolean): any[] {\n  const stackByFields = getStackByFields(model);\n  if (impute) {\n    return [imputeTransform(model, stackByFields), stackTransform(model, stackByFields)];\n  }\n  return [stackTransform(model, stackByFields)];\n}\n\n\n/** Compile stack-by field names from (from 'color' and 'detail') */\nfunction getStackByFields(model: UnitModel) {\n  const encoding = model.encoding();\n\n  return STACK_GROUP_CHANNELS.reduce(function(fields, channel) {\n    const channelEncoding = encoding[channel];\n    if (has(encoding, channel)) {\n      if (isArray(channelEncoding)) {\n        channelEncoding.forEach(function(fieldDef) {\n          fields.push(field(fieldDef));\n        });\n      } else {\n        const fieldDef: FieldDef = channelEncoding;\n        const scale = model.scale(channel);\n        const _field = field(fieldDef, {\n          binSuffix: scale && scale.type === ScaleType.ORDINAL ? 'range' : 'start'\n        });\n        if (!!_field) {\n          fields.push(_field);\n        }\n      }\n    }\n    return fields;\n  }, []);\n}\n\n// impute data for stacked area\nfunction imputeTransform(model: UnitModel, stackFields: string[]) {\n  const stack = model.stack();\n  return {\n    type: 'impute',\n    field: model.field(stack.fieldChannel),\n    groupby: stackFields,\n    orderby: [model.field(stack.groupbyChannel, {binSuffix: 'mid'})],\n    method: 'value',\n    value: 0\n  };\n}\n\nfunction stackTransform(model: UnitModel, stackFields: string[]) {\n  const stack = model.stack();\n  const encoding = model.encoding();\n  const sortby = model.has(ORDER) ?\n    (isArray(encoding[ORDER]) ? encoding[ORDER] : [encoding[ORDER]]).map(sortField) :\n    // default = descending by stackFields\n    stackFields.map(function(field) {\n     return '-' + field;\n    });\n\n  const valName = model.field(stack.fieldChannel);\n\n  // add stack transform to mark\n  let transform: VgStackTransform = {\n    type: 'stack',\n    groupby: [model.field(stack.groupbyChannel, {binSuffix: 'mid'}) || 'undefined'],\n    field: model.field(stack.fieldChannel),\n    sortby: sortby,\n    output: {\n      start: valName + '_start',\n      end: valName + '_end'\n    }\n  };\n\n  if (stack.offset) {\n    transform.offset = stack.offset;\n  }\n  return transform;\n}\n",
    "import {X, Y, SHAPE, SIZE} from '../../channel';\nimport {Config} from '../../config';\nimport {ChannelDefWithLegend, FieldDef, field} from '../../fielddef';\nimport {Scale} from '../../scale';\nimport {VgValueRef} from '../../vega.schema';\n\nimport {applyColorAndOpacity} from '../common';\nimport {UnitModel} from '../unit';\n\nexport namespace point {\n  export function markType() {\n    return 'symbol';\n  }\n\n  export function properties(model: UnitModel, fixedShape?: string) {\n    // TODO Use Vega's marks properties interface\n    let p: any = {};\n    const config = model.config();\n\n    p.x = x(model.encoding().x, model.scaleName(X), config);\n\n    p.y = y(model.encoding().y, model.scaleName(Y), config);\n\n    p.size = size(model.encoding().size, model.scaleName(SIZE), model.scale(SIZE), config);\n\n    p.shape = shape(model.encoding().shape, model.scaleName(SHAPE), model.scale(SHAPE), config, fixedShape);\n\n    applyColorAndOpacity(p, model);\n    return p;\n  }\n\n  function x(fieldDef: FieldDef, scaleName: string, config: Config): VgValueRef {\n    // x\n    if (fieldDef) {\n      if (fieldDef.field) {\n        return {\n          scale: scaleName,\n          field: field(fieldDef, { binSuffix: 'mid' })\n        };\n      }\n      // TODO: fieldDef.value (for layering)\n    }\n    // TODO: allow this to fit\n    return { value: config.scale.bandSize / 2 };\n  }\n\n  function y(fieldDef: FieldDef, scaleName: string, config: Config): VgValueRef {\n    // y\n    if (fieldDef) {\n      if (fieldDef.field) {\n        return {\n          scale: scaleName,\n          field: field(fieldDef, { binSuffix: 'mid' })\n        };\n      }\n      // TODO: fieldDef.value (for layering)\n    }\n    // TODO: allow this to fit\n    return { value: config.scale.bandSize / 2 };\n  }\n\n  function size(fieldDef: ChannelDefWithLegend, scaleName: string, scale: Scale, config: Config): VgValueRef {\n    if (fieldDef) {\n      if (fieldDef.field) {\n        return {\n          scale: scaleName,\n          field: field(fieldDef, {scaleType: scale.type})\n        };\n      } else if (fieldDef.value !== undefined) {\n        return { value: fieldDef.value };\n      }\n    }\n    return { value: config.mark.size };\n  }\n\n  function shape(fieldDef: ChannelDefWithLegend, scaleName: string, scale: Scale, config: Config, fixedShape?: string): VgValueRef {\n    // shape\n    if (fixedShape) { // square and circle marks\n      return { value: fixedShape };\n    } else if (fieldDef) {\n      if (fieldDef.field) {\n        return {\n          scale: scaleName,\n          field: field(fieldDef, {scaleType: scale.type})\n        };\n      } else if (fieldDef.value) {\n        return { value: fieldDef.value };\n      }\n    }\n    return { value: config.mark.shape };\n  }\n}\n\nexport namespace circle {\n  export function markType() {\n    return 'symbol';\n  }\n\n  export function properties(model: UnitModel) {\n    return point.properties(model, 'circle');\n  }\n}\n\nexport namespace square {\n  export function markType() {\n    return 'symbol';\n  }\n\n  export function properties(model: UnitModel) {\n    return point.properties(model, 'square');\n  }\n}\n",
    "import {X, Y, X2, Y2, SIZE} from '../../channel';\nimport {Orient} from '../../config';\n\nimport {UnitModel} from '../unit';\nimport {applyColorAndOpacity} from '../common';\n\nexport namespace rule {\n  export function markType() {\n    return 'rule';\n  }\n\n  export function properties(model: UnitModel) {\n    let p: any = {};\n\n    // TODO: support explicit value\n    if(model.config().mark.orient === Orient.VERTICAL) {\n      if (model.has(X)) {\n        p.x = {\n          scale: model.scaleName(X),\n          field: model.field(X, { binSuffix: 'mid' })\n        };\n      } else {\n        p.x = { value : 0 };\n      }\n\n      if (model.has(Y)) {\n        p.y = {\n          scale: model.scaleName(Y),\n          field: model.field(Y, { binSuffix: 'mid' })\n        };\n      } else {\n        p.y = { field: { group: 'height' } };\n      }\n\n      if (model.has(Y2)) {\n        p.y2 = {\n          scale: model.scaleName(Y),\n          field: model.field(Y2, { binSuffix: 'mid' })\n        };\n      } else {\n        p.y2 = { value: 0 };\n      }\n    } else {\n      if (model.has(Y)) {\n        p.y = {\n          scale: model.scaleName(Y),\n          field: model.field(Y, { binSuffix: 'mid' })\n        };\n      } else {\n        p.y = { value: 0 };\n      }\n\n      if (model.has(X)) {\n        p.x = {\n          scale: model.scaleName(X),\n          field: model.field(X, { binSuffix: 'mid' })\n        };\n      } else {\n        p.x = { value: 0 };\n      }\n\n      if (model.has(X2)) {\n        p.x2 = {\n          scale: model.scaleName(X),\n          field: model.field(X2, { binSuffix: 'mid' })\n        };\n      } else {\n        p.x2 = { field: { group: 'width' } };\n      }\n    }\n\n    // FIXME: this function would overwrite strokeWidth but shouldn't\n    applyColorAndOpacity(p, model);\n\n    // size\n    if (model.has(SIZE)) {\n      p.strokeWidth = {\n        scale: model.scaleName(SIZE),\n        field: model.field(SIZE)\n      };\n    } else {\n      p.strokeWidth = { value: sizeValue(model) };\n    }\n    return p;\n  }\n\n  function sizeValue(model: UnitModel) {\n    const fieldDef = model.encoding().size;\n    if (fieldDef && fieldDef.value !== undefined) {\n       return fieldDef.value;\n    }\n\n    return model.config().mark.ruleSize;\n  }\n}\n",
    "import {X, Y, COLOR, TEXT, SIZE} from '../../channel';\nimport {applyMarkConfig, applyColorAndOpacity, numberFormat, timeTemplate} from '../common';\nimport {Config} from '../../config';\nimport {FieldDef, field} from '../../fielddef';\nimport {QUANTITATIVE, ORDINAL, TEMPORAL} from '../../type';\nimport {VgValueRef} from '../../vega.schema';\n\n\nimport {UnitModel} from '../unit';\n\nexport namespace text {\n  export function markType() {\n    return 'text';\n  }\n\n  export function background(model: UnitModel) {\n    return {\n      x: { value: 0 },\n      y: { value: 0 },\n      width: { field: { group: 'width' } },\n      height: { field: { group: 'height' } },\n      fill: {\n        scale: model.scaleName(COLOR),\n        field: model.field(COLOR, model.encoding().color.type === ORDINAL ? {prefix: 'rank'} : {})\n      }\n    };\n  }\n\n  export function properties(model: UnitModel) {\n    // TODO Use Vega's marks properties interface\n    let p: any = {};\n\n    applyMarkConfig(p, model,\n      ['angle', 'align', 'baseline', 'dx', 'dy', 'font', 'fontWeight',\n        'fontStyle', 'radius', 'theta', 'text']);\n\n    const config = model.config();\n    const textFieldDef = model.encoding().text;\n\n    p.x = x(model.encoding().x, model.scaleName(X), config, textFieldDef);\n\n    p.y = y(model.encoding().y, model.scaleName(Y), config);\n\n    p.fontSize = size(model.encoding().size, model.scaleName(SIZE), config);\n\n    p.text = text(textFieldDef, model.scaleName(TEXT), config);\n\n    if (model.config().mark.applyColorToBackground && !model.has(X) && !model.has(Y)) {\n      p.fill = {value: 'black'}; // TODO: add rules for swapping between black and white\n      // opacity\n      const opacity = model.config().mark.opacity;\n      if (opacity) { p.opacity = { value: opacity }; };\n    } else {\n      applyColorAndOpacity(p, model);\n    }\n\n    return p;\n  }\n\n  function x(xFieldDef: FieldDef, scaleName: string, config: Config, textFieldDef:FieldDef): VgValueRef {\n    // x\n    if (xFieldDef) {\n      if (xFieldDef.field) {\n        return {\n          scale: scaleName,\n          field: field(xFieldDef, { binSuffix: 'mid' })\n        };\n      }\n    }\n    // TODO: support x.value, x.datum\n    if (textFieldDef && textFieldDef.type === QUANTITATIVE) {\n      return { field: { group: 'width' }, offset: -5 };\n    } else {\n      // TODO: allow this to fit\n      return { value: config.scale.textBandWidth / 2 };\n    }\n  }\n\n  function y(yFieldDef: FieldDef, scaleName: string, config: Config): VgValueRef {\n    // y\n    if (yFieldDef) {\n      if (yFieldDef.field) {\n        return {\n          scale: scaleName,\n          field: field(yFieldDef, { binSuffix: 'mid' })\n        };\n      }\n    }\n    // TODO: allow this to fit\n    // TODO consider if this should support group: height case too.\n    return { value: config.scale.bandSize / 2 };\n  }\n\n  function size(sizeFieldDef: FieldDef, scaleName: string, config: Config): VgValueRef {\n    // size\n    if (sizeFieldDef) {\n      if (sizeFieldDef.field) {\n        return {\n          scale: scaleName,\n          field: field(sizeFieldDef)\n        };\n      }\n      if (sizeFieldDef.value) {\n        return {value: sizeFieldDef.value};\n      }\n    }\n    return { value: config.mark.fontSize };\n  }\n\n  function text(textFieldDef: FieldDef, scaleName: string, config: Config): VgValueRef {\n    // text\n    if (textFieldDef) {\n      if (textFieldDef.field) {\n        if (QUANTITATIVE === textFieldDef.type) {\n          const format = numberFormat(textFieldDef, config.mark.format, config);\n\n          const filter = 'number' + ( format ? ':\\'' + format + '\\'' : '');\n          return {\n            template: '{{' + field(textFieldDef, { datum: true }) + ' | ' + filter + '}}'\n          };\n        } else if (TEMPORAL === textFieldDef.type) {\n          return {\n            template: timeTemplate(field(textFieldDef, {datum: true}), textFieldDef.timeUnit, config.mark.format, config.mark.shortTimeLabels, config)\n          };\n        } else {\n          return { field: textFieldDef.field };\n        }\n      } else if (textFieldDef.value) {\n        return { value: textFieldDef.value };\n      }\n    }\n    return {value: config.mark.text};\n  }\n}\n",
    "import {X, Y, SIZE} from '../../channel';\nimport {Orient} from '../../config';\nimport {FieldDef, field} from '../../fielddef';\nimport {Config} from '../../config';\nimport {VgValueRef} from '../../vega.schema';\n\nimport {UnitModel} from '../unit';\nimport {applyColorAndOpacity} from '../common';\n\nexport namespace tick {\n  export function markType() {\n    return 'rect';\n  }\n\n  export function properties(model: UnitModel) {\n    let p: any = {};\n    const config = model.config();\n\n    // TODO: support explicit value\n\n    p.xc = x(model.encoding().x, model.scaleName(X), config);\n\n    p.yc = y(model.encoding().y, model.scaleName(Y), config);\n\n    if (config.mark.orient === Orient.HORIZONTAL) {\n      p.width = size(model.encoding().size, model.scaleName(SIZE), config, (model.scale(X) || {}).bandSize);\n      p.height = { value: config.mark.tickThickness };\n    } else {\n      p.width = { value: config.mark.tickThickness };\n      p.height = size(model.encoding().size, model.scaleName(SIZE), config, (model.scale(Y) || {}).bandSize);\n    }\n\n    applyColorAndOpacity(p, model);\n    return p;\n  }\n\n  function x(fieldDef: FieldDef, scaleName: string, config: Config): VgValueRef {\n    // x\n    if (fieldDef) {\n      if (fieldDef.field) {\n        return {\n          scale: scaleName,\n          field: field(fieldDef, { binSuffix: 'mid' })\n        };\n      } else if (fieldDef.value) {\n        return {value: fieldDef.value};\n      }\n    }\n    return { value: config.scale.bandSize / 2 };\n  }\n\n  function y(fieldDef: FieldDef, scaleName: string, config: Config): VgValueRef {\n    // y\n    if (fieldDef) {\n      if (fieldDef.field) {\n        return {\n          scale: scaleName,\n          field: field(fieldDef, { binSuffix: 'mid' })\n        };\n      } else if (fieldDef.value) {\n        return {value: fieldDef.value};\n      }\n    }\n    return { value: config.scale.bandSize / 2 };\n  }\n\n  function size(fieldDef: FieldDef, scaleName: string, config: Config, scaleBandSize: number): VgValueRef {\n    if (fieldDef) {\n      if (fieldDef.field) {\n        return {\n          scale: scaleName,\n          field: fieldDef.field\n        };\n      } else if (fieldDef.value !== undefined) {\n        return { value: fieldDef.value };\n      }\n    }\n    if (config.mark.tickSize) {\n      return { value: config.mark.tickSize };\n    }\n    const bandSize = scaleBandSize !== undefined ?\n      scaleBandSize :\n      config.scale.bandSize;\n    return { value: bandSize / 1.5 };\n  }\n}\n",
    "import {Axis} from '../axis';\nimport {Channel, X, COLUMN} from '../channel';\nimport {Config, CellConfig} from '../config';\nimport {Data, DataTable} from '../data';\nimport {channelMappingReduce, channelMappingForEach} from '../encoding';\nimport {FieldDef, FieldRefOption, field} from '../fielddef';\nimport {Legend} from '../legend';\nimport {Scale, ScaleType} from '../scale';\nimport {SortField, SortOrder} from '../sort';\nimport {BaseSpec} from '../spec';\nimport {Transform} from '../transform';\nimport {extend, flatten, vals, warning, Dict} from '../util';\nimport {VgData, VgMarkGroup, VgScale, VgAxis, VgLegend} from '../vega.schema';\n\nimport {DataComponent} from './data/data';\nimport {LayoutComponent} from './layout';\nimport {ScaleComponents} from './scale';\n\n/**\n * Composable Components that are intermediate results of the parsing phase of the\n * compilations.  These composable components will be assembled in the last\n * compilation step.\n */\nexport interface Component {\n  data: DataComponent;\n  layout: LayoutComponent;\n  scale: Dict<ScaleComponents>;\n\n  /** Dictionary mapping channel to VgAxis definition */\n  // TODO: if we allow multiple axes (e.g., dual axis), this will become VgAxis[]\n  axis: Dict<VgAxis>;\n\n  /** Dictionary mapping channel to VgLegend definition */\n  legend: Dict<VgLegend>;\n\n  /** Dictionary mapping channel to axis mark group for facet and concat */\n  axisGroup: Dict<VgMarkGroup>;\n\n  /** Dictionary mapping channel to grid mark group for facet (and concat?) */\n  gridGroup: Dict<VgMarkGroup[]>;\n\n  mark: VgMarkGroup[];\n}\n\nclass NameMap {\n  private _nameMap: Dict<string>;\n\n  constructor() {\n    this._nameMap = {} as Dict<string>;\n  }\n\n  public rename(oldName: string, newName: string) {\n    this._nameMap[oldName] = newName;\n  }\n\n  public get(name: string): string {\n    // If the name appears in the _nameMap, we need to read its new name.\n    // We have to loop over the dict just in case, the new name also gets renamed.\n    while (this._nameMap[name]) {\n      name = this._nameMap[name];\n    }\n\n    return name;\n  }\n}\n\nexport abstract class Model {\n  protected _parent: Model;\n  protected _name: string;\n  protected _description: string;\n\n  protected _data: Data;\n\n  /** Name map for data sources, which can be renamed by a model's parent. */\n  protected _dataNameMap: NameMap;\n\n  /** Name map for scales, which can be renamed by a model's parent. */\n  protected _scaleNameMap: NameMap;\n\n  /** Name map for size, which can be renamed by a model's parent. */\n  protected _sizeNameMap: NameMap;\n\n  protected _transform: Transform;\n  protected _scale: Dict<Scale>;\n\n  protected _axis: Dict<Axis>;\n\n  protected _legend: Dict<Legend>;\n\n  protected _config: Config;\n\n  protected _warnings: string[] = [];\n\n  public component: Component;\n\n  constructor(spec: BaseSpec, parent: Model, parentGivenName: string) {\n    this._parent = parent;\n\n    // If name is not provided, always use parent's givenName to avoid name conflicts.\n    this._name = spec.name || parentGivenName;\n\n    // Shared name maps\n    this._dataNameMap = parent ? parent._dataNameMap : new NameMap();\n    this._scaleNameMap = parent ? parent._scaleNameMap : new NameMap();\n    this._sizeNameMap = parent ? parent._sizeNameMap : new NameMap();\n\n    this._data = spec.data;\n\n    this._description = spec.description;\n    this._transform = spec.transform;\n\n    this.component = {data: null, layout: null, mark: null, scale: null, axis: null, axisGroup: null, gridGroup: null, legend: null};\n  }\n\n\n  public parse() {\n    this.parseData();\n    this.parseSelectionData();\n    this.parseLayoutData();\n    this.parseScale(); // depends on data name\n    this.parseAxis(); // depends on scale name\n    this.parseLegend(); // depends on scale name\n    this.parseAxisGroup(); // depends on child axis\n    this.parseGridGroup();\n    this.parseMark(); // depends on data name and scale name, axisGroup, gridGroup and children's scale, axis, legend and mark.\n  }\n\n  public abstract parseData();\n\n  public abstract parseSelectionData();\n\n  public abstract parseLayoutData();\n\n  public abstract parseScale();\n\n  public abstract parseMark();\n\n  public abstract parseAxis();\n\n  public abstract parseLegend();\n\n  // TODO: revise if these two methods make sense for shared scale concat\n  public abstract parseAxisGroup();\n  public abstract parseGridGroup();\n\n\n  public abstract assembleData(data: VgData[]): VgData[];\n\n  public abstract assembleLayout(layoutData: VgData[]): VgData[];\n\n  // TODO: for Arvind to write\n  // public abstract assembleSelectionSignal(layoutData: VgData[]): VgData[];\n  // public abstract assembleSelectionData(layoutData: VgData[]): VgData[];\n\n  public assembleScales(): VgScale[] {\n    // FIXME: write assembleScales() in scale.ts that\n    // help assemble scale domains with scale signature as well\n    return flatten(vals(this.component.scale).map((scales: ScaleComponents) => {\n      let arr = [scales.main];\n      if (scales.colorLegend) {\n        arr.push(scales.colorLegend);\n      }\n      if (scales.binColorLegend) {\n        arr.push(scales.binColorLegend);\n      }\n      return arr;\n    }));\n  }\n\n  public abstract assembleMarks(): any[]; // TODO: VgMarkGroup[]\n\n  public assembleAxes(): VgAxis[] {\n    return vals(this.component.axis);\n  }\n\n  public assembleLegends(): any[] { // TODO: VgLegend[]\n    return vals(this.component.legend);\n  }\n\n  public assembleGroup() {\n    let group: VgMarkGroup = {};\n\n    // TODO: consider if we want scales to come before marks in the output spec.\n\n    group.marks = this.assembleMarks();\n    const scales = this.assembleScales();\n    if (scales.length > 0) {\n      group.scales = scales;\n    }\n\n    const axes = this.assembleAxes();\n    if (axes.length > 0) {\n      group.axes = axes;\n    }\n\n    const legends = this.assembleLegends();\n    if (legends.length > 0) {\n      group.legends = legends;\n    }\n\n    return group;\n  }\n\n  public abstract assembleParentGroupProperties(cellConfig: CellConfig);\n\n  public abstract channels(): Channel[];\n\n  protected abstract mapping();\n\n  public reduce(f: (acc: any, fd: FieldDef, c: Channel) => any, init, t?: any) {\n    return channelMappingReduce(this.channels(), this.mapping(), f, init, t);\n  }\n\n  public forEach(f: (fd: FieldDef, c: Channel, i:number) => void, t?: any) {\n    channelMappingForEach(this.channels(), this.mapping(), f, t);\n  }\n\n  public abstract has(channel: Channel): boolean;\n\n  public parent(): Model {\n    return this._parent;\n  }\n\n  public name(text: string, delimiter: string = '_') {\n    return (this._name ? this._name + delimiter : '') + text;\n  }\n\n  public description() {\n    return this._description;\n  }\n\n  public data() {\n    return this._data;\n  }\n\n  public renameData(oldName: string, newName: string) {\n     this._dataNameMap.rename(oldName, newName);\n  }\n\n  /**\n   * Return the data source name for the given data source type.\n   *\n   * For unit spec, this is always simply the spec.name + '-' + dataSourceType.\n   * We already use the name map so that marks and scales use the correct data.\n   */\n  public dataName(dataSourceType: DataTable): string {\n    return this._dataNameMap.get(this.name(String(dataSourceType)));\n  }\n\n  public renameSize(oldName: string, newName: string) {\n    this._sizeNameMap.rename(oldName, newName);\n  }\n\n  public channelSizeName(channel: Channel): string {\n    return this.sizeName(channel === X || channel === COLUMN ? 'width' : 'height');\n  }\n\n  public sizeName(size: string): string {\n     return this._sizeNameMap.get(this.name(size, '_'));\n  }\n\n  public abstract dataTable(): string;\n\n  public transform(): Transform {\n    return this._transform || {};\n  }\n\n  /** Get \"field\" reference for vega */\n  public field(channel: Channel, opt: FieldRefOption = {}) {\n    const fieldDef = this.fieldDef(channel);\n\n    if (fieldDef.bin) { // bin has default suffix that depends on scaleType\n      opt = extend({\n        binSuffix: this.scale(channel).type === ScaleType.ORDINAL ? 'range' : 'start'\n      }, opt);\n    }\n\n    return field(fieldDef, opt);\n  }\n\n  public abstract fieldDef(channel: Channel): FieldDef;\n\n  public scale(channel: Channel): Scale {\n    return this._scale[channel];\n  }\n\n  // TODO: rename to hasOrdinalScale\n  public isOrdinalScale(channel: Channel) {\n    const scale = this.scale(channel);\n    return scale && scale.type === ScaleType.ORDINAL;\n  }\n\n  public renameScale(oldName: string, newName: string) {\n    this._scaleNameMap.rename(oldName, newName);\n  }\n\n  /** returns scale name for a given channel */\n  public scaleName(channel: Channel|string): string {\n    return this._scaleNameMap.get(this.name(channel + ''));\n  }\n\n  public sort(channel: Channel): SortField | SortOrder {\n    return (this.mapping()[channel] || {}).sort;\n  }\n\n  public abstract stack();\n\n  public axis(channel: Channel): Axis {\n    return this._axis[channel];\n  }\n\n  public legend(channel: Channel): Legend {\n    return this._legend[channel];\n  }\n\n  /**\n   * Get the spec configuration.\n   */\n  public config(): Config {\n    return this._config;\n  }\n\n  public addWarning(message: string) {\n    warning(message);\n    this._warnings.push(message);\n  }\n\n  public warnings(): string[] {\n    return this._warnings;\n  }\n\n  /**\n   * Type checks\n   */\n  public isUnit() {\n    return false;\n  }\n  public isFacet() {\n    return false;\n  }\n  public isLayer() {\n    return false;\n  }\n}\n",
    "// https://github.com/Microsoft/TypeScript/blob/master/doc/spec.md#11-ambient-declarations\ndeclare var exports;\n\nimport {SHARED_DOMAIN_OPS} from '../aggregate';\nimport {COLUMN, ROW, X, Y, X2, Y2, SHAPE, SIZE, COLOR, OPACITY, TEXT, hasScale, Channel} from '../channel';\nimport {Orient} from '../config';\nimport {SOURCE, STACKED_SCALE} from '../data';\nimport {FieldDef, field, isMeasure} from '../fielddef';\nimport {Mark, BAR, TEXT as TEXTMARK, RULE, TICK} from '../mark';\nimport {Scale, ScaleConfig, ScaleType, NiceTime, BANDSIZE_FIT, BandSize} from '../scale';\nimport {isSortField, SortOrder} from '../sort';\nimport {StackOffset} from '../stack';\nimport {NOMINAL, ORDINAL, QUANTITATIVE, TEMPORAL} from '../type';\nimport {contains, extend, Dict} from '../util';\nimport {VgScale} from '../vega.schema';\n\nimport {Model} from './model';\nimport {defaultScaleType, rawDomain, smallestUnit} from '../timeunit';\nimport {UnitModel} from './unit';\n\n/**\n * Color Ramp's scale for legends.  This scale has to be ordinal so that its\n * legends show a list of numbers.\n */\nexport const COLOR_LEGEND = 'color_legend';\n\n// scale used to get labels for binned color scales\nexport const COLOR_LEGEND_LABEL = 'color_legend_label';\n\n\n// FIXME: With layer and concat, scaleComponent should decompose between\n// ScaleSignature and ScaleDomain[].\n// Basically, if two unit specs has the same scale, signature for a particular channel,\n// the scale can be unioned by combining the domain.\nexport type ScaleComponent = VgScale;\n\nexport type ScaleComponents = {\n  main: ScaleComponent;\n  colorLegend?: ScaleComponent,\n  binColorLegend?: ScaleComponent\n}\n\nexport function parseScaleComponent(model: Model): Dict<ScaleComponents> {\n  // TODO: should model.channels() inlcude X2/Y2?\n  return model.channels().reduce(function(scale: Dict<ScaleComponents>, channel: Channel) {\n      if (model.scale(channel)) {\n        const fieldDef = model.fieldDef(channel);\n        const scales: ScaleComponents = {\n          main: parseMainScale(model, fieldDef, channel)\n        };\n\n        // Add additional scales needed to support ordinal legends (list of values)\n        // for color ramp.\n        if (channel === COLOR && model.legend(COLOR) && (fieldDef.type === ORDINAL || fieldDef.bin || fieldDef.timeUnit)) {\n          scales.colorLegend = parseColorLegendScale(model, fieldDef);\n          if (fieldDef.bin) {\n            scales.binColorLegend = parseBinColorLegendLabel(model, fieldDef);\n          }\n        }\n\n        scale[channel] = scales;\n      }\n      return scale;\n    }, {} as Dict<ScaleComponents>);\n}\n\n/**\n * Return the main scale for each channel.  (Only color can have multiple scales.)\n */\nfunction parseMainScale(model: Model, fieldDef: FieldDef, channel: Channel) {\n  const scale = model.scale(channel);\n  const sort = model.sort(channel);\n  let scaleDef: any = {\n    name: model.scaleName(channel),\n    type: scale.type,\n  };\n\n  // If channel is either X or Y then union them with X2 & Y2 if they exist\n  if (channel === X && model.has(X2)) {\n    if (model.has(X)) {\n      scaleDef.domain = { fields: [domain(scale, model, X), domain(scale, model, X2)] };\n    } else {\n      scaleDef.domain = domain(scale, model, X2);\n    }\n  } else if (channel === Y && model.has(Y2)) {\n    if (model.has(Y)) {\n      scaleDef.domain = { fields: [domain(scale, model, Y), domain(scale, model, Y2)] };\n    } else {\n      scaleDef.domain = domain(scale, model, Y2);\n    }\n  } else {\n    scaleDef.domain = domain(scale, model, channel);\n  }\n\n  extend(scaleDef, rangeMixins(scale, model, channel));\n  if (sort && (isSortField(sort) ? sort.order : sort) === SortOrder.DESCENDING) {\n    scaleDef.reverse = true;\n  }\n\n  // Add optional properties\n  [\n    // general properties\n    'round',\n    // quantitative / time\n    'clamp', 'nice',\n    // quantitative\n    'exponent', 'zero',\n    // ordinal\n    'points',\n    'padding' // padding depends on points\n  ].forEach(function(property) {\n    const value = exports[property](scale, channel, fieldDef, model, scaleDef);\n    if (value !== undefined) {\n      scaleDef[property] = value;\n    }\n  });\n\n  return scaleDef;\n}\n\n/**\n *  Return a scale  for producing ordinal scale for legends.\n *  - For an ordinal field, provide an ordinal scale that maps rank values to field value\n *  - For a field with bin or timeUnit, provide an identity ordinal scale\n *    (mapping the field values to themselves)\n */\nfunction parseColorLegendScale(model: Model, fieldDef: FieldDef): ScaleComponent {\n  return {\n    name: model.scaleName(COLOR_LEGEND),\n    type: ScaleType.ORDINAL,\n    domain: {\n      data: model.dataTable(),\n      // use rank_<field> for ordinal type, for bin and timeUnit use default field\n      field: model.field(COLOR, (fieldDef.bin || fieldDef.timeUnit) ? {} : {prefix: 'rank'}),\n      sort: true\n    },\n    range: {data: model.dataTable(), field: model.field(COLOR), sort: true}\n  };\n}\n\n/**\n *  Return an additional scale for bin labels because we need to map bin_start to bin_range in legends\n */\nfunction parseBinColorLegendLabel(model: Model, fieldDef: FieldDef): ScaleComponent {\n  return {\n    name: model.scaleName(COLOR_LEGEND_LABEL),\n    type: ScaleType.ORDINAL,\n    domain: {\n      data: model.dataTable(),\n      field: model.field(COLOR),\n      sort: true\n    },\n    range: {\n      data: model.dataTable(),\n      field: field(fieldDef, {binSuffix: 'range'}),\n      sort: {\n        field: model.field(COLOR, { binSuffix: 'start' }),\n        op: 'min' // min or max doesn't matter since same _range would have the same _start\n      }\n    }\n  };\n}\n\nexport function scaleType(scale: Scale, fieldDef: FieldDef, channel: Channel, mark: Mark): ScaleType {\n  if (!hasScale(channel)) {\n    // There is no scale for these channels\n    return null;\n  }\n\n  // We can't use linear/time for row, column or shape\n  if (contains([ROW, COLUMN, SHAPE], channel)) {\n    if (scale && scale.type !== undefined && scale.type !== ScaleType.ORDINAL) {\n      // TODO: consolidate warning\n      console.warn('Channel', channel, 'does not work with scale type =', scale.type);\n    }\n    return ScaleType.ORDINAL;\n  }\n\n  if (scale.type !== undefined) {\n    return scale.type;\n  }\n\n  switch (fieldDef.type) {\n    case NOMINAL:\n      return ScaleType.ORDINAL;\n    case ORDINAL:\n      if (channel === COLOR) {\n        return ScaleType.LINEAR; // time has order, so use interpolated ordinal color scale.\n      }\n      return ScaleType.ORDINAL;\n    case TEMPORAL:\n      if (channel === COLOR) {\n        return ScaleType.TIME; // time has order, so use interpolated ordinal color scale.\n      }\n\n      if (fieldDef.timeUnit) {\n        return defaultScaleType(fieldDef.timeUnit);\n      }\n      return ScaleType.TIME;\n\n    case QUANTITATIVE:\n      if (fieldDef.bin) {\n        return contains([X, Y, COLOR], channel) ? ScaleType.LINEAR : ScaleType.ORDINAL;\n      }\n      return ScaleType.LINEAR;\n  }\n\n  // should never reach this\n  return null;\n}\n\nexport function scaleBandSize(scaleType: ScaleType, bandSize: number | BandSize, scaleConfig: ScaleConfig, topLevelSize: number, mark: Mark, channel: Channel): number | BandSize {\n  if (scaleType === ScaleType.ORDINAL) {\n    if (topLevelSize === undefined) {\n\n      if (bandSize) {\n        // Use manually specified bandSize\n        return bandSize;\n      } else if (channel === X && mark === TEXTMARK) {\n        return scaleConfig.textBandWidth;\n      } else {\n        return scaleConfig.bandSize;\n      }\n    } else {\n      // If top-level is specified, use bandSize fit\n      if (bandSize) {\n        // If top-level size is specified, we override specified bandSize with \"fit\"\n        console.warn('bandSize for', channel, 'overridden as top-level',\n          channel === X ? 'width' : 'height', 'is provided.');\n      }\n      return BANDSIZE_FIT;\n    }\n  } else {\n    // bandSize is not applicable for non-ordinal scale.\n    return undefined;\n\n  }\n}\n\nexport function domain(scale: Scale, model: Model, channel:Channel): any {\n  const fieldDef = model.fieldDef(channel);\n\n  if (scale.domain) { // explicit value\n    return scale.domain;\n  }\n\n  // special case for temporal scale\n  if (fieldDef.type === TEMPORAL) {\n    if (rawDomain(fieldDef.timeUnit, channel)) {\n      return {\n        data: fieldDef.timeUnit,\n        field: 'date'\n      };\n    }\n\n    return {\n      data: model.dataTable(),\n      field: model.field(channel),\n      sort: {\n        field: model.field(channel),\n        op: 'min'\n      }\n    };\n  }\n\n  // For stack, use STACKED data.\n  const stack = model.stack();\n  if (stack && channel === stack.fieldChannel) {\n    if(stack.offset === StackOffset.NORMALIZE) {\n      return [0, 1];\n    }\n    return {\n      data: model.dataName(STACKED_SCALE),\n      // STACKED_SCALE produces sum of the field's value e.g., sum of sum, sum of distinct\n      field: model.field(channel, {prefix: 'sum'})\n    };\n  }\n\n  const useRawDomain = _useRawDomain(scale, model, channel),\n  sort = domainSort(model, channel, scale.type);\n\n  if (useRawDomain) { // useRawDomain - only Q/T\n    return {\n      data: SOURCE,\n      field: model.field(channel, {noAggregate: true})\n    };\n  } else if (fieldDef.bin) { // bin\n    if (scale.type === ScaleType.ORDINAL) {\n      // ordinal bin scale takes domain from bin_range, ordered by bin_start\n      return {\n        data: model.dataTable(),\n        field: model.field(channel, { binSuffix: 'range' }),\n        sort: {\n          field: model.field(channel, { binSuffix: 'start' }),\n          op: 'min' // min or max doesn't matter since same _range would have the same _start\n        }\n      };\n    } else if (channel === COLOR) {\n      // Currently, binned on color uses linear scale and thus use _start point\n      return {\n        data: model.dataTable(),\n        field: model.field(channel, { binSuffix: 'start' })\n      };\n    } else {\n      // other linear bin scale merges both bin_start and bin_end for non-ordinal scale\n      return {\n        data: model.dataTable(),\n        field: [\n          model.field(channel, { binSuffix: 'start' }),\n          model.field(channel, { binSuffix: 'end' })\n        ]\n      };\n    }\n  } else if (sort) { // have sort -- only for ordinal\n    return {\n      // If sort by aggregation of a specified sort field, we need to use SOURCE table,\n      // so we can aggregate values for the scale independently from the main aggregation.\n      data: sort.op ? SOURCE : model.dataTable(),\n      field: (fieldDef.type === ORDINAL && channel === COLOR) ? model.field(channel, {prefix: 'rank'}) : model.field(channel),\n      sort: sort\n    };\n  } else {\n    return {\n      data: model.dataTable(),\n      field: (fieldDef.type === ORDINAL && channel === COLOR) ? model.field(channel, {prefix: 'rank'}) : model.field(channel),\n    };\n  }\n}\n\nexport function domainSort(model: Model, channel: Channel, scaleType: ScaleType): any {\n  if (scaleType !== ScaleType.ORDINAL) {\n    return undefined;\n  }\n\n  const sort = model.sort(channel);\n\n  // Sorted based on an aggregate calculation over a specified sort field (only for ordinal scale)\n  if (isSortField(sort)) {\n    return {\n      op: sort.op,\n      field: sort.field\n    };\n  }\n\n  if (contains([SortOrder.ASCENDING, SortOrder.DESCENDING, undefined /* default =ascending*/], sort)) {\n    return true;\n  }\n\n  // sort === 'none'\n  return undefined;\n}\n\n\n/**\n * Determine if useRawDomain should be activated for this scale.\n * @return {Boolean} Returns true if all of the following conditons applies:\n * 1. `useRawDomain` is enabled either through scale or config\n * 2. Aggregation function is not `count` or `sum`\n * 3. The scale is quantitative or time scale.\n */\nfunction _useRawDomain (scale: Scale, model: Model, channel: Channel) {\n  const fieldDef = model.fieldDef(channel);\n\n  return scale.useRawDomain && //  if useRawDomain is enabled\n    // only applied to aggregate table\n    fieldDef.aggregate &&\n    // only activated if used with aggregate functions that produces values ranging in the domain of the source data\n    SHARED_DOMAIN_OPS.indexOf(fieldDef.aggregate) >= 0 &&\n    (\n      // Q always uses quantitative scale except when it's binned.\n      // Binned field has similar values in both the source table and the summary table\n      // but the summary table has fewer values, therefore binned fields draw\n      // domain values from the summary table.\n      (fieldDef.type === QUANTITATIVE && !fieldDef.bin) ||\n      // T uses non-ordinal scale when there's no unit or when the unit is not ordinal.\n      (fieldDef.type === TEMPORAL && contains([ScaleType.TIME, ScaleType.UTC], scale.type))\n    );\n}\n\n\nexport function rangeMixins(scale: Scale, model: Model, channel: Channel): any {\n  // TODO: need to add rule for quantile, quantize, threshold scale\n\n  const fieldDef = model.fieldDef(channel);\n  const scaleConfig = model.config().scale;\n\n  if (scale.type === ScaleType.ORDINAL && scale.bandSize && scale.bandSize !== BANDSIZE_FIT && contains([X, Y], channel)) {\n    return {bandSize: scale.bandSize};\n  }\n\n  if (scale.range && !contains([X, Y, ROW, COLUMN], channel)) {\n    // explicit value (Do not allow explicit values for X, Y, ROW, COLUMN)\n    return {range: scale.range};\n  }\n  switch (channel) {\n    case ROW:\n      return {range: 'height'};\n    case COLUMN:\n      return {range: 'width'};\n  }\n\n  // If not ROW / COLUMN, we can assume that this is a unit spec.\n  const unitModel = model as UnitModel;\n  switch (channel) {\n    case X:\n      // we can't use {range: \"width\"} here since we put scale in the root group\n      // not inside the cell, so scale is reusable for axes group\n\n      return {\n        rangeMin: 0,\n        // TODO: replace\n        rangeMax: unitModel.width // Fixed cell width for non-ordinal\n      };\n    case Y:\n      return {\n        // TODO: replace\n        rangeMin: unitModel.height, // Fixed cell height for non-ordinal\n        rangeMax: 0\n      };\n    case SIZE:\n\n      if (unitModel.mark() === BAR) {\n        if (scaleConfig.barSizeRange !== undefined) {\n          return {range: scaleConfig.barSizeRange};\n        }\n        const dimension = model.config().mark.orient === Orient.HORIZONTAL ? Y : X;\n        return {range: [model.config().mark.barThinSize, model.scale(dimension).bandSize]};\n      } else if (unitModel.mark() === TEXTMARK) {\n        return {range: scaleConfig.fontSizeRange };\n      } else if (unitModel.mark() === RULE) {\n        return {range: scaleConfig.ruleSizeRange };\n      } else if (unitModel.mark() === TICK) {\n        return {range: scaleConfig.tickSizeRange };\n      }\n      // else -- point, square, circle\n      if (scaleConfig.pointSizeRange !== undefined) {\n        return {range: scaleConfig.pointSizeRange};\n      }\n\n      const bandSize = pointBandSize(unitModel);\n\n      return {range: [9, (bandSize - 2) * (bandSize - 2)]};\n    case SHAPE:\n      return {range: scaleConfig.shapeRange};\n    case COLOR:\n      if (fieldDef.type === NOMINAL) {\n        return {range: scaleConfig.nominalColorRange};\n      }\n      // else -- ordinal, time, or quantitative\n      return {range: scaleConfig.sequentialColorRange};\n    case OPACITY:\n      return {range: scaleConfig.opacity};\n  }\n  return {};\n}\n\nfunction pointBandSize(model: UnitModel) {\n  const scaleConfig = model.config().scale;\n\n  const hasX = model.has(X);\n  const hasY = model.has(Y);\n\n  const xIsMeasure = isMeasure(model.encoding().x);\n  const yIsMeasure = isMeasure(model.encoding().y);\n\n  if (hasX && hasY) {\n    return xIsMeasure !== yIsMeasure ?\n      model.scale(xIsMeasure ? Y : X).bandSize :\n      Math.min(\n        model.scale(X).bandSize || scaleConfig.bandSize,\n        model.scale(Y).bandSize || scaleConfig.bandSize\n      );\n  } else if (hasY) {\n    return yIsMeasure ? model.config().scale.bandSize : model.scale(Y).bandSize;\n  } else if (hasX) {\n    return xIsMeasure ? model.config().scale.bandSize : model.scale(X).bandSize;\n  }\n  return model.config().scale.bandSize;\n}\n\nexport function clamp(scale: Scale) {\n  // Only works for scale with both continuous domain continuous range\n  // (Doesn't work for quantize, quantile, threshold, ordinal)\n  if (contains([ScaleType.LINEAR, ScaleType.POW, ScaleType.SQRT,\n        ScaleType.LOG, ScaleType.TIME, ScaleType.UTC], scale.type)) {\n    return scale.clamp;\n  }\n  return undefined;\n}\n\nexport function exponent(scale: Scale) {\n  if (scale.type === ScaleType.POW) {\n    return scale.exponent;\n  }\n  return undefined;\n}\n\nexport function nice(scale: Scale, channel: Channel, fieldDef: FieldDef): boolean | NiceTime {\n  if (contains([ScaleType.LINEAR, ScaleType.POW, ScaleType.SQRT, ScaleType.LOG,\n        ScaleType.TIME, ScaleType.UTC, ScaleType.QUANTIZE], scale.type)) {\n\n    if (scale.nice !== undefined) {\n      return scale.nice;\n    }\n    if (contains([ScaleType.TIME, ScaleType.UTC], scale.type)) {\n      return smallestUnit(fieldDef.timeUnit) as any;\n    }\n    return contains([X, Y], channel); // return true for quantitative X/Y\n  }\n  return undefined;\n}\n\n\nexport function padding(scale: Scale, channel: Channel, __, ___, scaleDef) {\n  /* Padding is only allowed for X and Y.\n   *\n   * Basically it doesn't make sense to add padding for color and size.\n   *\n   * We do not use d3 scale's padding for row/column because padding there\n   * is a ratio ([0, 1]) and it causes the padding to be decimals.\n   * Therefore, we manually calculate padding in the layout by ourselves.\n   */\n  if (scale.type === ScaleType.ORDINAL && contains([X, Y], channel)) {\n    // TODO: design config for this\n    return scaleDef.points ? 1 : scale.padding;\n  }\n  return undefined;\n}\n\nexport function points(scale: Scale, channel: Channel, __, model: Model) {\n  if (scale.type === ScaleType.ORDINAL && contains([X, Y], channel)) {\n    // We always use ordinal point scale for x and y except when the mark is bar and the scale's bandWidth is 'fit'\n    // Thus `points` isn't included in the scale's schema.\n    return (model as UnitModel).mark() === BAR && scale.bandSize === BANDSIZE_FIT ? undefined : true;\n  }\n  return undefined;\n}\n\nexport function round(scale: Scale, channel: Channel) {\n  if (contains([X, Y, ROW, COLUMN, SIZE], channel) && scale.round !== undefined) {\n    return scale.round;\n  }\n\n  return undefined;\n}\n\nexport function zero(scale: Scale, channel: Channel, fieldDef: FieldDef) {\n  // only applicable for non-ordinal scale\n  if (!contains([ScaleType.TIME, ScaleType.UTC, ScaleType.ORDINAL], scale.type)) {\n    if (scale.zero !== undefined) {\n      return scale.zero;\n    }\n    // By default, return true only for non-binned, quantitative x-scale or y-scale\n    // If no custom domain is provided.\n    return !scale.domain && !fieldDef.bin && contains([X, Y], channel);\n  }\n  return undefined;\n}\n",
    "import {AggregateOp} from '../aggregate';\nimport {Axis} from '../axis';\nimport {X, Y, X2, Y2, TEXT, PATH, ORDER, Channel, UNIT_CHANNELS,  UNIT_SCALE_CHANNELS, NONSPATIAL_SCALE_CHANNELS, supportMark} from '../channel';\nimport {defaultConfig, Config, CellConfig} from '../config';\nimport {SOURCE, SUMMARY} from '../data';\nimport {Encoding} from '../encoding';\nimport * as vlEncoding from '../encoding'; // TODO: remove\nimport {FieldDef, FieldRefOption, field} from '../fielddef';\nimport {Legend} from '../legend';\nimport {Mark, TEXT as TEXTMARK} from '../mark';\nimport {BANDSIZE_FIT, Scale, ScaleConfig, ScaleType} from '../scale';\nimport {ExtendedUnitSpec} from '../spec';\nimport {getFullName, QUANTITATIVE} from '../type';\nimport {duplicate, extend, mergeDeep, Dict} from '../util';\nimport {VgData} from '../vega.schema';\n\nimport {parseAxisComponent} from './axis';\nimport {applyConfig, FILL_STROKE_CONFIG} from './common';\nimport {initMarkConfig} from './config';\nimport {assembleData, parseUnitData} from './data/data';\nimport {parseLegendComponent} from './legend';\nimport {assembleLayout, parseUnitLayout} from './layout';\nimport {Model} from './model';\nimport {parseMark} from './mark/mark';\nimport {parseScaleComponent, scaleBandSize, scaleType} from './scale';\nimport {stack, StackProperties} from '../stack';\n\n/**\n * Internal model of Vega-Lite specification for the compiler.\n */\nexport class UnitModel extends Model {\n  /**\n   * Fixed width for the unit visualization.\n   * If undefined (e.g., for ordinal scale), the width of the\n   * visualization will be calculated dynamically.\n   */\n  private _width: number;\n\n  /**\n   * Fixed height for the unit visualization.\n   * If undefined (e.g., for ordinal scale), the height of the\n   * visualization will be calculated dynamically.\n   */\n  private _height: number;\n\n  private _mark: Mark;\n  private _encoding: Encoding;\n  private _stack: StackProperties;\n\n  constructor(spec: ExtendedUnitSpec, parent: Model, parentGivenName: string) {\n    super(spec, parent, parentGivenName);\n\n    // use top-level width / height or parent's top-level width / height\n    const providedWidth = spec.width !== undefined ? spec.width :\n      parent ? parent['width'] : undefined; // only exists if parent is layer\n    const providedHeight = spec.height !== undefined ? spec.height :\n      parent ? parent['height'] : undefined; // only exists if parent is layer\n\n    const mark = this._mark = spec.mark;\n    const encoding = this._encoding = this._initEncoding(mark, spec.encoding || {});\n    const config = this._config = this._initConfig(spec.config, parent, mark, encoding);\n\n    this._scale =  this._initScale(mark, encoding, config, providedWidth, providedHeight);\n    this._axis = this._initAxis(encoding, config);\n    this._legend = this._initLegend(encoding, config);\n\n    // width / height\n    this._initSize(mark, this._scale,\n      providedWidth,\n      providedHeight,\n      config.cell, config.scale\n    );\n\n    // calculate stack properties\n    this._stack = stack(mark, encoding, config);\n  }\n\n  private _initEncoding(mark: Mark, encoding: Encoding) {\n    // clone to prevent side effect to the original spec\n    encoding = duplicate(encoding);\n\n    vlEncoding.forEach(encoding, function(fieldDef: FieldDef, channel: Channel) {\n      if (!supportMark(channel, mark)) {\n        // Drop unsupported channel\n\n        // FIXME consolidate warning method\n        console.warn(channel, 'dropped as it is incompatible with', mark);\n        delete fieldDef.field;\n        return;\n      }\n\n      if (fieldDef.type) {\n        // convert short type to full type\n        fieldDef.type = getFullName(fieldDef.type);\n      }\n\n      if ((channel === PATH || channel === ORDER) && !fieldDef.aggregate && fieldDef.type === QUANTITATIVE) {\n        fieldDef.aggregate = AggregateOp.MIN;\n      }\n    });\n    return encoding;\n  }\n\n  private _initConfig(specConfig: Config, parent: Model, mark: Mark, encoding: Encoding) {\n    let config = mergeDeep(duplicate(defaultConfig), parent ? parent.config() : {}, specConfig);\n    config.mark = initMarkConfig(mark, encoding, config);\n    return config;\n  }\n\n  private _initScale(mark: Mark, encoding: Encoding, config: Config, topLevelWidth:number, topLevelHeight: number): Dict<Scale> {\n    return UNIT_SCALE_CHANNELS.reduce(function(_scale, channel) {\n      if (vlEncoding.has(encoding, channel) ||\n          (channel === X && vlEncoding.has(encoding, X2)) ||\n          (channel === Y && vlEncoding.has(encoding, Y2))\n        ) {\n\n        const channelDef = encoding[channel];\n        const scaleSpec = (channelDef || {}).scale || {};\n        const _scaleType = scaleType(scaleSpec, channelDef, channel, mark);\n\n        var scale = _scale[channel] = extend({\n          type: _scaleType,\n          round: config.scale.round,\n          padding: config.scale.padding,\n          useRawDomain: config.scale.useRawDomain\n        }, scaleSpec);\n\n        // bandSize depends on top-level size (width/height) and scale type\n        // If top-level size is specified, we override specified bandSize with \"fit\".\n        scale.bandSize = scaleBandSize(scale.type, scale.bandSize, config.scale, channel === X ? topLevelWidth : topLevelHeight, mark, channel);\n      }\n      return _scale;\n    }, {} as Dict<Scale>);\n  }\n\n  private _initSize(mark: Mark, scale: Dict<Scale>, width: number, height: number, cellConfig: CellConfig, scaleConfig: ScaleConfig) {\n    if (width !== undefined) {\n      this._width = width;\n    } else if (scale[X]) {\n      if (scale[X].type !== ScaleType.ORDINAL || scale[X].bandSize === BANDSIZE_FIT) {\n        this._width = cellConfig.width;\n      } // else: Do nothing, use dynamic width.\n    } else { // No scale X\n      if (mark === TEXTMARK) {\n        // for text table without x/y scale we need wider bandSize\n        this._width = scaleConfig.textBandWidth;\n      } else {\n        this._width = scaleConfig.bandSize;\n      }\n    }\n\n    if (height !== undefined) {\n      this._height = height;\n    } else if (scale[Y]) {\n      if (scale[Y].type !== ScaleType.ORDINAL || scale[Y].bandSize === BANDSIZE_FIT) {\n        this._height = cellConfig.height;\n      } // else: Do nothing, use dynamic height .\n    } else {\n      this._height = scaleConfig.bandSize;\n    }\n  }\n\n  private _initAxis(encoding: Encoding, config: Config): Dict<Axis> {\n    return [X, Y].reduce(function(_axis, channel) {\n      // Position Axis\n      if (vlEncoding.has(encoding, channel) ||\n          (channel === X && vlEncoding.has(encoding, X2)) ||\n          (channel === Y && vlEncoding.has(encoding, Y2))) {\n\n        const axisSpec = (encoding[channel] || {}).axis;\n        if (axisSpec !== false) {\n          _axis[channel] = extend({},\n            config.axis,\n            axisSpec === true ? {} : axisSpec ||  {}\n          );\n        }\n      }\n      return _axis;\n    }, {} as Dict<Axis>);\n  }\n\n  private _initLegend(encoding: Encoding, config: Config): Dict<Legend> {\n    return NONSPATIAL_SCALE_CHANNELS.reduce(function(_legend, channel) {\n      if (vlEncoding.has(encoding, channel)) {\n        const legendSpec = encoding[channel].legend;\n        if (legendSpec !== false) {\n          _legend[channel] = extend({}, config.legend,\n            legendSpec === true ? {} : legendSpec ||  {}\n          );\n        }\n      }\n      return _legend;\n    }, {} as Dict<Legend>);\n  }\n\n  public get width(): number {\n    return this._width;\n  }\n\n  public get height(): number {\n    return this._height;\n  }\n\n  public parseData() {\n    this.component.data = parseUnitData(this);\n  }\n\n  public parseSelectionData() {\n    // TODO: @arvind can write this\n    // We might need to split this into compileSelectionData and compileSelectionSignals?\n  }\n\n  public parseLayoutData() {\n    this.component.layout = parseUnitLayout(this);\n  }\n\n  public parseScale() {\n    this.component.scale = parseScaleComponent(this);\n  }\n\n  public parseMark() {\n    this.component.mark = parseMark(this);\n  }\n\n  public parseAxis() {\n    this.component.axis = parseAxisComponent(this, [X, Y]);\n  }\n\n  public parseAxisGroup() {\n    return null;\n  }\n\n  public parseGridGroup() {\n    return null;\n  }\n\n  public parseLegend() {\n    this.component.legend = parseLegendComponent(this);\n  }\n\n  public assembleData(data: VgData[]): VgData[] {\n    return assembleData(this, data);\n  }\n\n  public assembleLayout(layoutData: VgData[]): VgData[] {\n    return assembleLayout(this, layoutData);\n  }\n\n  public assembleMarks() {\n    return this.component.mark;\n  }\n\n  public assembleParentGroupProperties(cellConfig: CellConfig) {\n    return applyConfig({}, cellConfig, FILL_STROKE_CONFIG.concat(['clip']));\n  }\n\n  public channels() {\n    return UNIT_CHANNELS;\n  }\n\n  protected mapping() {\n    return this.encoding();\n  }\n\n  public stack(): StackProperties {\n    return this._stack;\n  }\n\n  public toSpec(excludeConfig?, excludeData?) {\n    const encoding = duplicate(this._encoding);\n    let spec: any;\n\n    spec = {\n      mark: this._mark,\n      encoding: encoding\n    };\n\n    if (!excludeConfig) {\n      spec.config = duplicate(this._config);\n    }\n\n    if (!excludeData) {\n      spec.data = duplicate(this._data);\n    }\n\n    // remove defaults\n    return spec;\n  }\n\n  public mark(): Mark {\n    return this._mark;\n  }\n\n  public has(channel: Channel) {\n    return vlEncoding.has(this._encoding, channel);\n  }\n\n  public encoding() {\n    return this._encoding;\n  }\n\n  public fieldDef(channel: Channel): FieldDef {\n    // TODO: remove this || {}\n    // Currently we have it to prevent null pointer exception.\n    return this._encoding[channel] || {};\n  }\n\n  /** Get \"field\" reference for vega */\n  public field(channel: Channel, opt: FieldRefOption = {}) {\n    const fieldDef = this.fieldDef(channel);\n\n    if (fieldDef.bin) { // bin has default suffix that depends on scaleType\n      opt = extend({\n        binSuffix: this.scale(channel).type === ScaleType.ORDINAL ? 'range' : 'start'\n      }, opt);\n    }\n\n    return field(fieldDef, opt);\n  }\n\n  public dataTable() {\n    return this.dataName(vlEncoding.isAggregate(this._encoding) ? SUMMARY : SOURCE);\n  }\n\n  public isUnit() {\n    return true;\n  }\n}\n",
    "import {ScaleConfig, FacetScaleConfig, defaultScaleConfig, defaultFacetScaleConfig} from './scale';\nimport {AxisConfig, defaultAxisConfig, defaultFacetAxisConfig} from './axis';\nimport {LegendConfig, defaultLegendConfig} from './legend';\nimport {StackOffset} from './stack';\n\nexport interface CellConfig {\n  width?: number;\n  height?: number;\n\n  clip?: boolean;\n\n  // FILL_STROKE_CONFIG\n  /**\n   * The fill color.\n   * @format color\n   */\n  fill?: string;\n\n  /** The fill opacity (value between [0,1]). */\n  fillOpacity?: number;\n\n  /** The stroke color. */\n  stroke?: string;\n\n  /** The stroke opacity (value between [0,1]). */\n  strokeOpacity?: number;\n\n  /** The stroke width, in pixels. */\n  strokeWidth?: number;\n\n  /** An array of alternating stroke, space lengths for creating dashed or dotted lines. */\n  strokeDash?: number[];\n\n  /** The offset (in pixels) into which to begin drawing with the stroke dash array. */\n  strokeDashOffset?: number;\n}\n\nexport const defaultCellConfig: CellConfig = {\n  width: 200,\n  height: 200\n};\n\nexport const defaultFacetCellConfig: CellConfig = {\n  stroke: '#ccc',\n  strokeWidth: 1\n};\n\nexport interface FacetConfig {\n  /** Facet Scale Config */\n  scale?: FacetScaleConfig;\n\n  /** Facet Axis Config */\n  axis?: AxisConfig;\n\n  /** Facet Grid Config */\n  grid?: FacetGridConfig;\n\n  /** Facet Cell Config */\n  cell?: CellConfig;\n}\n\nexport interface FacetGridConfig {\n  /** @format color */\n  color?: string;\n  opacity?: number;\n  offset?: number;\n}\n\nconst defaultFacetGridConfig: FacetGridConfig = {\n  color: '#000000',\n  opacity: 0.4,\n  offset: 0\n};\n\nexport const defaultFacetConfig: FacetConfig = {\n  scale: defaultFacetScaleConfig,\n  axis: defaultFacetAxisConfig,\n  grid: defaultFacetGridConfig,\n  cell: defaultFacetCellConfig\n};\n\nexport enum FontWeight {\n    NORMAL = 'normal' as any,\n    BOLD = 'bold' as any\n}\n\nexport enum Shape {\n    CIRCLE = 'circle' as any,\n    SQUARE = 'square' as any,\n    CROSS = 'cross' as any,\n    DIAMOND = 'diamond' as any,\n    TRIANGLEUP = 'triangle-up' as any,\n    TRIANGLEDOWN = 'triangle-down' as any,\n}\n\nexport enum Orient {\n  HORIZONTAL = 'horizontal' as any,\n  VERTICAL = 'vertical' as any\n}\n\nexport enum HorizontalAlign {\n    LEFT = 'left' as any,\n    RIGHT = 'right' as any,\n    CENTER = 'center' as any,\n}\n\nexport enum VerticalAlign {\n    TOP = 'top' as any,\n    MIDDLE = 'middle' as any,\n    BOTTOM = 'bottom' as any,\n}\n\nexport enum FontStyle {\n    NORMAL = 'normal' as any,\n    ITALIC = 'italic' as any,\n}\n\nexport enum Interpolate {\n    /** piecewise linear segments, as in a polyline */\n    LINEAR = 'linear' as any,\n    /** close the linear segments to form a polygon */\n    LINEAR_CLOSED = 'linear-closed' as any,\n    /** alternate between horizontal and vertical segments, as in a step function */\n    STEP = 'step' as any,\n    /** alternate between vertical and horizontal segments, as in a step function */\n    STEP_BEFORE = 'step-before' as any,\n    /** alternate between horizontal and vertical segments, as in a step function */\n    STEP_AFTER = 'step-after' as any,\n    /** a B-spline, with control point duplication on the ends */\n    BASIS = 'basis' as any,\n    /** an open B-spline; may not intersect the start or end */\n    BASIS_OPEN = 'basis-open' as any,\n    /** a closed B-spline, as in a loop */\n    BASIS_CLOSED = 'basis-closed' as any,\n    /** a Cardinal spline, with control point duplication on the ends */\n    CARDINAL = 'cardinal' as any,\n    /** an open Cardinal spline; may not intersect the start or end, but will intersect other control points */\n    CARDINAL_OPEN = 'cardinal-open' as any,\n    /** a closed Cardinal spline, as in a loop */\n    CARDINAL_CLOSED = 'cardinal-closed' as any,\n    /** equivalent to basis, except the tension parameter is used to straighten the spline */\n    BUNDLE = 'bundle' as any,\n    /** cubic interpolation that preserves monotonicity in y */\n    MONOTONE = 'monotone' as any,\n}\n\nexport enum AreaOverlay {\n  LINE = 'line' as any,\n  LINEPOINT = 'linepoint' as any,\n  NONE = 'none' as any\n}\n\nexport interface OverlayConfig {\n  /**\n   * Whether to overlay line with point.\n   */\n  line?: boolean;\n\n  /**\n   * Type of overlay for area mark (line or linepoint)\n   */\n  area?: AreaOverlay;\n\n  /**\n   * Default style for the overlayed point.\n   */\n  pointStyle?: MarkConfig;\n\n  /**\n   * Default style for the overlayed point.\n   */\n  lineStyle?: MarkConfig;\n}\n\nexport const defaultOverlayConfig: OverlayConfig = {\n  line: false,\n  pointStyle: {filled: true},\n  lineStyle: {}\n};\n\nexport interface MarkConfig {\n\n  // ---------- Color ----------\n  /**\n   * Whether the shape\\'s color should be used as fill color instead of stroke color.\n   * This is only applicable for \"bar\", \"point\", and \"area\".\n   * All marks except \"point\" marks are filled by default.\n   * See Mark Documentation (http://vega.github.io/vega-lite/docs/marks.html)\n   * for usage example.\n   */\n  filled?: boolean;\n\n  /**\n   * Default color.\n   * @format color\n   */\n  color?: string;\n\n  /**\n   * Default Fill Color.  This has higher precedence than config.color\n   * @format color\n   */\n  fill?: string;\n\n  /**\n   * Default Stroke Color.  This has higher precedence than config.color\n   * @format color\n   */\n  stroke?: string;\n\n  // ---------- Opacity ----------\n  /**\n   * @minimum 0\n   * @maximum 1\n   */\n  opacity?: number;\n\n  /**\n   * @minimum 0\n   * @maximum 1\n   */\n  fillOpacity?: number;\n\n  /**\n   * @minimum 0\n   * @maximum 1\n   */\n  strokeOpacity?: number;\n\n  // ---------- Stroke Style ----------\n  /**\n   * @minimum 0\n   */\n  strokeWidth?: number;\n\n  /**\n   * An array of alternating stroke, space lengths for creating dashed or dotted lines.\n   */\n  strokeDash?: number[];\n\n  /**\n   * The offset (in pixels) into which to begin drawing with the stroke dash array.\n   */\n  strokeDashOffset?: number;\n\n  // ---------- Stacking: Bar & Area ----------\n  stacked?: StackOffset;\n\n  // ---------- Orientation: Bar, Tick, Line, Area ----------\n  /**\n   * The orientation of a non-stacked bar, tick, area, and line charts.\n   * The value is either horizontal (default) or vertical.\n   * - For bar, rule and tick, this determines whether the size of the bar and tick\n   * should be applied to x or y dimension.\n   * - For area, this property determines the orient property of the Vega output.\n   * - For line, this property determines the sort order of the points in the line\n   * if `config.sortLineBy` is not specified.\n   * For stacked charts, this is always determined by the orientation of the stack;\n   * therefore explicitly specified value will be ignored.\n   */\n  orient?: Orient;\n\n  // ---------- Interpolation: Line / area ----------\n  /**\n   * The line interpolation method to use. One of linear, step-before, step-after, basis, basis-open, cardinal, cardinal-open, monotone.\n   */\n  interpolate?: Interpolate;\n  /**\n   * Depending on the interpolation type, sets the tension parameter.\n   */\n  tension?: number;\n\n  // ---------- Line ---------\n  /**\n   * Size of line mark.\n   */\n  lineSize?: number;\n\n  // ---------- Rule ---------\n  /**\n   * Size of rule mark.\n   */\n  ruleSize?: number;\n\n  // ---------- Bar ----------\n  /**\n   * The size of the bars.  If unspecified, the default size is  `bandSize-1`,\n   * which provides 1 pixel offset between bars.\n   */\n  barSize?: number;\n\n  /**\n   * The size of the bars on continuous scales.\n   */\n  barThinSize?: number;\n\n  // ---------- Point ----------\n  /**\n   * The symbol shape to use. One of circle (default), square, cross, diamond, triangle-up, or triangle-down, or a custom SVG path.\n   */\n  shape?: Shape | string;\n\n  // ---------- Point Size (Point / Square / Circle) ----------\n  /**\n   * The pixel area each the point. For example: in the case of circles, the radius is determined in part by the square root of the size value.\n   */\n  size?: number;\n\n  // ---------- Tick ----------\n  /** The width of the ticks. */\n  tickSize?: number;\n\n  /** Thickness of the tick mark. */\n  tickThickness?: number;\n\n  // ---------- Text ----------\n  /**\n   * The horizontal alignment of the text. One of left, right, center.\n   */\n  align?: HorizontalAlign;\n  /**\n   * The rotation angle of the text, in degrees.\n   */\n  angle?: number;\n  /**\n   * The vertical alignment of the text. One of top, middle, bottom.\n   */\n  baseline?: VerticalAlign;\n  /**\n   * The horizontal offset, in pixels, between the text label and its anchor point. The offset is applied after rotation by the angle property.\n   */\n  dx?: number;\n  /**\n   * The vertical offset, in pixels, between the text label and its anchor point. The offset is applied after rotation by the angle property.\n   */\n  dy?: number;\n  /**\n   * Polar coordinate radial offset, in pixels, of the text label from the origin determined by the x and y properties.\n   */\n  radius?: number;\n  /**\n   * Polar coordinate angle, in radians, of the text label from the origin determined by the x and y properties. Values for theta follow the same convention of arc mark startAngle and endAngle properties: angles are measured in radians, with 0 indicating \"north\".\n   */\n  theta?: number;\n  /**\n   * The typeface to set the text in (e.g., Helvetica Neue).\n   */\n  font?: string;\n  /**\n   * The font size, in pixels.\n   */\n  fontSize?: number;\n  /**\n   * The font style (e.g., italic).\n   */\n  fontStyle?: FontStyle;\n  /**\n   * The font weight (e.g., bold).\n   */\n  fontWeight?: FontWeight;\n  // Vega-Lite only for text only\n  /**\n   * The formatting pattern for text value. If not defined, this will be determined automatically.\n   */\n  format?: string;\n  /**\n   * Whether month names and weekday names should be abbreviated.\n   */\n  shortTimeLabels?: boolean;\n  /**\n   * Placeholder Text\n   */\n  text?: string;\n\n  /**\n   * Apply color field to background color instead of the text.\n   */\n  applyColorToBackground?: boolean;\n}\n\nexport const defaultMarkConfig: MarkConfig = {\n  color: '#4682b4',\n  shape: Shape.CIRCLE,\n  strokeWidth: 2,\n  size: 30,\n  barThinSize: 2,\n  // lineSize is undefined by default, and refer to value from strokeWidth\n  ruleSize: 1,\n  tickThickness: 1,\n\n  fontSize: 10,\n  baseline: VerticalAlign.MIDDLE,\n  text: 'Abc',\n\n  shortTimeLabels: false,\n  applyColorToBackground: false\n};\n\n\nexport interface Config {\n  // TODO: add this back once we have top-down layout approach\n  // width?: number;\n  // height?: number;\n  // padding?: number|string;\n  /**\n   * The width and height of the on-screen viewport, in pixels. If necessary, clipping and scrolling will be applied.\n   */\n  viewport?: number;\n  /**\n   * CSS color property to use as background of visualization. Default is `\"transparent\"`.\n   */\n  background?: string;\n\n  /**\n   * D3 Number format for axis labels and text tables. For example \"s\" for SI units.\n   */\n  numberFormat?: string;\n\n  /**\n   * Default datetime format for axis and legend labels. The format can be set directly on each axis and legend.\n   */\n  timeFormat?: string;\n\n  /**\n   * Default axis and legend title for count fields.\n   * @type {string}\n   */\n  countTitle?: string;\n\n  /** Cell Config */\n  cell?: CellConfig;\n\n  /** Mark Config */\n  mark?: MarkConfig;\n\n  /** Mark Overlay Config */\n  overlay?: OverlayConfig;\n\n  /** Scale Config */\n  scale?: ScaleConfig;\n\n  /** Axis Config */\n  axis?: AxisConfig;\n\n  /** Legend Config */\n  legend?: LegendConfig;\n\n  /** Facet Config */\n  facet?: FacetConfig;\n}\n\nexport const defaultConfig: Config = {\n  numberFormat: 's',\n  timeFormat: '%Y-%m-%d',\n  countTitle: 'Number of Records',\n\n  cell: defaultCellConfig,\n  mark: defaultMarkConfig,\n  overlay: defaultOverlayConfig,\n  scale: defaultScaleConfig,\n  axis: defaultAxisConfig,\n  legend: defaultLegendConfig,\n\n  facet: defaultFacetConfig,\n};\n",
    "/*\n * Constants and utilities for data.\n */\nimport {Type} from './type';\n\nexport interface DataFormat {\n  /**\n   * Type of input data: `\"json\"`, `\"csv\"`, `\"tsv\"`.\n   * The default format type is determined by the extension of the file url.\n   * If no extension is detected, `\"json\"` will be used by default.\n   */\n  type?: DataFormatType;\n\n  /**\n   * JSON only) The JSON property containing the desired data.\n   * This parameter can be used when the loaded JSON file may have surrounding structure or meta-data.\n   * For example `\"property\": \"values.features\"` is equivalent to retrieving `json.values.features`\n   * from the loaded JSON object.\n   */\n  property?: string;\n\n  /**\n   * The name of the TopoJSON object set to convert to a GeoJSON feature collection.\n   * For example, in a map of the world, there may be an object set named `\"countries\"`.\n   * Using the feature property, we can extract this set and generate a GeoJSON feature object for each country.\n   */\n  feature?: string;\n  /**\n   * The name of the TopoJSON object set to convert to a mesh.\n   * Similar to the `feature` option, `mesh` extracts a named TopoJSON object set.\n   *  Unlike the `feature` option, the corresponding geo data is returned as a single, unified mesh instance, not as inidividual GeoJSON features.\n   * Extracting a mesh is useful for more efficiently drawing borders or other geographic elements that you do not need to associate with specific regions such as individual countries, states or counties.\n   */\n  mesh?: string;\n}\n\nexport enum DataFormatType {\n    JSON = 'json' as any,\n    CSV = 'csv' as any,\n    TSV = 'tsv' as any,\n    TOPOJSON = 'topojson' as any\n}\n\nexport interface Data {\n  /**\n   * An object that specifies the format for the data file or values.\n   */\n  format?: DataFormat;\n\n  /**\n   * A URL from which to load the data set. Use the format.type property\n   * to ensure the loaded data is correctly parsed.\n   */\n  url?: string;\n  /**\n   * Pass array of objects instead of a url to a file.\n   */\n  values?: any[];\n}\n\nexport enum DataTable {\n  SOURCE = 'source' as any,\n  SUMMARY = 'summary' as any,\n  STACKED_SCALE = 'stacked_scale' as any,\n  LAYOUT = 'layout' as any\n}\n\nexport const SUMMARY = DataTable.SUMMARY;\nexport const SOURCE = DataTable.SOURCE;\nexport const STACKED_SCALE = DataTable.STACKED_SCALE;\nexport const LAYOUT = DataTable.LAYOUT;\n\n/** Mapping from datalib's inferred type to Vega-lite's type */\n// TODO: consider if we can remove\nexport const types = {\n  'boolean': Type.NOMINAL,\n  'number': Type.QUANTITATIVE,\n  'integer': Type.QUANTITATIVE,\n  'date': Type.TEMPORAL,\n  'string': Type.NOMINAL\n};\n",
    "// DateTime definition object\n\nimport {duplicate, isNumber} from './util';\n\n/**\n * Object for defining datetime in Vega-Lite Filter.\n * If both month and quarter are provided, month has higher precedence.\n * `day` cannot be combined with other date.\n * We accept string for month and day names.\n */\nexport interface DateTime {\n  /** Integer value representing the year. */\n  year?: number;\n\n  /** Integer value representing the quarter of the year (from 1-4). */\n  quarter?: number;\n\n  /** One of: (1) integer value representing the month from `1`-`12`. `1` represents January;  (2) case-insensitive month name (e.g., `\"January\"`);  (3) case-insensitive, 3-character short month name (e.g., `\"Jan\"`). */\n  month?: number | string;\n\n  /** Integer value representing the date from 1-31. */\n  date?: number;\n\n  /**\n   * Value representing the day of week.  This can be one of: (1) integer value -- `1` represents Monday; (2) case-insensitive day name (e.g., `\"Monday\"`);  (3) case-insensitive, 3-character short day name (e.g., `\"Mon\"`).   <br/> **Warning:** A DateTime definition object with `day`** should not be combined with `year`, `quarter`, `month`, or `date`.\n   */\n  day?: number | string;\n\n  /** Integer value representing the hour of day from 0-23. */\n  hours?: number;\n\n  /** Integer value representing minute segment of a time from 0-59. */\n  minutes?: number;\n\n  /** Integer value representing second segment of a time from 0-59. */\n  seconds?: number;\n\n  /** Integer value representing millisecond segment of a time. */\n  milliseconds?: number;\n}\n\n\n/**\n * Internal Object for defining datetime expressions.\n * This is an expression version of DateTime.\n * If both month and quarter are provided, month has higher precedence.\n * `day` cannot be combined with other date.\n */\nexport interface DateTimeExpr {\n  year?: string;\n  quarter?: string;\n  month?: string;\n  date?: string;\n  day?: string;\n  hours?: string;\n  minutes?: string;\n  seconds?: string;\n  milliseconds?: string;\n}\n\nexport function isDateTime(o: any): o is DateTime {\n  return !!o.year || !!o.quarter || !!o.month || !!o.date || !!o.day ||\n    !!o.hours || !!o.minutes || !!o.seconds || !!o.milliseconds;\n}\n\nexport const MONTHS = ['january', 'february', 'march', 'april', 'may', 'june', 'july', 'august', 'september', 'october', 'november', 'december'];\nexport const SHORT_MONTHS = MONTHS.map((m) => m.substr(0, 3));\n\nexport const DAYS = ['sunday', 'monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday'];\nexport const SHORT_DAYS = DAYS.map((d) => d.substr(0,3));\n\nfunction normalizeQuarter(q: number | string) {\n  if (isNumber(q)) {\n    // We accept 1-based quarter, so need to readjust to 0-based quarter\n    return (q - 1) + '';\n  } else {\n    // Simply an expression string, but normalize should not be called in this case.\n    console.warn('Potentially invalid quarter', q);\n    return q;\n  }\n}\n\nfunction normalizeMonth(m: string | number) {\n  if (isNumber(m)) {\n    // We accept 1-based month, so need to readjust to 0-based month\n    return (m - 1) + '';\n  } else {\n    const lowerM = m.toLowerCase();\n    const monthIndex = MONTHS.indexOf(lowerM);\n    if (monthIndex !== -1) {\n      return monthIndex + ''; // 0 for january, ...\n    }\n    const shortM = lowerM.substr(0, 3);\n    const shortMonthIndex = SHORT_MONTHS.indexOf(shortM);\n    if (shortMonthIndex !== -1) {\n      return shortMonthIndex + '';\n    }\n    // Simply an expression string, but normalize should not be called in this case.\n    console.warn('Potentially invalid month', m);\n    return m;\n  }\n}\n\nfunction normalizeDay(d: string | number) {\n  if (isNumber(d)) {\n    // mod so that this can be both 0-based where 0 = sunday\n    // and 1-based where 7=sunday\n    return (d % 7) + '';\n  } else {\n    const lowerD = d.toLowerCase();\n    const dayIndex = DAYS.indexOf(lowerD);\n    if (dayIndex !== -1) {\n      return dayIndex + ''; // 0 for january, ...\n    }\n    const shortD = lowerD.substr(0, 3);\n    const shortDayIndex = SHORT_DAYS.indexOf(shortD);\n    if (shortDayIndex !== -1) {\n      return shortDayIndex + '';\n    }\n    // Simply an expression string, but normalize should not be called in this case.\n    console.warn('Potentially invalid day', d);\n    return d;\n  }\n}\n\n/**\n * Return Vega Expression for a particular date time.\n * @param d\n * @param normalize whether to normalize quarter, month, day.\n */\nexport function dateTimeExpr(d: DateTime | DateTimeExpr, normalize = false) {\n  const units = [];\n\n  if (normalize && d.day !== undefined) {\n    for (let unit of ['year', 'quarter', 'month', 'date']) {\n      if (d[unit] !== undefined) {\n        console.warn('Dropping day from datetime', JSON.stringify(d),\n          'as day cannot be combined with', unit);\n        d = duplicate(d);\n        delete d.day;\n        break;\n      }\n    }\n  }\n\n  if (d.year !== undefined) {\n    units.push(d.year);\n  } else if (d.day !== undefined) {\n    // Set year to 2006 for working with day since January 1 2006 is a Sunday\n    units.push(2006);\n  } else {\n    units.push(0);\n  }\n\n  if (d.month !== undefined) {\n    const month = normalize ? normalizeMonth(d.month) : d.month;\n    units.push(month);\n  } else if (d.quarter !== undefined) {\n    const quarter = normalize ? normalizeQuarter(d.quarter) : d.quarter;\n    units.push(quarter + '*3');\n  } else {\n    units.push(0); // months start at zero in JS\n  }\n\n  if (d.date !== undefined) {\n    units.push(d.date);\n  } else if (d.day !== undefined) {\n    // HACK: Day only works as a standalone unit\n    // This is only correct because we always set year to 2006 for day\n    const day = normalize ? normalizeDay(d.day) : d.day;\n    units.push(day + '+1');\n  } else {\n    units.push(1); // Date starts at 1 in JS\n  }\n\n  // Note: can't use TimeUnit enum here as importing it will create\n  // circular dependency problem!\n  for (let timeUnit of ['hours', 'minutes', 'seconds', 'milliseconds']) {\n    if (d[timeUnit] !== undefined) {\n      units.push(d[timeUnit]);\n    } else {\n      units.push(0);\n    }\n  }\n\n  return 'datetime(' + units.join(', ') + ')';\n}\n",
    "// utility for encoding mapping\nimport {FieldDef, PositionChannelDef, FacetChannelDef, ChannelDefWithLegend, OrderChannelDef} from './fielddef';\nimport {Channel, CHANNELS} from './channel';\nimport {isArray, some} from './util';\n\n// TODO: once we decompose facet, rename this to Encoding\nexport interface UnitEncoding {\n  /**\n   * X coordinates for `point`, `circle`, `square`,\n   * `line`, `rule`, `text`, and `tick`\n   * (or to width and height for `bar` and `area` marks).\n   */\n  x?: PositionChannelDef;\n\n  /**\n   * Y coordinates for `point`, `circle`, `square`,\n   * `line`, `rule`, `text`, and `tick`\n   * (or to width and height for `bar` and `area` marks).\n   */\n  y?: PositionChannelDef;\n\n  /**\n   * X2 coordinates for ranged `bar`, `rule`, `area`\n   */\n  x2?: FieldDef;\n\n  /**\n   * Y2 coordinates for ranged `bar`, `rule`, `area`\n   */\n  y2?: FieldDef;\n\n  /**\n   * Color of the marks – either fill or stroke color based on mark type.\n   * (By default, fill color for `area`, `bar`, `tick`, `text`, `circle`, and `square` /\n   * stroke color for `line` and `point`.)\n   */\n  color?: ChannelDefWithLegend;\n  /**\n   * Opacity of the marks – either can be a value or in a range.\n   */\n  opacity?: ChannelDefWithLegend;\n\n  /**\n   * Size of the mark.\n   * - For `point`, `square` and `circle`\n   * – the symbol size, or pixel area of the mark.\n   * - For `bar` and `tick` – the bar and tick's size.\n   * - For `text` – the text's font size.\n   * - Size is currently unsupported for `line` and `area`.\n   */\n  size?: ChannelDefWithLegend;\n\n  /**\n   * The symbol's shape (only for `point` marks). The supported values are\n   * `\"circle\"` (default), `\"square\"`, `\"cross\"`, `\"diamond\"`, `\"triangle-up\"`,\n   * or `\"triangle-down\"`, or else a custom SVG path string.\n   */\n  shape?: ChannelDefWithLegend; // TODO: maybe distinguish ordinal-only\n\n  /**\n   * Additional levels of detail for grouping data in aggregate views and\n   * in line and area marks without mapping data to a specific visual channel.\n   */\n  detail?: FieldDef | FieldDef[];\n\n  /**\n   * Text of the `text` mark.\n   */\n  text?: FieldDef;\n\n  label?: FieldDef;\n\n  /**\n   * Order of data points in line marks.\n   */\n  path?: OrderChannelDef | OrderChannelDef[];\n\n  /**\n   * Layer order for non-stacked marks, or stack order for stacked marks.\n   */\n  order?: OrderChannelDef | OrderChannelDef[];\n}\n\n// TODO: once we decompose facet, rename this to ExtendedEncoding\nexport interface Encoding extends UnitEncoding {\n  /**\n   * Vertical facets for trellis plots.\n   */\n  row?: FacetChannelDef;\n\n  /**\n   * Horizontal facets for trellis plots.\n   */\n  column?: FacetChannelDef;\n}\n\nexport function countRetinal(encoding: Encoding) {\n  let count = 0;\n  if (encoding.color) { count++; }\n  if (encoding.opacity) { count++; }\n  if (encoding.size) { count++; }\n  if (encoding.shape) { count++; }\n  return count;\n}\n\nexport function channels(encoding: Encoding) {\n  return CHANNELS.filter(function(channel) {\n    return has(encoding, channel);\n  });\n}\n\n// TOD: rename this to hasChannelField and only use we really want it.\nexport function has(encoding: Encoding, channel: Channel): boolean {\n  const channelEncoding = encoding && encoding[channel];\n  return channelEncoding && (\n    channelEncoding.field !== undefined ||\n    // TODO: check that we have field in the array\n    (isArray(channelEncoding) && channelEncoding.length > 0)\n  );\n}\n\nexport function isAggregate(encoding: Encoding) {\n  return some(CHANNELS, (channel) => {\n    if (has(encoding, channel) && encoding[channel].aggregate) {\n      return true;\n    }\n    return false;\n  });\n}\n\nexport function isRanged(encoding: Encoding) {\n  return encoding && ((!!encoding.x && !!encoding.x2) || (!!encoding.y && !!encoding.y2));\n}\n\nexport function fieldDefs(encoding: Encoding): FieldDef[] {\n  let arr = [];\n  CHANNELS.forEach(function(channel) {\n    if (has(encoding, channel)) {\n      if (isArray(encoding[channel])) {\n        encoding[channel].forEach(function(fieldDef) {\n          arr.push(fieldDef);\n        });\n      } else {\n        arr.push(encoding[channel]);\n      }\n    }\n  });\n  return arr;\n};\n\nexport function forEach(encoding: Encoding,\n    f: (fd: FieldDef, c: Channel, i: number) => void,\n    thisArg?: any) {\n  channelMappingForEach(CHANNELS, encoding, f, thisArg);\n}\n\nexport function channelMappingForEach(channels: Channel[], mapping: any,\n    f: (fd: FieldDef, c: Channel, i: number) => void,\n    thisArg?: any) {\n  let i = 0;\n  channels.forEach(function(channel) {\n    if (has(mapping, channel)) {\n      if (isArray(mapping[channel])) {\n        mapping[channel].forEach(function(fieldDef) {\n            f.call(thisArg, fieldDef, channel, i++);\n        });\n      } else {\n        f.call(thisArg, mapping[channel], channel, i++);\n      }\n    }\n  });\n}\n\nexport function map(encoding: Encoding,\n    f: (fd: FieldDef, c: Channel, i: number) => any,\n    thisArg?: any) {\n  return channelMappingMap(CHANNELS, encoding, f , thisArg);\n}\n\nexport function channelMappingMap(channels: Channel[], mapping: any,\n    f: (fd: FieldDef, c: Channel, i: number) => any,\n    thisArg?: any) {\n  let arr = [];\n  channels.forEach(function(channel) {\n    if (has(mapping, channel)) {\n      if (isArray(mapping[channel])) {\n        mapping[channel].forEach(function(fieldDef) {\n          arr.push(f.call(thisArg, fieldDef, channel));\n        });\n      } else {\n        arr.push(f.call(thisArg, mapping[channel], channel));\n      }\n    }\n  });\n  return arr;\n}\nexport function reduce(encoding: Encoding,\n    f: (acc: any, fd: FieldDef, c: Channel) => any,\n    init,\n    thisArg?: any) {\n  return channelMappingReduce(CHANNELS, encoding, f, init, thisArg);\n}\n\nexport function channelMappingReduce(channels: Channel[], mapping: any,\n    f: (acc: any, fd: FieldDef, c: Channel) => any,\n    init,\n    thisArg?: any) {\n  let r = init;\n  CHANNELS.forEach(function(channel) {\n    if (has(mapping, channel)) {\n      if (isArray(mapping[channel])) {\n        mapping[channel].forEach(function(fieldDef) {\n            r = f.call(thisArg, r, fieldDef, channel);\n        });\n      } else {\n        r = f.call(thisArg, r, mapping[channel], channel);\n      }\n    }\n  });\n  return r;\n}\n",
    "// utility for a field definition object\n\nimport {AggregateOp} from './aggregate';\nimport {Axis} from './axis';\nimport {Bin} from './bin';\nimport {Config} from './config';\nimport {Legend} from './legend';\nimport {Scale, ScaleType} from './scale';\nimport {SortField, SortOrder} from './sort';\nimport {TimeUnit} from './timeunit';\nimport {Type, NOMINAL, ORDINAL, QUANTITATIVE, TEMPORAL} from './type';\nimport {contains} from './util';\n\n/**\n *  Interface for any kind of FieldDef;\n *  For simplicity, we do not declare multiple interfaces of FieldDef like\n *  we do for JSON schema.\n */\nexport interface FieldDef {\n  /**\n   * Name of the field from which to pull a data value.\n   */\n  field?: string;\n\n  /**\n   * The encoded field's type of measurement. This can be either a full type\n   * name (`\"quantitative\"`, `\"temporal\"`, `\"ordinal\"`,  and `\"nominal\"`)\n   * or an initial character of the type name (`\"Q\"`, `\"T\"`, `\"O\"`, `\"N\"`).\n   * This property is case insensitive.\n   */\n  type?: Type;\n\n  /**\n   * A constant value in visual domain.\n   */\n  value?: number | string | boolean;\n\n  // function\n\n  /**\n   * Time unit for a `temporal` field  (e.g., `year`, `yearmonth`, `month`, `hour`).\n   */\n  timeUnit?: TimeUnit;\n\n  /**\n   * Flag for binning a `quantitative` field, or a bin property object\n   * for binning parameters.\n   */\n  bin?: boolean | Bin;\n\n  /**\n   * Aggregation function for the field\n   * (e.g., `mean`, `sum`, `median`, `min`, `max`, `count`).\n   */\n  aggregate?: AggregateOp;\n\n  /**\n   * Title for axis or legend.\n   */\n  title?: string;\n}\n\nexport interface ChannelDefWithScale extends FieldDef {\n  scale?: Scale;\n  sort?: SortField | SortOrder;\n}\n\nexport interface PositionChannelDef extends ChannelDefWithScale {\n  axis?: boolean | Axis;\n}\nexport interface ChannelDefWithLegend extends ChannelDefWithScale {\n  legend?: Legend;\n}\n\n// Detail\n\n// Order Path have no scale\n\nexport interface OrderChannelDef extends FieldDef {\n  sort?: SortOrder;\n}\n\n// TODO: consider if we want to distinguish ordinalOnlyScale from scale\nexport type FacetChannelDef = PositionChannelDef;\n\nexport interface FieldRefOption {\n  /** exclude bin, aggregate, timeUnit */\n  nofn?: boolean;\n  /** exclude aggregation function */\n  noAggregate?: boolean;\n  /** Wrap the field inside datum[...] per Vega convention */\n  datum?: boolean;\n  /** replace fn with custom function prefix */\n  fn?: string;\n  /** prepend fn with custom function prefix */\n  prefix?: string;\n  /** scaleType */\n  scaleType?: ScaleType;\n  /** append suffix to the field ref for bin (default='start') */\n  binSuffix?: string;\n  /** append suffix to the field ref (general) */\n  suffix?: string;\n}\n\nexport function field(fieldDef: FieldDef, opt: FieldRefOption = {}) {\n  let field = fieldDef.field;\n  let prefix = opt.prefix;\n  let suffix = opt.suffix;\n\n  if (isCount(fieldDef)) {\n    field = 'count';\n  } else {\n    let fn = opt.fn;\n\n    if (!opt.nofn) {\n      if (fieldDef.bin) {\n        fn = 'bin';\n\n        suffix = opt.binSuffix || (\n          opt.scaleType === ScaleType.ORDINAL ?\n            // For ordinal scale type, use `range` as suffix.\n            'range' :\n            // For non-ordinal scale or unknown, use `start` as suffix.\n            'start'\n        );\n      } else if (!opt.noAggregate && fieldDef.aggregate) {\n        fn = String(fieldDef.aggregate);\n      } else if (fieldDef.timeUnit) {\n        fn = String(fieldDef.timeUnit);\n      }\n    }\n\n    if (!!fn) {\n      field = `${fn}_${field}`;\n    }\n  }\n\n  if (!!suffix) {\n    field = `${field}_${suffix}`;\n  }\n\n  if (!!prefix) {\n    field = `${prefix}_${field}`;\n  }\n\n  if (opt.datum) {\n    field = `datum[\"${field}\"]`;\n  }\n\n  return field;\n}\n\nfunction _isFieldDimension(fieldDef: FieldDef) {\n  if (contains([NOMINAL, ORDINAL], fieldDef.type)) {\n    return true;\n  } else if(!!fieldDef.bin) {\n    return true;\n  } else if (fieldDef.type === TEMPORAL) {\n    return !!fieldDef.timeUnit;\n  }\n  return false;\n}\n\nexport function isDimension(fieldDef: FieldDef) {\n  return fieldDef && fieldDef.field && _isFieldDimension(fieldDef);\n}\n\nexport function isMeasure(fieldDef: FieldDef) {\n  return fieldDef && fieldDef.field && !_isFieldDimension(fieldDef);\n}\n\nexport function count(): FieldDef {\n  return { field: '*', aggregate: AggregateOp.COUNT, type: QUANTITATIVE};\n}\n\nexport function isCount(fieldDef: FieldDef) {\n  return fieldDef.aggregate === AggregateOp.COUNT;\n}\n\nexport function title(fieldDef: FieldDef, config: Config) {\n  if (fieldDef.title != null) {\n    return fieldDef.title;\n  }\n  if (isCount(fieldDef)) {\n    return config.countTitle;\n  }\n  const fn = fieldDef.aggregate || fieldDef.timeUnit || (fieldDef.bin && 'bin');\n  if (fn) {\n    return fn.toString().toUpperCase() + '(' + fieldDef.field + ')';\n  } else {\n    return fieldDef.field;\n  }\n}\n",
    "import {DateTime, dateTimeExpr, isDateTime} from './datetime';\nimport {field} from './fielddef';\nimport {TimeUnit, fieldExpr as timeUnitFieldExpr, isSingleTimeUnit} from './timeunit';\nimport {isArray, isString} from './util';\n\nexport type Filter = EqualFilter | RangeFilter | OneOfFilter ;\n\n\nexport interface EqualFilter {\n  // TODO: support aggregate\n\n  /**\n   * Time unit for the field to be filtered.\n   */\n  timeUnit?: TimeUnit;\n\n  /**\n   * Field to be filtered.\n   */\n  field: string;\n\n  /**\n   * Value that the field should be equal to.\n   */\n  equal: string | number | boolean | DateTime;\n\n}\n\nexport function isEqualFilter(filter: any): filter is EqualFilter {\n  return filter && !!filter.field && filter.equal!==undefined;\n}\n\nexport interface RangeFilter {\n  // TODO: support aggregate\n\n  /**\n   * time unit for the field to be filtered.\n   */\n  timeUnit?: TimeUnit;\n\n  /**\n   * Field to be filtered\n   */\n  field: string;\n\n  /**\n   * Array of inclusive minimum and maximum values\n   * for a field value of a data item to be included in the filtered data.\n   * @maxItems 2\n   * @minItems 2\n   */\n  range: Array<number|DateTime>;\n\n}\n\nexport function isRangeFilter(filter: any): filter is RangeFilter {\n  if (filter && !!filter.field) {\n    if (isArray(filter.range) && filter.range.length === 2) {\n      return true;\n    }\n  }\n  return false;\n}\n\nexport interface OneOfFilter {\n  // TODO: support aggregate\n\n  /**\n   * time unit for the field to be filtered.\n   */\n  timeUnit?: TimeUnit;\n\n  /**\n   * Field to be filtered\n   */\n  field: string;\n\n  /**\n   * A set of values that the `field`'s value should be a member of,\n   * for a data item included in the filtered data.\n   */\n  oneOf: Array<string|number|boolean|DateTime>;\n\n}\n\nexport function isOneOfFilter(filter: any): filter is OneOfFilter {\n  return filter && !!filter.field && (\n    isArray(filter.oneOf) ||\n    isArray(filter.in) // backward compatability\n  );\n}\n\nexport function expression(filter: Filter | string) {\n  if (isString(filter)) {\n    return filter as string;\n  } else { // Filter Object\n    const fieldExpr = filter.timeUnit ?\n      // For timeUnit, cast into integer with time() so we can use ===, inrange, indexOf to compare values directly.\n        // TODO: We calculate timeUnit on the fly here. Consider if we would like to consolidate this with timeUnit pipeline\n        // TODO: support utc\n      ('time(' + timeUnitFieldExpr(filter.timeUnit, filter.field) + ')') :\n      field(filter, {datum: true});\n\n    if (isEqualFilter(filter)) {\n      return fieldExpr + '===' + valueExpr(filter.equal, filter.timeUnit);\n    } else if (isOneOfFilter(filter)) {\n      // \"oneOf\" was formerly \"in\" -- so we need to add backward compatability\n      const oneOf = filter.oneOf || filter['in'];\n      return 'indexof([' +\n        oneOf.map((v) => valueExpr(v, filter.timeUnit)).join(',') +\n        '], ' + fieldExpr + ') !== -1';\n    } else if (isRangeFilter(filter)) {\n      const lower = filter.range[0];\n      const upper = filter.range[1];\n\n      if (lower !== null &&  upper !== null) {\n        return 'inrange(' + fieldExpr + ', ' +\n          valueExpr(lower, filter.timeUnit) + ', ' +\n          valueExpr(upper, filter.timeUnit) + ')';\n      } else if (lower !== null) {\n        return fieldExpr + ' >= ' + lower;\n      } else if (upper !== null) {\n        return fieldExpr + ' <= ' + upper;\n      }\n    }\n  }\n  return undefined;\n}\n\nfunction valueExpr(v: any, timeUnit: TimeUnit) {\n  if (isDateTime(v)) {\n    const expr = dateTimeExpr(v, true);\n    return 'time(' + expr + ')';\n  }\n  if (isSingleTimeUnit(timeUnit)) {\n    const datetime: DateTime = {};\n    datetime[timeUnit] = v;\n    const expr = dateTimeExpr(datetime, true);\n    return 'time(' + expr + ')';\n  }\n  return JSON.stringify(v);\n}\n",
    "export interface LegendConfig {\n  /**\n   * The orientation of the legend. One of \"left\" or \"right\". This determines how the legend is positioned within the scene. The default is \"right\".\n   */\n  orient?: string;\n  /**\n   * The offset, in pixels, by which to displace the legend from the edge of the enclosing group or data rectangle.\n   */\n  offset?: number;\n  /**\n   * The padding, in pixels, between the lengend and axis.\n   */\n  padding?: number;\n  /**\n   * The margin around the legend, in pixels\n   */\n  margin?: number;\n  /**\n   * The color of the gradient stroke, can be in hex color code or regular color name.\n   */\n  gradientStrokeColor?: string;\n  /**\n   * The width of the gradient stroke, in pixels.\n   */\n  gradientStrokeWidth?: number;\n  /**\n   * The height of the gradient, in pixels.\n   */\n  gradientHeight?: number;\n  /**\n   * The width of the gradient, in pixels.\n   */\n  gradientWidth?: number;\n  /**\n   * The alignment of the legend label, can be left, middle or right.\n   */\n  labelAlign?: string;\n  /**\n   * The position of the baseline of legend label, can be top, middle or bottom.\n   */\n  labelBaseline?: string;\n  /**\n   * The color of the legend label, can be in hex color code or regular color name.\n   */\n  labelColor?: string;\n  /**\n   * The font of the lengend label.\n   */\n  labelFont?: string;\n  /**\n   * The font size of lengend lable.\n   */\n  labelFontSize?: number;\n  /**\n   * The offset of the legend label.\n   */\n  labelOffset?: number;\n  /**\n   * Whether month names and weekday names should be abbreviated.\n   */\n  shortTimeLabels?: boolean;\n  /**\n   * The color of the legend symbol,\n   */\n  symbolColor?: string;\n  /**\n   * The shape of the legend symbol, can be the 'circle', 'square', 'cross', 'diamond',\n   * 'triangle-up', 'triangle-down', or else a custom SVG path string.\n   */\n  symbolShape?: string;\n  /**\n   * The size of the lengend symbol, in pixels.\n   */\n  symbolSize?: number;\n  /**\n   * The width of the symbol's stroke.\n   */\n  symbolStrokeWidth?: number;\n  /**\n   * Optional mark property definitions for custom legend styling.\n   */\n  /**\n   * The color of the legend title, can be in hex color code or regular color name.\n   */\n  titleColor?: string;\n  /**\n   * The font of the legend title.\n   */\n  titleFont?: string;\n  /**\n   * The font size of the legend title.\n   */\n  titleFontSize?: number;\n  /**\n   * The font weight of the legend title.\n   */\n  titleFontWeight?: string;\n  /**\n   * Optional mark property definitions for custom legend styling.\n   */\n  properties?: any; // TODO(#975) replace with config properties\n}\n\n/**\n * Properties of a legend or boolean flag for determining whether to show it.\n */\nexport interface Legend extends LegendConfig {\n  /**\n   * An optional formatting pattern for legend labels. Vega uses D3\\'s format pattern.\n   */\n  format?: string;\n  /**\n   * A title for the legend. (Shows field name and its function by default.)\n   */\n  title?: string;\n  /**\n   * Explicitly set the visible legend values.\n   */\n  values?: Array<any>;\n}\n\nexport const defaultLegendConfig: LegendConfig = {\n  orient: undefined, // implicitly \"right\"\n  shortTimeLabels: false\n};\n",
    "export enum Mark {\n  AREA = 'area' as any,\n  BAR = 'bar' as any,\n  LINE = 'line' as any,\n  POINT = 'point' as any,\n  TEXT = 'text' as any,\n  TICK = 'tick' as any,\n  RULE = 'rule' as any,\n  CIRCLE = 'circle' as any,\n  SQUARE = 'square' as any,\n  ERRORBAR = 'errorBar' as any\n}\n\nexport const AREA = Mark.AREA;\nexport const BAR = Mark.BAR;\nexport const LINE = Mark.LINE;\nexport const POINT = Mark.POINT;\nexport const TEXT = Mark.TEXT;\nexport const TICK = Mark.TICK;\nexport const RULE = Mark.RULE;\n\nexport const CIRCLE = Mark.CIRCLE;\nexport const SQUARE = Mark.SQUARE;\n\nexport const ERRORBAR = Mark.ERRORBAR;\nexport const PRIMITIVE_MARKS = [AREA, BAR, LINE, POINT, TEXT, TICK, RULE, CIRCLE, SQUARE];\n",
    "export enum ScaleType {\n    LINEAR = 'linear' as any,\n    LOG = 'log' as any,\n    POW = 'pow' as any,\n    SQRT = 'sqrt' as any,\n    QUANTILE = 'quantile' as any,\n    QUANTIZE = 'quantize' as any,\n    ORDINAL = 'ordinal' as any,\n    TIME = 'time' as any,\n    UTC  = 'utc' as any,\n}\n\nexport enum NiceTime {\n    SECOND = 'second' as any,\n    MINUTE = 'minute' as any,\n    HOUR = 'hour' as any,\n    DAY = 'day' as any,\n    WEEK = 'week' as any,\n    MONTH = 'month' as any,\n    YEAR = 'year' as any,\n}\n\nexport enum BandSize {\n  FIT = 'fit' as any\n}\n\nexport const BANDSIZE_FIT = BandSize.FIT;\n\nexport interface ScaleConfig {\n  /**\n   * If true, rounds numeric output values to integers.\n   * This can be helpful for snapping to the pixel grid.\n   * (Only available for `x`, `y`, `size`, `row`, and `column` scales.)\n   */\n  round?: boolean;\n  /**\n   *  Default band width for `x` ordinal scale when is mark is `text`.\n   *  @minimum 0\n   */\n  textBandWidth?: number;\n  /**\n   * Default band size for (1) `y` ordinal scale,\n   * and (2) `x` ordinal scale when the mark is not `text`.\n   * @minimum 0\n   */\n  bandSize?: number | BandSize;\n  /**\n   * Default range for opacity.\n   */\n  opacity?: number[];\n  /**\n   * Default padding for `x` and `y` ordinal scales.\n   */\n  padding?: number;\n\n  /**\n   * Uses the source data range as scale domain instead of aggregated data for aggregate axis.\n   * This property only works with aggregate functions that produce values within the raw data domain (`\"mean\"`, `\"average\"`, `\"stdev\"`, `\"stdevp\"`, `\"median\"`, `\"q1\"`, `\"q3\"`, `\"min\"`, `\"max\"`). For other aggregations that produce values outside of the raw data domain (e.g. `\"count\"`, `\"sum\"`), this property is ignored.\n   */\n  useRawDomain?: boolean;\n\n  /** Default range for nominal color scale */\n  nominalColorRange?: string | string[];\n  /** Default range for ordinal / continuous color scale */\n  sequentialColorRange?: string | string[];\n  /** Default range for shape */\n  shapeRange?: string|string[];\n\n  /** Default range for bar size scale */\n  barSizeRange?: number[];\n\n  /** Default range for font size scale */\n  fontSizeRange?: number[];\n\n  /** Default range for rule stroke widths */\n  ruleSizeRange?: number[];\n\n  /** Default range for tick spans */\n  tickSizeRange?: number[];\n\n  /** Default range for bar size scale */\n  pointSizeRange?: number[];\n\n  // nice should depends on type (quantitative or temporal), so\n  // let's not make a config.\n}\n\nexport const defaultScaleConfig: ScaleConfig = {\n  round: true,\n  textBandWidth: 90,\n  bandSize: 21,\n  padding: 0.1,\n  useRawDomain: false,\n  opacity: [0.3, 0.8],\n\n  nominalColorRange: 'category10',\n  sequentialColorRange: ['#AFC6A3', '#09622A'], // tableau greens\n  shapeRange: 'shapes',\n  fontSizeRange: [8, 40],\n  ruleSizeRange: [1, 5],\n  tickSizeRange: [1, 20]\n};\n\nexport interface FacetScaleConfig {\n  round?: boolean;\n  padding?: number;\n}\n\nexport const defaultFacetScaleConfig: FacetScaleConfig = {\n  round: true,\n  padding: 16\n};\n\nexport interface Scale {\n  type?: ScaleType;\n  /**\n   * The domain of the scale, representing the set of data values. For quantitative data, this can take the form of a two-element array with minimum and maximum values. For ordinal/categorical data, this may be an array of valid input values.\n   */\n  domain?: number[] | string[]; // TODO: declare vgDataDomain\n  /**\n   * The range of the scale, representing the set of visual values. For numeric values, the range can take the form of a two-element array with minimum and maximum values. For ordinal or quantized data, the range may by an array of desired output values, which are mapped to elements in the specified domain. For ordinal scales only, the range can be defined using a DataRef: the range values are then drawn dynamically from a backing data set.\n   */\n  range?: string | number[] | string[]; // TODO: declare vgRangeDomain\n  /**\n   * If true, rounds numeric output values to integers. This can be helpful for snapping to the pixel grid.\n   */\n  round?: boolean;\n\n  // ordinal\n  /**\n   * @minimum 0\n   */\n  bandSize?: number | BandSize;\n  /**\n   * Applies spacing among ordinal elements in the scale range. The actual effect depends on how the scale is configured. If the __points__ parameter is `true`, the padding value is interpreted as a multiple of the spacing between points. A reasonable value is 1.0, such that the first and last point will be offset from the minimum and maximum value by half the distance between points. Otherwise, padding is typically in the range [0, 1] and corresponds to the fraction of space in the range interval to allocate to padding. A value of 0.5 means that the range band width will be equal to the padding width. For more, see the [D3 ordinal scale documentation](https://github.com/mbostock/d3/wiki/Ordinal-Scales).\n   */\n  padding?: number;\n\n  // typical\n  /**\n   * If true, values that exceed the data domain are clamped to either the minimum or maximum range value\n   */\n  clamp?: boolean;\n  /**\n   * If specified, modifies the scale domain to use a more human-friendly value range. If specified as a true boolean, modifies the scale domain to use a more human-friendly number range (e.g., 7 instead of 6.96). If specified as a string, modifies the scale domain to use a more human-friendly value range. For time and utc scale types only, the nice value should be a string indicating the desired time interval.\n   */\n  nice?: boolean | NiceTime;\n  /**\n   * Sets the exponent of the scale transformation. For pow scale types only, otherwise ignored.\n   */\n  exponent?: number;\n  /**\n   * If `true`, ensures that a zero baseline value is included in the scale domain.\n   * Default value: `true` for `x` and `y` channel if the quantitative field is not binned\n   * and no custom `domain` is provided; `false` otherwise.\n   */\n  zero?: boolean;\n\n  // Vega-Lite only\n  /**\n   * Uses the source data range as scale domain instead of aggregated data for aggregate axis.\n   * This property only works with aggregate functions that produce values within the raw data domain (`\"mean\"`, `\"average\"`, `\"stdev\"`, `\"stdevp\"`, `\"median\"`, `\"q1\"`, `\"q3\"`, `\"min\"`, `\"max\"`). For other aggregations that produce values outside of the raw data domain (e.g. `\"count\"`, `\"sum\"`), this property is ignored.\n   */\n  useRawDomain?: boolean;\n}\n",
    "/** module for shorthand */\n\nimport {Encoding} from './encoding';\nimport {FieldDef} from './fielddef';\nimport {ExtendedUnitSpec} from './spec';\n\nimport {AggregateOp, AGGREGATE_OPS} from './aggregate';\nimport {TIMEUNITS} from './timeunit';\nimport {SHORT_TYPE, TYPE_FROM_SHORT_TYPE} from './type';\nimport * as vlEncoding from './encoding';\nimport {Mark} from './mark';\n\nexport const DELIM = '|';\nexport const ASSIGN = '=';\nexport const TYPE = ',';\nexport const FUNC = '_';\n\n\nexport function shorten(spec: ExtendedUnitSpec): string {\n  return 'mark' + ASSIGN + spec.mark +\n    DELIM + shortenEncoding(spec.encoding);\n}\n\nexport function parse(shorthand: string, data?, config?) {\n  let split = shorthand.split(DELIM),\n    mark = split.shift().split(ASSIGN)[1].trim(),\n    encoding = parseEncoding(split.join(DELIM));\n\n  let spec:ExtendedUnitSpec = {\n    mark: Mark[mark],\n    encoding: encoding\n  };\n\n  if (data !== undefined) {\n    spec.data = data;\n  }\n  if (config !== undefined) {\n    spec.config = config;\n  }\n  return spec;\n}\n\nexport function shortenEncoding(encoding: Encoding): string {\n  return vlEncoding.map(encoding, function(fieldDef, channel) {\n    return channel + ASSIGN + shortenFieldDef(fieldDef);\n  }).join(DELIM);\n}\n\nexport function parseEncoding(encodingShorthand: string): Encoding {\n  return encodingShorthand.split(DELIM).reduce(function(m, e) {\n    const split = e.split(ASSIGN),\n        enctype = split[0].trim(),\n        fieldDefShorthand = split[1];\n\n    m[enctype] = parseFieldDef(fieldDefShorthand);\n    return m;\n  }, {});\n}\n\nexport function shortenFieldDef(fieldDef: FieldDef): string {\n  return (fieldDef.aggregate ? fieldDef.aggregate + FUNC : '') +\n    (fieldDef.timeUnit ? fieldDef.timeUnit + FUNC : '') +\n    (fieldDef.bin ? 'bin' + FUNC : '') +\n    (fieldDef.field || '') + TYPE + SHORT_TYPE[fieldDef.type];\n}\n\nexport function shortenFieldDefs(fieldDefs: FieldDef[], delim = DELIM): string {\n  return fieldDefs.map(shortenFieldDef).join(delim);\n}\n\nexport function parseFieldDef(fieldDefShorthand: string): FieldDef {\n  const split = fieldDefShorthand.split(TYPE);\n\n  let fieldDef: FieldDef = {\n    field: split[0].trim(),\n    type: TYPE_FROM_SHORT_TYPE[split[1].trim()]\n  };\n\n  // check aggregate type\n  for (let i = 0; i < AGGREGATE_OPS.length; i++) {\n    let a = AGGREGATE_OPS[i];\n    if (fieldDef.field.indexOf(a + '_') === 0) {\n      fieldDef.field = fieldDef.field.substr(a.toString().length + 1);\n      if (a === AggregateOp.COUNT && fieldDef.field.length === 0) {\n        fieldDef.field = '*';\n      }\n      fieldDef.aggregate = a;\n      break;\n    }\n  }\n\n  for (let i = 0; i < TIMEUNITS.length; i++) {\n    let tu = TIMEUNITS[i];\n    if (fieldDef.field && fieldDef.field.indexOf(tu + '_') === 0) {\n      fieldDef.field = fieldDef.field.substr(fieldDef.field.length + 1);\n      fieldDef.timeUnit = tu;\n      break;\n    }\n  }\n\n  // check bin\n  if (fieldDef.field && fieldDef.field.indexOf('bin_') === 0) {\n    fieldDef.field = fieldDef.field.substr(4);\n    fieldDef.bin = true;\n  }\n\n  return fieldDef;\n}\n",
    "import {AggregateOp} from './aggregate';\n\nexport enum SortOrder {\n    ASCENDING = 'ascending' as any,\n    DESCENDING = 'descending' as any,\n    NONE = 'none' as any,\n}\n\nexport interface SortField {\n  /**\n   * The field name to aggregate over.\n   */\n  field: string;\n  /**\n   * The sort aggregation operator\n   */\n  op: AggregateOp;\n\n  order?: SortOrder;\n}\n\nexport function isSortField(sort: SortOrder | SortField): sort is SortField {\n  return !!sort && !!sort['field'] && !!sort['op'];\n}\n",
    "/* Package of defining Vega-lite Specification's json schema at its utility functions */\n\nimport {Config, defaultOverlayConfig, AreaOverlay} from './config';\nimport {Data} from './data';\nimport {Encoding, UnitEncoding, has, isRanged} from './encoding';\nimport {Facet} from './facet';\nimport {FieldDef} from './fielddef';\nimport {Mark, ERRORBAR, TICK, AREA, RULE, LINE, POINT} from './mark';\nimport {stack} from './stack';\nimport {Transform} from './transform';\nimport {ROW, COLUMN, X, Y, X2, Y2} from './channel';\nimport * as vlEncoding from './encoding';\nimport {contains, duplicate, extend, keys, omit, pick} from './util';\n\nexport interface BaseSpec {\n  /**\n   * Name of the visualization for later reference.\n   */\n  name?: string;\n\n  /**\n   * An optional description of this mark for commenting purpose.\n   * This property has no effect on the output visualization.\n   */\n  description?: string;\n\n  /**\n   * An object describing the data source\n   */\n  data?: Data;\n\n  /**\n   * An object describing filter and new field calculation.\n   */\n  transform?: Transform;\n\n  /**\n   * Configuration object\n   */\n  config?: Config;\n}\n\nexport interface UnitSpec extends BaseSpec {\n  // FIXME description for top-level width\n  width?: number;\n\n  // FIXME description for top-level width\n  height?: number;\n\n  /**\n   * The mark type.\n   * One of `\"bar\"`, `\"circle\"`, `\"square\"`, `\"tick\"`, `\"line\"`,\n   * `\"area\"`, `\"point\"`, `\"rule\"`, and `\"text\"`.\n   */\n  mark: Mark;\n\n  /**\n   * A key-value mapping between encoding channels and definition of fields.\n   */\n  encoding?: UnitEncoding;\n}\n\n/**\n * Schema for a unit Vega-Lite specification, with the syntactic sugar extensions:\n * - `row` and `column` are included in the encoding.\n * - (Future) label, box plot\n *\n * Note: the spec could contain facet.\n *\n * @required [\"mark\", \"encoding\"]\n */\nexport interface ExtendedUnitSpec extends BaseSpec {\n  // FIXME description for top-level width\n  width?: number;\n\n  // FIXME description for top-level width\n  height?: number;\n\n  /**\n   * The mark type.\n   * One of `\"bar\"`, `\"circle\"`, `\"square\"`, `\"tick\"`, `\"line\"`,\n   * `\"area\"`, `\"point\"`, `\"rule\"`, and `\"text\"`.\n   */\n  mark: Mark;\n\n  /**\n   * A key-value mapping between encoding channels and definition of fields.\n   */\n  encoding?: Encoding;\n}\n\nexport interface FacetSpec extends BaseSpec {\n  facet: Facet;\n  spec: LayerSpec | UnitSpec;\n}\n\nexport interface LayerSpec extends BaseSpec {\n  // FIXME description for top-level width\n  width?: number;\n\n  // FIXME description for top-level width\n  height?: number;\n\n  /**\n   * Unit specs that will be layered.\n   */\n  layers: UnitSpec[];\n}\n\n/** This is for the future schema */\nexport interface ExtendedFacetSpec extends BaseSpec {\n  facet: Facet;\n\n  spec: ExtendedUnitSpec | FacetSpec;\n}\n\nexport type ExtendedSpec = ExtendedUnitSpec | FacetSpec | LayerSpec;\nexport type Spec = UnitSpec | FacetSpec | LayerSpec;\n\n/* Custom type guards */\n\nexport function isFacetSpec(spec: ExtendedSpec): spec is FacetSpec {\n  return spec['facet'] !== undefined;\n}\n\nexport function isExtendedUnitSpec(spec: ExtendedSpec): spec is ExtendedUnitSpec {\n  if (isSomeUnitSpec(spec)) {\n    const hasRow = has(spec.encoding, ROW);\n    const hasColumn = has(spec.encoding, COLUMN);\n\n    return hasRow || hasColumn;\n  }\n\n  return false;\n}\n\nexport function isUnitSpec(spec: ExtendedSpec): spec is UnitSpec {\n  if (isSomeUnitSpec(spec)) {\n    return !isExtendedUnitSpec(spec);\n  }\n\n  return false;\n}\n\nexport function isSomeUnitSpec(spec: ExtendedSpec): spec is ExtendedUnitSpec | UnitSpec {\n  return spec['mark'] !== undefined;\n}\n\nexport function isLayerSpec(spec: ExtendedSpec): spec is LayerSpec {\n  return spec['layers'] !== undefined;\n}\n\n\n/**\n * Decompose extended unit specs into composition of pure unit specs.\n */\n// TODO: consider moving this to another file.  Maybe vl.spec.normalize or vl.normalize\nexport function normalize(spec: ExtendedSpec): Spec {\n  if (isExtendedUnitSpec(spec)) {\n    return normalizeExtendedUnitSpec(spec);\n  }\n  if (isUnitSpec(spec)) {\n    return normalizeUnitSpec(spec);\n  }\n  return spec;\n}\n\nexport function normalizeExtendedUnitSpec(spec: ExtendedUnitSpec): Spec {\n    const hasRow = has(spec.encoding, ROW);\n    const hasColumn = has(spec.encoding, COLUMN);\n\n    // TODO: @arvind please  add interaction syntax here\n    let encoding = duplicate(spec.encoding);\n    delete encoding.column;\n    delete encoding.row;\n\n    return extend(\n      spec.name ? { name: spec.name } : {},\n      spec.description ? { description: spec.description } : {},\n      { data: spec.data },\n      spec.transform ? { transform: spec.transform } : {},\n      {\n        facet: extend(\n          hasRow ? { row: spec.encoding.row } : {},\n          hasColumn ? { column: spec.encoding.column } : {}\n        ),\n        spec: normalizeUnitSpec({\n          mark: spec.mark,\n          encoding: encoding\n        })\n      },\n      spec.config ? { config: spec.config } : {}\n    );\n}\n\nexport function normalizeUnitSpec(spec: UnitSpec): Spec {\n  const config = spec.config;\n  const overlayConfig = config && config.overlay;\n  const overlayWithLine = overlayConfig  && spec.mark === AREA &&\n    contains([AreaOverlay.LINEPOINT, AreaOverlay.LINE], overlayConfig.area);\n  const overlayWithPoint = overlayConfig && (\n    (overlayConfig.line && spec.mark === LINE) ||\n    (overlayConfig.area === AreaOverlay.LINEPOINT && spec.mark === AREA)\n  );\n\n  // TODO: thoroughly test\n  if (spec.mark === ERRORBAR) {\n    return normalizeErrorBarUnitSpec(spec);\n  }\n  // TODO: thoroughly test\n  if (isRanged(spec.encoding)) {\n    return normalizeRangedUnitSpec(spec);\n  }\n\n  if (isStacked(spec)) {\n    // We can't overlay stacked area yet!\n    return spec;\n  }\n\n  if (overlayWithPoint || overlayWithLine) {\n    return normalizeOverlay(spec, overlayWithPoint, overlayWithLine);\n  }\n  return spec;\n}\n\nexport function normalizeRangedUnitSpec(spec: UnitSpec): Spec {\n  if (spec.encoding) {\n    const hasX = has(spec.encoding, X);\n    const hasY = has(spec.encoding, Y);\n    const hasX2 = has(spec.encoding, X2);\n    const hasY2 = has(spec.encoding, Y2);\n    if ((hasX2 && !hasX) || (hasY2 && !hasY)) {\n      let normalizedSpec = duplicate(spec);\n      if (hasX2 && !hasX) {\n        normalizedSpec.encoding.x = normalizedSpec.encoding.x2;\n        delete normalizedSpec.encoding.x2;\n      }\n      if (hasY2 && !hasY) {\n        normalizedSpec.encoding.y = normalizedSpec.encoding.y2;\n        delete normalizedSpec.encoding.y2;\n      }\n\n      return normalizedSpec;\n    }\n  }\n  return spec;\n}\n\nexport function normalizeErrorBarUnitSpec(spec: UnitSpec): Spec {\n  // FIXME correctly deal with color and opacity\n\n  let layerSpec = extend(spec.name ? {name: spec.name} : {},\n    spec.description ? {description: spec.description} : {},\n    spec.data ? {data: spec.data} : {},\n    spec.transform ? {transform: spec.transform} : {},\n    spec.config ? {config: spec.config} : {}, {layers: []}\n  );\n  if (!spec.encoding) {\n    return layerSpec;\n  }\n  if (spec.mark === ERRORBAR) {\n    const ruleSpec = {\n      mark: RULE,\n      encoding: extend(\n        spec.encoding.x ? {x: duplicate(spec.encoding.x)} : {},\n        spec.encoding.y ? {y: duplicate(spec.encoding.y)} : {},\n        spec.encoding.x2 ? {x2: duplicate(spec.encoding.x2)} : {},\n        spec.encoding.y2 ? {y2: duplicate(spec.encoding.y2)} : {},\n        {})\n    };\n    const lowerTickSpec = {\n      mark: TICK,\n      encoding: extend(\n        spec.encoding.x ? {x: duplicate(spec.encoding.x)} : {},\n        spec.encoding.y ? {y: duplicate(spec.encoding.y)} : {},\n        spec.encoding.size ? {size: duplicate(spec.encoding.size)} : {},\n        {})\n    };\n    const upperTickSpec = {\n      mark: TICK,\n      encoding: extend({\n        x: spec.encoding.x2 ? duplicate(spec.encoding.x2) : duplicate(spec.encoding.x),\n        y: spec.encoding.y2 ? duplicate(spec.encoding.y2) : duplicate(spec.encoding.y)\n      }, spec.encoding.size ? {size: duplicate(spec.encoding.size)} : {})\n    };\n    layerSpec.layers.push(normalizeUnitSpec(ruleSpec));\n    layerSpec.layers.push(normalizeUnitSpec(lowerTickSpec));\n    layerSpec.layers.push(normalizeUnitSpec(upperTickSpec));\n  }\n  return layerSpec;\n}\n\nexport function normalizeOverlay(spec: UnitSpec, overlayWithPoint: boolean, overlayWithLine: boolean): LayerSpec {\n  let outerProps = ['name', 'description', 'data', 'transform'];\n  let baseSpec = omit(spec, outerProps.concat('config'));\n\n  let baseConfig = duplicate(spec.config);\n  delete baseConfig.overlay;\n  // TODO: remove shape, size\n\n  const layerSpec = extend(\n    pick(spec, outerProps),\n    { layers: [baseSpec] },\n    keys(baseConfig).length > 0 ? { config: baseConfig } : {}\n  );\n\n  if (overlayWithLine) {\n    // TODO: add name with suffix\n    let lineSpec = duplicate(baseSpec);\n    lineSpec.mark = LINE;\n    // TODO: remove shape, size\n    let markConfig = extend({}, defaultOverlayConfig.lineStyle, spec.config.overlay.lineStyle);\n    if (keys(markConfig).length > 0) {\n      lineSpec.config = {mark: markConfig};\n    }\n\n    layerSpec.layers.push(lineSpec);\n  }\n\n  if (overlayWithPoint) {\n    // TODO: add name with suffix\n    let pointSpec = duplicate(baseSpec);\n    pointSpec.mark = POINT;\n    let markConfig = extend({}, defaultOverlayConfig.pointStyle, spec.config.overlay.pointStyle);;\n    if (keys(markConfig).length > 0) {\n      pointSpec.config = {mark: markConfig};\n    }\n    layerSpec.layers.push(pointSpec);\n  }\n  return layerSpec;\n}\n\n// TODO: add vl.spec.validate & move stuff from vl.validate to here\n\nexport function fieldDefs(spec: ExtendedUnitSpec): FieldDef[] {\n  // TODO: refactor this once we have composition\n  return vlEncoding.fieldDefs(spec.encoding);\n};\n\nexport function isStacked(spec: ExtendedUnitSpec): boolean {\n  return stack(spec.mark, spec.encoding, spec.config) !== null;\n}\n",
    "import {Channel, STACK_GROUP_CHANNELS, X, Y} from './channel';\nimport {Config} from './config';\nimport {Encoding, has, isAggregate} from './encoding';\nimport {Mark, BAR, AREA} from './mark';\nimport {contains} from './util';\n\nexport enum StackOffset {\n  ZERO = 'zero' as any,\n  CENTER = 'center' as any,\n  NORMALIZE = 'normalize' as any,\n  NONE = 'none' as any\n}\n\nexport interface StackProperties {\n  /** Dimension axis of the stack ('x' or 'y'). */\n  groupbyChannel: Channel;\n\n  /** Measure axis of the stack ('x' or 'y'). */\n  fieldChannel: Channel;\n\n  /** Stack-by channels e.g., color, detail */\n  stackByChannels: Channel[];\n\n  /** Stack offset property. */\n  offset: StackOffset;\n}\n\nexport function stack(mark: Mark, encoding: Encoding, config: Config): StackProperties {\n  const stacked = (config && config.mark) ? config.mark.stacked : undefined;\n\n  // Should not have stack explicitly disabled\n  if (contains([StackOffset.NONE, null, false], stacked)) {\n    return null;\n  }\n\n  // Should have stackable mark\n  if (!contains([BAR, AREA], mark)) {\n    return null;\n  }\n\n  // Should be aggregate plot\n  if (!isAggregate(encoding)) {\n    return null;\n  }\n\n  // Should have grouping level of detail\n  const stackByChannels = STACK_GROUP_CHANNELS.reduce((sc, channel) => {\n    if (has(encoding, channel) && !encoding[channel].aggregate) {\n      sc.push(channel);\n    }\n    return sc;\n  }, []);\n\n  if (stackByChannels.length === 0) {\n    return null;\n  }\n\n  // Has only one aggregate axis\n  const hasXField = has(encoding, X);\n  const hasYField = has(encoding, Y);\n  const xIsAggregate = hasXField && !!encoding.x.aggregate;\n  const yIsAggregate = hasYField && !!encoding.y.aggregate;\n\n  if (xIsAggregate !== yIsAggregate) {\n    return {\n      groupbyChannel: xIsAggregate ? (hasYField ? Y : null) : (hasXField ? X : null),\n      fieldChannel: xIsAggregate ? X : Y,\n      stackByChannels: stackByChannels,\n      offset: stacked || StackOffset.ZERO\n    };\n  }\n  return null;\n}\n",
    "import {COLUMN, ROW, SHAPE, COLOR, Channel} from './channel';\nimport {DateTimeExpr, dateTimeExpr} from './datetime';\nimport {ScaleType} from './scale';\nimport {Dict, contains, keys, range} from './util';\n\nexport enum TimeUnit {\n  YEAR = 'year' as any,\n  MONTH = 'month' as any,\n  DAY = 'day' as any,\n  DATE = 'date' as any,\n  HOURS = 'hours' as any,\n  MINUTES = 'minutes' as any,\n  SECONDS = 'seconds' as any,\n  MILLISECONDS = 'milliseconds' as any,\n  YEARMONTH = 'yearmonth' as any,\n  // Note: don't add MONTH DATE because it will be incorrect\n  // since days on a leap year will be shifted by one if\n  // we only add\n  YEARMONTHDATE = 'yearmonthdate' as any,\n  YEARMONTHDATEHOURS = 'yearmonthdatehours' as any,\n  YEARMONTHDATEHOURSMINUTES = 'yearmonthdatehoursminutes' as any,\n  YEARMONTHDATEHOURSMINUTESSECONDS = 'yearmonthdatehoursminutesseconds' as any,\n  HOURSMINUTES = 'hoursminutes' as any,\n  HOURSMINUTESSECONDS = 'hoursminutesseconds' as any,\n  MINUTESSECONDS = 'minutesseconds' as any,\n  SECONDSMILLISECONDS = 'secondsmilliseconds' as any,\n  QUARTER = 'quarter' as any,\n  YEARQUARTER = 'yearquarter' as any,\n  QUARTERMONTH = 'quartermonth' as any,\n  YEARQUARTERMONTH = 'yearquartermonth' as any,\n}\n\n/** Time Unit that only corresponds to only one part of Date objects. */\nexport const SINGLE_TIMEUNITS = [\n  TimeUnit.YEAR,\n  TimeUnit.QUARTER,\n  TimeUnit.MONTH,\n  TimeUnit.DAY,\n  TimeUnit.DATE,\n  TimeUnit.HOURS,\n  TimeUnit.MINUTES,\n  TimeUnit.SECONDS,\n  TimeUnit.MILLISECONDS,\n];\n\nconst SINGLE_TIMEUNIT_INDEX: Dict<boolean> = SINGLE_TIMEUNITS.reduce((d, timeUnit) => {\n  d[timeUnit] = true;\n  return d;\n}, {} as Dict<boolean>);\n\nexport function isSingleTimeUnit(timeUnit: TimeUnit) {\n  return !!SINGLE_TIMEUNIT_INDEX[timeUnit];\n}\n\n/**\n * Converts a date to only have the measurements relevant to the specified unit\n * i.e. ('yearmonth', '2000-12-04 07:58:14') -> '2000-12-01 00:00:00'\n * Note: the base date is Jan 01 1900 00:00:00\n */\nexport function convert(unit: TimeUnit, date: Date): Date {\n  const result: Date = new Date(0, 0, 1, 0, 0, 0, 0); // start with uniform date\n  SINGLE_TIMEUNITS.forEach(function(singleUnit) {\n    if (containsTimeUnit(unit, singleUnit)) {\n      switch (singleUnit) {\n        case TimeUnit.DAY:\n          throw new Error('Cannot convert to TimeUnits containing \\'day\\'');\n        case TimeUnit.YEAR:\n          result.setFullYear(date.getFullYear());\n          break;\n        case TimeUnit.QUARTER:\n          // indicate quarter by setting month to be the first of the quarter i.e. may (4) -> april (3)\n          result.setMonth((Math.floor(date.getMonth() / 3)) * 3);\n          break;\n        case TimeUnit.MONTH:\n          result.setMonth(date.getMonth());\n          break;\n        case TimeUnit.DATE:\n          result.setDate(date.getDate());\n          break;\n        case TimeUnit.HOURS:\n          result.setHours(date.getHours());\n          break;\n        case TimeUnit.MINUTES:\n          result.setMinutes(date.getMinutes());\n          break;\n        case TimeUnit.SECONDS:\n          result.setSeconds(date.getSeconds());\n          break;\n        case TimeUnit.MILLISECONDS:\n          result.setMilliseconds(date.getMilliseconds());\n          break;\n      }\n    }\n  });\n\n  return result;\n}\n\nexport const MULTI_TIMEUNITS = [\n  TimeUnit.YEARQUARTER,\n  TimeUnit.YEARQUARTERMONTH,\n  TimeUnit.YEARMONTH,\n  TimeUnit.YEARMONTHDATE,\n  TimeUnit.YEARMONTHDATEHOURS,\n  TimeUnit.YEARMONTHDATEHOURSMINUTES,\n  TimeUnit.YEARMONTHDATEHOURSMINUTESSECONDS,\n  TimeUnit.QUARTERMONTH,\n  TimeUnit.HOURSMINUTES,\n  TimeUnit.HOURSMINUTESSECONDS,\n  TimeUnit.MINUTESSECONDS,\n  TimeUnit.SECONDSMILLISECONDS,\n];\n\nconst MULTI_TIMEUNIT_INDEX: Dict<boolean> = MULTI_TIMEUNITS.reduce((d, timeUnit) => {\n  d[timeUnit] = true;\n  return d;\n}, {} as Dict<boolean>);\n\nexport function isMultiTimeUnit(timeUnit: TimeUnit) {\n  return !!MULTI_TIMEUNIT_INDEX[timeUnit];\n}\n\nexport const TIMEUNITS = SINGLE_TIMEUNITS.concat(MULTI_TIMEUNITS);\n\n/** Returns true if fullTimeUnit contains the timeUnit, false otherwise. */\nexport function containsTimeUnit(fullTimeUnit: TimeUnit, timeUnit: TimeUnit) {\n  let fullTimeUnitStr = fullTimeUnit.toString();\n  let timeUnitStr = timeUnit.toString();\n  const index = fullTimeUnitStr.indexOf(timeUnitStr);\n  return index > -1 &&\n    (\n      timeUnit !== TimeUnit.SECONDS ||\n      index === 0 ||\n      fullTimeUnitStr.charAt(index-1) !== 'i' // exclude milliseconds\n    );\n}\n\nexport function defaultScaleType(timeUnit: TimeUnit) {\n   switch (timeUnit) {\n    case TimeUnit.HOURS:\n    case TimeUnit.DAY:\n    case TimeUnit.MONTH:\n    case TimeUnit.QUARTER:\n      return ScaleType.ORDINAL;\n  }\n  // date, year, minute, second, yearmonth, monthday, ...\n  return ScaleType.TIME;\n}\n\n/**\n * Returns Vega expresssion for a given timeUnit and fieldRef\n */\nexport function fieldExpr(fullTimeUnit: TimeUnit, field: string): string {\n  const fieldRef = 'datum[\"' + field + '\"]';\n\n  function func(timeUnit: TimeUnit) {\n    if (timeUnit === TimeUnit.QUARTER) {\n      // Divide by 3 to get the corresponding quarter number, multiply by 3\n      // to scale to the first month of the corresponding quarter(0,3,6,9).\n      return 'floor(month(' + fieldRef + ')' + '/3)';\n    } else {\n      return timeUnit + '(' + fieldRef + ')' ;\n    }\n  }\n\n  let d: DateTimeExpr = SINGLE_TIMEUNITS.reduce((_d, tu: TimeUnit) => {\n    if (containsTimeUnit(fullTimeUnit, tu)) {\n      _d[tu] = func(tu);\n    }\n    return _d;\n  }, {});\n\n  if (d.day && keys(d).length > 1) {\n    console.warn('Time unit \"'+ fullTimeUnit +'\" is not supported. We are replacing it with ',\n      (fullTimeUnit+'').replace('day', 'date')+'.');\n    delete d.day;\n    d.date = func(TimeUnit.DATE);\n  }\n\n  return dateTimeExpr(d);\n}\n\n/** Generate the complete raw domain. */\nexport function rawDomain(timeUnit: TimeUnit, channel: Channel) {\n  if (contains([ROW, COLUMN, SHAPE, COLOR], channel)) {\n    return null;\n  }\n\n  switch (timeUnit) {\n    case TimeUnit.SECONDS:\n      return range(0, 60);\n    case TimeUnit.MINUTES:\n      return range(0, 60);\n    case TimeUnit.HOURS:\n      return range(0, 24);\n    case TimeUnit.DAY:\n      return range(0, 7);\n    case TimeUnit.DATE:\n      return range(1, 32);\n    case TimeUnit.MONTH:\n      return range(0, 12);\n    case TimeUnit.QUARTER:\n      return [0,3,6,9];\n  }\n\n  return null;\n}\n\n/** returns the smallest nice unit for scale.nice */\nexport function smallestUnit(timeUnit): string {\n  if (!timeUnit) {\n    return undefined;\n  }\n\n  if (containsTimeUnit(timeUnit, TimeUnit.SECONDS)) {\n    return 'second';\n  }\n\n  if (containsTimeUnit(timeUnit, TimeUnit.MINUTES)) {\n    return 'minute';\n  }\n\n  if (containsTimeUnit(timeUnit, TimeUnit.HOURS)) {\n    return 'hour';\n  }\n\n  if (containsTimeUnit(timeUnit, TimeUnit.DAY) ||\n      containsTimeUnit(timeUnit, TimeUnit.DATE)) {\n    return 'day';\n  }\n\n  if (containsTimeUnit(timeUnit, TimeUnit.MONTH)) {\n    return 'month';\n  }\n\n  if (containsTimeUnit(timeUnit, TimeUnit.YEAR)) {\n    return 'year';\n  }\n  return undefined;\n}\n\n/** returns the template name used for axis labels for a time unit */\nexport function template(timeUnit: TimeUnit, field: string, shortTimeLabels: boolean): string {\n  if (!timeUnit) {\n    return undefined;\n  }\n\n  let dateComponents = [];\n\n  if (containsTimeUnit(timeUnit, TimeUnit.YEAR)) {\n    dateComponents.push(shortTimeLabels ? '%y' : '%Y');\n  }\n\n  if (containsTimeUnit(timeUnit, TimeUnit.QUARTER)) {\n   // special template for quarter\n    dateComponents.push('\\'}}Q{{' + field + ' | quarter}}{{' + field + ' | time:\\'');\n  }\n\n  if (containsTimeUnit(timeUnit, TimeUnit.MONTH)) {\n    dateComponents.push(shortTimeLabels ? '%b' : '%B');\n  }\n\n  if (containsTimeUnit(timeUnit, TimeUnit.DAY)) {\n    dateComponents.push(shortTimeLabels ? '%a' : '%A');\n  } else if (containsTimeUnit(timeUnit, TimeUnit.DATE)) {\n    dateComponents.push('%d');\n  }\n\n  let timeComponents = [];\n\n  if (containsTimeUnit(timeUnit, TimeUnit.HOURS)) {\n    timeComponents.push('%H');\n  }\n  if (containsTimeUnit(timeUnit, TimeUnit.MINUTES)) {\n    timeComponents.push('%M');\n  }\n  if (containsTimeUnit(timeUnit, TimeUnit.SECONDS)) {\n    timeComponents.push('%S');\n  }\n  if (containsTimeUnit(timeUnit, TimeUnit.MILLISECONDS)) {\n    timeComponents.push('%L');\n  }\n\n  let out = [];\n  if (dateComponents.length > 0) {\n    out.push(dateComponents.join('-'));\n  }\n  if (timeComponents.length > 0) {\n    out.push(timeComponents.join(':'));\n  }\n\n  if (out.length > 0) {\n    // clean up empty formatting expressions that may have been generated by the quarter time unit\n    const template = '{{' + field + ' | time:\\'' + out.join(' ') + '\\'}}';\n\n    // FIXME: Remove these RegExp Hacks!!!\n    const escapedField = field.replace(/(\\[|\\])/g, '\\\\$1'); // excape field for use in Regex\n    return template.replace(new RegExp('{{' + escapedField + ' \\\\| time:\\'\\'}}', 'g'), ''); // remove empty templates with Regex\n  } else {\n    return undefined;\n  }\n}\n\n",
    "/** Constants and utilities for data type */\n\nexport enum Type {\n  QUANTITATIVE = 'quantitative' as any,\n  ORDINAL = 'ordinal' as any,\n  TEMPORAL = 'temporal' as any,\n  NOMINAL = 'nominal' as any\n}\n\nexport const QUANTITATIVE = Type.QUANTITATIVE;\nexport const ORDINAL = Type.ORDINAL;\nexport const TEMPORAL = Type.TEMPORAL;\nexport const NOMINAL = Type.NOMINAL;\n\n/**\n * Mapping from full type names to short type names.\n * @type {Object}\n */\nexport const SHORT_TYPE = {\n  quantitative: 'Q',\n  temporal: 'T',\n  nominal: 'N',\n  ordinal: 'O'\n};\n/**\n * Mapping from short type names to full type names.\n * @type {Object}\n */\nexport const TYPE_FROM_SHORT_TYPE = {\n  Q: QUANTITATIVE,\n  T: TEMPORAL,\n  O: ORDINAL,\n  N: NOMINAL\n};\n\n/**\n * Get full, lowercase type name for a given type.\n * @param  type\n * @return Full type name.\n */\nexport function getFullName(type: Type): Type {\n  const typeString = <any>type;  // force type as string so we can translate short types\n  return TYPE_FROM_SHORT_TYPE[typeString.toUpperCase()] || // short type is uppercase by default\n         typeString.toLowerCase();\n}\n",
    "/// <reference path=\"../typings/datalib.d.ts\"/>\n/// <reference path=\"../typings/json-stable-stringify.d.ts\"/>\n\nimport * as stringify from 'json-stable-stringify';\nexport {keys, extend, duplicate, isArray, vals, truncate, toMap, isObject, isString, isNumber, isBoolean} from 'datalib/src/util';\nimport {duplicate as _duplicate} from 'datalib/src/util';\nimport {isString, isNumber, isBoolean} from 'datalib/src/util';\n\n/**\n * Creates an object composed of the picked object properties.\n *\n * Example:  (from lodash)\n *\n * var object = { 'a': 1, 'b': '2', 'c': 3 };\n * pick(object, ['a', 'c']);\n * // → { 'a': 1, 'c': 3 }\n *\n */\nexport function pick(obj: any, props: string[]) {\n  let copy = {};\n  props.forEach((prop) => {\n    if (obj.hasOwnProperty(prop)) {\n      copy[prop] = obj[prop];\n    }\n  });\n  return copy;\n}\n\n// Copied from datalib\nexport function range(start: number, stop?: number, step?: number): Array<number> {\n  if (arguments.length < 3) {\n    step = 1;\n    if (arguments.length < 2) {\n      stop = start;\n      start = 0;\n    }\n  }\n  if ((stop - start) / step === Infinity) {\n    throw new Error('Infinite range');\n  }\n  var range = [], i = -1, j;\n  if (step < 0) {\n    /* tslint:disable */\n    while ((j = start + step * ++i) > stop) {\n      range.push(j);\n    }\n  } else {\n    while ((j = start + step * ++i) < stop) {\n      range.push(j);\n    }\n    /* tslint:enable */\n  }\n  return range;\n};\n\n/**\n * The opposite of _.pick; this method creates an object composed of the own\n * and inherited enumerable string keyed properties of object that are not omitted.\n */\nexport function omit(obj: any, props: string[]) {\n  let copy = _duplicate(obj);\n  props.forEach((prop) => {\n    delete copy[prop];\n  });\n  return copy;\n}\n\nexport function hash(a: any) {\n  if (isString(a) || isNumber(a) || isBoolean(a)) {\n    return String(a);\n  }\n  return stringify(a);\n}\n\nexport function contains<T>(array: Array<T>, item: T) {\n  return array.indexOf(item) > -1;\n}\n\n/** Returns the array without the elements in item */\nexport function without<T>(array: Array<T>, excludedItems: Array<T>) {\n  return array.filter(function(item) {\n    return !contains(excludedItems, item);\n  });\n}\n\nexport function union<T>(array: Array<T>, other: Array<T>) {\n  return array.concat(without(other, array));\n}\n\nexport function forEach(obj, f: (a, d, k, o) => any, thisArg?) {\n  if (obj.forEach) {\n    obj.forEach.call(thisArg, f);\n  } else {\n    for (let k in obj) {\n      if (obj.hasOwnProperty(k)) {\n        f.call(thisArg, obj[k], k, obj);\n      }\n    }\n  }\n}\n\nexport function reduce(obj, f: (a, i, d, k, o) => any, init, thisArg?) {\n  if (obj.reduce) {\n    return obj.reduce.call(thisArg, f, init);\n  } else {\n    for (let k in obj) {\n      if (obj.hasOwnProperty(k)) {\n        init = f.call(thisArg, init, obj[k], k, obj);\n      }\n    }\n    return init;\n  }\n}\n\nexport function map(obj, f: (a, d, k, o) => any, thisArg?) {\n  if (obj.map) {\n    return obj.map.call(thisArg, f);\n  } else {\n    let output = [];\n    for (let k in obj) {\n      if (obj.hasOwnProperty(k)) {\n        output.push(f.call(thisArg, obj[k], k, obj));\n      }\n    }\n    return output;\n  }\n}\n\nexport function some<T>(arr: Array<T>, f: (d: T, k?, i?) => boolean) {\n  let i = 0;\n  for (let k = 0; k<arr.length; k++) {\n    if (f(arr[k], k, i++)) {\n      return true;\n    }\n  }\n  return false;\n}\n\nexport function every<T>(arr: Array<T>, f: (d: T, k?, i?) => boolean) {\n  let i = 0;\n  for (let k = 0; k<arr.length; k++) {\n    if (!f(arr[k], k, i++)) {\n      return false;\n    }\n  }\n  return true;\n}\n\nexport function flatten(arrays: any[]) {\n  return [].concat.apply([], arrays);\n}\n\nexport function mergeDeep(dest, ...src: any[]) {\n  for (let i = 0; i < src.length; i++) {\n    dest = deepMerge_(dest, src[i]);\n  }\n  return dest;\n};\n\n// recursively merges src into dest\nfunction deepMerge_(dest, src) {\n  if (typeof src !== 'object' || src === null) {\n    return dest;\n  }\n\n  for (let p in src) {\n    if (!src.hasOwnProperty(p)) {\n      continue;\n    }\n    if (src[p] === undefined) {\n      continue;\n    }\n    if (typeof src[p] !== 'object' || src[p] === null) {\n      dest[p] = src[p];\n    } else if (typeof dest[p] !== 'object' || dest[p] === null) {\n      dest[p] = mergeDeep(src[p].constructor === Array ? [] : {}, src[p]);\n    } else {\n      mergeDeep(dest[p], src[p]);\n    }\n  }\n  return dest;\n}\n\nexport function unique<T>(values: T[], f?: (item: T) => string) {\n  let results = [];\n  var u = {}, v, i, n;\n  for (i = 0, n = values.length; i < n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (v in u) {\n      continue;\n    }\n    u[v] = 1;\n    results.push(values[i]);\n  }\n  return results;\n};\n\nexport function warning(message: any) {\n  console.warn('[VL Warning]', message);\n}\n\nexport function error(message: any) {\n  console.error('[VL Error]', message);\n}\n\nexport interface Dict<T> {\n  [key: string]: T;\n}\n\nexport type StringSet = Dict<boolean>;\n\n/**\n * Returns true if the two dicitonaries disagree. Applies only to defioned values.\n */\nexport function differ<T>(dict: Dict<T>, other: Dict<T>) {\n  for (let key in dict) {\n    if (dict.hasOwnProperty(key)) {\n      if (other[key] && dict[key] && other[key] !== dict[key]) {\n        return true;\n      }\n    }\n  }\n  return false;\n}\n",
    "import {ExtendedUnitSpec} from './spec';\n\n// TODO: move to vl.spec.validator?\n\nimport {toMap} from './util';\nimport {BAR} from './mark';\n\ninterface RequiredChannelMap {\n  [mark: string]: Array<string>;\n}\n\n/**\n * Required Encoding Channels for each mark type\n * @type {Object}\n */\nexport const DEFAULT_REQUIRED_CHANNEL_MAP: RequiredChannelMap = {\n  text: ['text'],\n  line: ['x', 'y'],\n  area: ['x', 'y']\n};\n\ninterface SupportedChannelMap {\n  [mark: string]: {\n    [channel: string]: number\n  };\n}\n\n/**\n * Supported Encoding Channel for each mark type\n */\nexport const DEFAULT_SUPPORTED_CHANNEL_TYPE: SupportedChannelMap = {\n  bar: toMap(['row', 'column', 'x', 'y', 'size', 'color', 'detail']),\n  line: toMap(['row', 'column', 'x', 'y', 'color', 'detail']), // TODO: add size when Vega supports\n  area: toMap(['row', 'column', 'x', 'y', 'color', 'detail']),\n  tick: toMap(['row', 'column', 'x', 'y', 'color', 'detail']),\n  circle: toMap(['row', 'column', 'x', 'y', 'color', 'size', 'detail']),\n  square: toMap(['row', 'column', 'x', 'y', 'color', 'size', 'detail']),\n  point: toMap(['row', 'column', 'x', 'y', 'color', 'size', 'detail', 'shape']),\n  text: toMap(['row', 'column', 'size', 'color', 'text']) // TODO(#724) revise\n};\n\n// TODO: consider if we should add validate method and\n// requires ZSchema in the main vega-lite repo\n\n/**\n * Further check if encoding mapping of a spec is invalid and\n * return error if it is invalid.\n *\n * This checks if\n * (1) all the required encoding channels for the mark type are specified\n * (2) all the specified encoding channels are supported by the mark type\n * @param  {[type]} spec [description]\n * @param  {RequiredChannelMap  = DefaultRequiredChannelMap}  requiredChannelMap\n * @param  {SupportedChannelMap = DefaultSupportedChannelMap} supportedChannelMap\n * @return {String} Return one reason why the encoding is invalid,\n *                  or null if the encoding is valid.\n */\nexport function getEncodingMappingError(spec: ExtendedUnitSpec,\n  requiredChannelMap: RequiredChannelMap = DEFAULT_REQUIRED_CHANNEL_MAP,\n  supportedChannelMap: SupportedChannelMap = DEFAULT_SUPPORTED_CHANNEL_TYPE\n  ) {\n  let mark = spec.mark;\n  let encoding = spec.encoding;\n  let requiredChannels = requiredChannelMap[mark];\n  let supportedChannels = supportedChannelMap[mark];\n\n  for (let i in requiredChannels) { // all required channels are in encoding`\n    if (!(requiredChannels[i] in encoding)) {\n      return 'Missing encoding channel \\\"' + requiredChannels[i] +\n        '\\\" for mark \\\"' + mark + '\\\"';\n    }\n  }\n\n  for (let channel in encoding) { // all channels in encoding are supported\n    if (!supportedChannels[channel]) {\n      return 'Encoding channel \\\"' + channel +\n        '\\\" is not supported by mark type \\\"' + mark + '\\\"';\n    }\n  }\n\n  if (mark === BAR && !encoding.x && !encoding.y) {\n    return 'Missing both x and y for bar';\n  }\n\n  return null;\n}\n",
    "import {isArray} from './util';\nimport {ScaleType, NiceTime} from './scale';\n\nexport interface VgData {\n  name: string;\n  source?: string;\n  values?: any;\n  format?: any;\n  url?: any;\n  transform?: any;\n}\n\ntype VgParentRef = {\n  parent: string\n};\n\ntype VgFieldRef = string | VgParentRef | VgParentRef[];\n\nexport type VgDataRef = {\n  data: string,\n  field: VgFieldRef,\n  sort: boolean | {\n    field: VgFieldRef,\n    op: string\n  }\n};\n\nexport type VgValueRef = {\n  value?: any,\n  field?: string | {\n    datum?: string,\n    group?: string,\n    parent?: string\n  },\n  template?: string,\n  scale?: string, // TODO: object\n  mult?: number,\n  offset?: number,\n  band?: boolean\n}\n\nexport type UnionedDomain = {\n  fields: VgDataRef[]\n};\n\nexport type VgScale = {\n  name: string,\n  type: ScaleType,\n  domain?: any[] | UnionedDomain | VgDataRef,\n  domainMin?: any,\n  domainMax?: any\n  range?: any[] | VgDataRef | string,\n  rangeMin?: any,\n  rangeMax?: any,\n\n  bandSize?: number,\n  clamp?: boolean,\n  exponent?: number,\n  nice?: boolean | NiceTime,\n  padding?: number,\n  points?: boolean,\n  reverse?: boolean,\n  round?: boolean,\n  zero?: boolean\n}\n\nexport function isUnionedDomain(domain: any[] | UnionedDomain | VgDataRef): domain is UnionedDomain {\n  if (!isArray(domain)) {\n    return 'fields' in domain;\n  }\n  return false;\n}\n\nexport function isDataRefDomain(domain: any[] | UnionedDomain | VgDataRef): domain is VgDataRef {\n  if (!isArray(domain)) {\n    return 'data' in domain;\n  }\n  return false;\n}\n\n// TODO: declare\nexport type VgMarkGroup = any;\nexport type VgAxis = any;\nexport type VgLegend = any;\nexport type VgTransform = any;\n\nexport interface VgStackTransform {\n  type: string;\n  offset?: any;\n  groupby: any;\n  field: any;\n  sortby: any;\n  output: any;\n}\n",
    "export import axis = require('./axis');\nexport import aggregate = require('./aggregate');\nexport import bin = require('./bin');\nexport import channel = require('./channel');\nexport const compile = require('./compile/compile').compile;\nexport import config = require('./config');\nexport import data = require('./data');\nexport import datetime = require('./datetime');\nexport import encoding = require('./encoding');\nexport import facet = require('./facet');\nexport import fieldDef = require('./fielddef');\nexport import legend = require('./legend');\nexport import mark = require('./mark');\nexport import scale = require('./scale');\nexport import shorthand = require('./shorthand');\nexport import sort = require('./sort');\nexport import spec = require('./spec');\nexport import stack = require('./stack');\nexport import timeUnit = require('./timeunit');\nexport import transform = require('./transform');\nexport import type = require('./type');\nexport import util = require('./util');\nexport import validate = require('./validate');\n\nexport const version = '__VERSION__';\n"
  ]
}